<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Guy Lewis Steele Jr ©1978 (text and code)" />
  <meta name="author" content="Roger Turner ©2025 (markup and transcriber notes)" />
  <meta name="keywords" content="compiler, continuation passing, control
structures, environments, lambda calculus, lexical
scoping, LISP, optimization, macros, procedure
integration, SCHEME, source-to-source transformation, tail recursion" />
  <title>RABBIT- A Compiler for SCHEME (The Lambda Papers)</title>
  <style>
html {
font-size: 12pt;
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 36em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: blue;
}
a:visited {
color: blue;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
background-color: #1a1a1a;
border: none;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
</style>
  <style>
:root { 
background-color: color-mix(in oklab, Canvas 85%, #808080 15%);
color: color-mix(in oklab, CanvasText 85%, #808080 15%);
color-scheme: light dark; }
@media print {
hr, .pb {
break-before: always;
page-break-before: always }
div.box, div.npb, section.npb, pre, img {
break-inside: avoid-page;
page-break-inside: avoid }
img {
object-fit: scale-down }
body {
padding-top: 25px;
padding-bottom: 25px }
}
code {
font-family: Greybeard, Menlo, Monaco, Consolas, "Lucida Console", monospace }
body {
font-family: Bodoni, serif;
text-wrap: pretty;
max-width: 40em;
padding-right: 30px;
overflow-wrap: normal;
line-height: 1.2;
hyphens: none }
header {
margin-bottom: 1.0em }
h1 {
font-size: 1.2em;
margin-top: 0;
margin-bottom: 0.5em }
h2 {
font-size: 1.2em;
margin-top: 1.0em }
h4 { margin-top: 0.85em;
margin-bottom: 0;
padding-bottom: 0 }
h4 + p {
margin-top: 0;
margin-bottom: 0.85em }
#notes p, #references p, #bibliography p {
margin-top: 0 }
hr {
margin-top: 3em }
dd {
margin-bottom: 0.85em }
pre code { 
text-wrap: nowrap;
overflow-x: scroll;
font-size: 75% }
p code, .line-block code, figcaption code, h3 code, dt code { 
font-size: 85% }
code em {
font-style: italic } 
.large {
font-size: 150% }
.small {
font-size: 80% }
.sc { 
font-size: 92% }
.in {
margin-left: 1em }
.in5 {
margin-left: 5em }
.ti {
text-indent: -1em;
padding-left: 1em;
margin-top: -0.85em }
.ti5 {
text-indent: -5em;
padding-left: 5em;
margin-top: -0.85em }
div.ti2 p {
text-indent: -2em;
padding-left: 2em;
margin-top: -0.85em }
.fr {
float: right }
.fl {
float: left }
.fwn {
font-weight: normal }
li::marker {
content: '(' counters(list-item) ') '; }
div.box {
padding: 0 0 0.5em 1em;
border: 1px solid }
figure {
margin: 1em 0;
width: 100% }
figcaption {
padding-top: 1em;
text-align: center }
a:hover {
text-decoration: underline }
a:any-link {
color: AccentColor }
</style>
</head>
<body>
<div style="line-height: 1.05">
<div style="text-align: center">
<h1>
<p><span class="large">RABBIT:</span><br />
</p>
<p><span class="large">A Compiler for SCHEME</span><br />
</p>
(A Dialect of LISP)
</h1>
<p><br />
A Study in<br />
</p>
<p><span class="large">Compiler Optimization</span><br />
</p>
<p>Based on Viewing<br />
LAMBDA as RENAME<br />
and<br />
PROCEDURE CALL as GOTO<br />
</p>
<p><br />
using the techniques of<br />
</p>
<p>Macro Definition of Control and Environment Structures<br />
Source-to-Source Transformation<br />
Procedure Integration<br />
and<br />
Tail-Recursion</p>
<p><br />
</p>
<p>Guy Lewis Steele Jr. <br />
</p>
<p>Massachusetts Institute of Technology<br />
</p>
<p>May 1978<br />
</div></p>
<p><br />
</p>
<p><br />
</p>
<p>Revised version of a dissertation submitted (under the title
“Compiler Optimization Based on Viewing LAMBDA as RENAME plus GOTO”) to
the Department of Electrical Engineering and Computer Science on May 12,
1977, in partial fulfillment of the requirements for the degree of
Master of Science.</p>
<p>This research was conducted at the Artificial Intelligence Laboratory
of the Massachusetts Institute of Technology. Support for the
Laboratory’s artificial intelligence research is provided in part by the
Advanced Research Projects Agency of the Department of Defense under
Office of Naval Research contract number N00014-75-C-0643.<br />
<br />
</p>
<div id="licence" class="ti small">
<p>{{<a href="https://dspace.mit.edu/bitstream/handle/1721.1/6913/AITR-474.pdf" title="Original pdf at MIT: dspace.mit.edu/bitstream/handle/1721.1/6913/AITR-474.pdf">RABBIT:
A Compiler for SCHEME (A Dialect of LISP)</a> © 1978 by Guy Lewis Steele
Jr, and this transcription, licensed
<a href="https://creativecommons.org/licenses/by-nc/4.0/" title="Creative Commons license deed: creativecommons.org/licenses/by-nc/4.0/">CC
BY-NC 4.0</a>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.785" cy="28.501" r="28.836"></circle>
	<path d="M37.441-3.5c8.951,0,16.572,3.125,22.857,9.372c3.008,3.009,5.295,6.448,6.857,10.314
		c1.561,3.867,2.344,7.971,2.344,12.314c0,4.381-0.773,8.486-2.314,12.313c-1.543,3.828-3.82,7.21-6.828,10.143
		c-3.123,3.085-6.666,5.448-10.629,7.086c-3.961,1.638-8.057,2.457-12.285,2.457s-8.276-0.808-12.143-2.429
		c-3.866-1.618-7.333-3.961-10.4-7.027c-3.067-3.066-5.4-6.524-7-10.372S5.5,32.767,5.5,28.5c0-4.229,0.809-8.295,2.428-12.2
		c1.619-3.905,3.972-7.4,7.057-10.486C21.08-0.394,28.565-3.5,37.441-3.5z M37.557,2.272c-7.314,0-13.467,2.553-18.458,7.657
		c-2.515,2.553-4.448,5.419-5.8,8.6c-1.354,3.181-2.029,6.505-2.029,9.972c0,3.429,0.675,6.734,2.029,9.913
		c1.353,3.183,3.285,6.021,5.8,8.516c2.514,2.496,5.351,4.399,8.515,5.715c3.161,1.314,6.476,1.971,9.943,1.971
		c3.428,0,6.75-0.665,9.973-1.999c3.219-1.335,6.121-3.257,8.713-5.771c4.99-4.876,7.484-10.99,7.484-18.344
		c0-3.543-0.648-6.895-1.943-10.057c-1.293-3.162-3.18-5.98-5.654-8.458C50.984,4.844,44.795,2.272,37.557,2.272z M37.156,23.187
		l-4.287,2.229c-0.458-0.951-1.019-1.619-1.685-2c-0.667-0.38-1.286-0.571-1.858-0.571c-2.856,0-4.286,1.885-4.286,5.657
		c0,1.714,0.362,3.084,1.085,4.113c0.724,1.029,1.791,1.544,3.201,1.544c1.867,0,3.181-0.915,3.944-2.743l3.942,2
		c-0.838,1.563-2,2.791-3.486,3.686c-1.484,0.896-3.123,1.343-4.914,1.343c-2.857,0-5.163-0.875-6.915-2.629
		c-1.752-1.752-2.628-4.19-2.628-7.313c0-3.048,0.886-5.466,2.657-7.257c1.771-1.79,4.009-2.686,6.715-2.686
		C32.604,18.558,35.441,20.101,37.156,23.187z M55.613,23.187l-4.229,2.229c-0.457-0.951-1.02-1.619-1.686-2
		c-0.668-0.38-1.307-0.571-1.914-0.571c-2.857,0-4.287,1.885-4.287,5.657c0,1.714,0.363,3.084,1.086,4.113
		c0.723,1.029,1.789,1.544,3.201,1.544c1.865,0,3.18-0.915,3.941-2.743l4,2c-0.875,1.563-2.057,2.791-3.541,3.686
		c-1.486,0.896-3.105,1.343-4.857,1.343c-2.896,0-5.209-0.875-6.941-2.629c-1.736-1.752-2.602-4.19-2.602-7.313
		c0-3.048,0.885-5.466,2.658-7.257c1.77-1.79,4.008-2.686,6.713-2.686C51.117,18.558,53.938,20.101,55.613,23.187z" />
</g>
</svg>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.637" cy="28.806" r="28.276"></circle>
	<g>
		<path d="M37.443-3.5c8.988,0,16.57,3.085,22.742,9.257C66.393,11.967,69.5,19.548,69.5,28.5c0,8.991-3.049,16.476-9.145,22.456
			C53.879,57.319,46.242,60.5,37.443,60.5c-8.649,0-16.153-3.144-22.514-9.43C8.644,44.784,5.5,37.262,5.5,28.5
			c0-8.761,3.144-16.342,9.429-22.742C21.101-0.415,28.604-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.553-18.457,7.657
			c-5.22,5.334-7.829,11.525-7.829,18.572c0,7.086,2.59,13.22,7.77,18.398c5.181,5.182,11.352,7.771,18.514,7.771
			c7.123,0,13.334-2.607,18.629-7.828c5.029-4.838,7.543-10.952,7.543-18.343c0-7.276-2.553-13.465-7.656-18.571
			C50.967,4.824,44.795,2.272,37.557,2.272z M46.129,20.557v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557
			c0-0.572,0.2-1.057,0.599-1.457c0.401-0.399,0.887-0.6,1.457-0.6h13.144c0.533,0,1.01,0.2,1.428,0.6
			C45.918,19.5,46.129,19.986,46.129,20.557z M33.042,12.329c0-3.008,1.485-4.514,4.458-4.514s4.457,1.504,4.457,4.514
			c0,2.971-1.486,4.457-4.457,4.457S33.042,15.3,33.042,12.329z" />
	</g>
</g>
</svg>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.47" cy="28.736" r="29.471"></circle>
	<g>
		<path d="M37.442-3.5c8.99,0,16.571,3.085,22.743,9.256C66.393,11.928,69.5,19.509,69.5,28.5c0,8.992-3.048,16.476-9.145,22.458
			C53.88,57.32,46.241,60.5,37.442,60.5c-8.686,0-16.19-3.162-22.513-9.485C8.644,44.728,5.5,37.225,5.5,28.5
			c0-8.762,3.144-16.343,9.429-22.743C21.1-0.414,28.604-3.5,37.442-3.5z M12.7,19.872c-0.952,2.628-1.429,5.505-1.429,8.629
			c0,7.086,2.59,13.22,7.77,18.4c5.219,5.144,11.391,7.715,18.514,7.715c7.201,0,13.409-2.608,18.63-7.829
			c1.867-1.79,3.332-3.657,4.398-5.602l-12.056-5.371c-0.421,2.02-1.439,3.667-3.057,4.942c-1.622,1.276-3.535,2.011-5.744,2.2
			v4.915h-3.714v-4.915c-3.543-0.036-6.782-1.312-9.714-3.827l4.4-4.457c2.094,1.942,4.476,2.913,7.143,2.913
			c1.104,0,2.048-0.246,2.83-0.743c0.78-0.494,1.172-1.312,1.172-2.457c0-0.801-0.287-1.448-0.858-1.943l-3.085-1.315l-3.771-1.715
			l-5.086-2.229L12.7,19.872z M37.557,2.214c-7.276,0-13.428,2.571-18.457,7.714c-1.258,1.258-2.439,2.686-3.543,4.287L27.786,19.7
			c0.533-1.676,1.542-3.019,3.029-4.028c1.484-1.009,3.218-1.571,5.2-1.686V9.071h3.715v4.915c2.934,0.153,5.6,1.143,8,2.971
			l-4.172,4.286c-1.793-1.257-3.619-1.885-5.486-1.885c-0.991,0-1.876,0.191-2.656,0.571c-0.781,0.381-1.172,1.029-1.172,1.943
			c0,0.267,0.095,0.533,0.285,0.8l4.057,1.83l2.8,1.257l5.144,2.285l16.397,7.314c0.535-2.248,0.801-4.533,0.801-6.857
			c0-7.353-2.552-13.543-7.656-18.573C51.005,4.785,44.831,2.214,37.557,2.214z" />
	</g>
</g>
</svg>
(Attribution-NonCommercial 4.0 International).<br /> Transcription by
Roger Turner: compiler source code omitted, links and {{transcriber
notes}} added.}}</p>
</div>
</div>
<p><hr></p>
<div style="line-height: 1.1">
<p><div style="text-align: center"> RABBIT: A Compiler for SCHEME (A
Dialect of LISP)</p>
<p>A Study in Compiler Optimization<br />
Based on Viewing LAMBDA as RENAME and PROCEDURE CALL as GOTO</p>
<p>using the techniques of<br />
Macro Definition of Control and Environment Structures,<br />
Source-to-Source Transformation, Procedure Integration, and
Tail-Recursion</p>
<p>Guy Lewis Steele Jr. <br />
Massachusetts Institute of Technology<br />
May 1978</p>
<section id="abstract" class="level2">
<h2>ABSTRACT</h2>
<p></div></p>
<p>We have developed a compiler for the lexically-scoped dialect of
<span class="sc">LISP</span> known as <span class="sc">SCHEME</span>.
The compiler knows relatively little about specific data manipulation
primitives such as arithmetic operators, but concentrates on general
issues of environment and control. Rather than having specialized
knowledge about a large variety of control and environment constructs,
the compiler handles only a small basis set which reflects the semantics
of lambda-calculus. All of the traditional imperative constructs, such
as sequencing, assignment, looping, <code>GOTO</code>, as well as many
standard <span class="sc">LISP</span> constructs such as
<code>AND</code>, <code>OR</code>, and <code>COND</code>, are expressed
as macros in terms of the applicative basis set. A small number of
optimization techniques, coupled with the treatment of function calls as
<code>GOTO</code> statements, serve to produce code as good as that
produced by more traditional compilers. The macro approach enables
speedy implementation of new constructs as desired without sacrificing
efficiency in the generated code.</p>
<p>A fair amount of analysis is devoted to determining whether
environments may be stack-allocated or must be heap-allocated.
Heap-allocated environments are necessary in general because <span class="sc">SCHEME</span> (unlike Algol 60 and Algol 68, for example)
allows procedures with free lexically scoped variables to be returned as
the values of other procedures; the Algol stack-allocation environment
strategy does not suffice. The methods used here indicate that a
heap-allocating generalization of the “display” technique leads to an
efficient implementation of such “upward funargs”. Moreover,
compile-time optimization and analysis can eliminate many “funargs”
entirely, and so far fewer environment structures need be allocated at
run time than might be expected.</p>
<p>A subset of <span class="sc">SCHEME</span> (rather than triples, for
example) serves as the representation intermediate between the optimized
<span class="sc">SCHEME</span> code and the final output code; code is
expressed in this subset in the so-called continuation-passing style. As
a subset of <span class="sc">SCHEME</span>, it enjoys the same
theoretical properties; one could even apply the same optimizer used on
the input code to the intermediate code. However, the subset is so
chosen that all temporary quantities are made manifest as variables, and
no control stack is needed to evaluate it. As a result, this apparently
applicative representation admits an imperative interpretation which
permits easy transcription to final imperative machine code. These
qualities suggest that an applicative language like <span class="sc">SCHEME</span> is a better candidate for an <span class="sc">UNCOL</span> than the more imperative candidates proposed to
date.</p>
<p>Thesis Supervisor: Gerald Jay Sussman<br />
Title: Associate Professor of Electrical Engineering</p>
</section>
</div>
<p><hr></p>
<section id="note" class="level2">
<h2><a href="#contents">Note</a></h2>
<p>The first part of this report is a slightly revised version of a
dissertation submitted in May 1977. Where it was of historical interest
to reflect changes in the <span class="sc">SCHEME</span> language which
ocurred in the following year and the effect they had on <span class="sc">RABBIT</span>, the text was left intact, with notes added of
the form, “Since the dissertation was written, thus-and-so occurred.”
The second part, the Appendix, was not part of the dissertation, and is
a complete listing of the source code for <span class="sc">RABBIT</span>, with extensive commentary.</p>
<p>It is intended that the first part should be self-contained, and
provide a qualitative overview of the compilation methods used in <span class="sc">RABBIT</span>. The second part is provided for those readers
who would like to examine the precise mechanisms used to carry out the
general methods.</p>
<p>Thus there are five levels of thoroughness at which the reader may
consume this document:</p>
<ol type="1">
<li>The reader who wishes only to skim is advised to read sections 1, 5,
6, possibly 7, 8A, 8B, 8C, 10, 11, and 12. This will give a basic
overview, including the use of macros and the optimizing
techniques.</li>
<li>The reader who also wants to know about the details of <span class="sc">SCHEME</span>, the run-time system, and a long example is
advised to read the entire main text (about a third of the
document).</li>
<li>The reader who wants to understand the low-level organization of the
algorithms, and read about the more tricky special cases, should read
the main text and then the commentary on the code.</li>
<li>The reader who additionally wants to understand the nit-picking
details should read the code along with the commentary.</li>
<li>The reader who wants a real feel for the techniques involved should
read the entire document, invent three new <span class="sc">SCHEME</span> constructs and write macros for them, and then
reimplement the compiler for another run-time environment. (He ought
please also to send a copy of any documents on such a project to this
author, who would be very interested!)</li>
</ol>
<p><hr></p>
</section>
<section id="acknowledgements" class="level2">
<h2><a href="#contents">Acknowledgements</a></h2>
<p>I would like to acknowledge the contributions to this work of the
following people and other entities:<br />
<br />
</p>
<div class="ti2">
<p>Gerald Jay Sussman, who is not only my thesis advisor but a colleague
and a good friend; who is fun to hack programs with; who not only
provided insights on the issues of programming, but also was willing to
give me a kick in the right direction when necessary;</p>
<p>Jon Doyle, one of the first real “users” of <span class="sc">SCHEME</span>, who was always willing to discuss my problems,
and who carefully proofread the thesis in one day when no one else would
or could;</p>
<p>Richard Zippel, the other first real <span class="sc">SCHEME</span>
user, who has discussed with me many possibilities for the practical use
of <span class="sc">SCHEME</span>-like languages in such large systems
as <span class="sc">MACSYMA</span>;</p>
<p>Carl Hewitt, whose actors metaphor inspired in part first <span class="sc">SCHEME</span> and then the investigations presented here;</p>
<p>Scott Fahlman, who has Great Ideas, and who paid some of his dues at
the same place I did;</p>
<p>Jon L White, resident <span class="sc">LISP</span> compiler expert
and agreeable office-mate, who likes both tea and <code>()</code>;</p>
<p>Dan Weinreb, Bernie Greenberg, Richard Stallman, Dave Moon, Howard
Cannon, Alan Bawden, Henry Baker, and Richard Greenblatt for their
companionship, advice, comments, enthusiasm, criticism, and/or
constructive opposition;</p>
<p>the rest of the gang at the AI Lab and Project MAC (loosely known as
the Lab for Computer Science), for their continued interest in my work
and for the pleasant social atmosphere they provide;</p>
<p>Bill Wulf, Charles Geschke, Richard Johnsson, Charles Weinstock, and
Steven Hobbs, whose work on <span class="sc">BLISS-11</span> I found a
great inspiration, for it told me that there was at least one beautiful
compiler already;</p>
<p>Dan Friedman and Dave Wise, who also know that <span class="sc">LISP</span> is the One True Way;</p>
<p>Dick Gabriel, a most singular person (that’s odd…), who knows that
Lapin is best dealt with gingerly;</p>
<p>the National Science Foundation, which provided the fellowship under
which this work was done;</p>
<p>Cindy Ellis and J.J. McCabe, who always treated me as just a regular
guy;</p>
<p>Julie Genovese, my main (and only) groupie;</p>
<p>the congregation at the Brighton Evangelical Congregational Church,
for their social and moral support;</p>
<p>Mittens Jr., our cat, who was willing to communicate when the rest of
the world was asleep;</p>
<p>Chuck, the peculiar poodle, who carried on as best she could after
Mittens Jr. had gone, and who still barks in the night;</p>
<p>my brother, David A. Steele, who has kept me up to date on cultural
affairs, and who probably understands me better than anyone else;</p>
<p>and my parents, Guy L. Steele Sr. and Nalora Steele, who provided
unbounded amounts of patience, encouragement, opportunity, and
support.</p>
</div>
<p><hr></p>
</section>
<section id="contents" class="level2">
<h2>Contents</h2>
<div style="line-height: 1.22">
<div class="line-block"><a href="#introduction">1.  
Introduction</a><br />
   <a href="#a.-background">A.   Background</a><br />
   <a href="#b.-the-thesis">B.   The Thesis</a><br />
<a href="#the-source-language---scheme">2.   The Source Language - <span class="sc">SCHEME</span></a><br />
<a href="#the-target-language">3.   The Target Language</a><br />
<a href="#the-target-machine">4.   The Target Machine</a><br />
<a href="#language-design-considerations">5.   Language Design
Considerations</a><br />
<a href="#the-use-of-macros">6.   The Use of Macros</a><br />
<a href="#the-imperative-treatment-of-applicative-constructs">7.   The
Imperative Treatment of Applicative Constructs</a><br />
<a href="#compilation-strategy">8.   Compilation Strategy</a><br />
   <a href="#a.-alpha-conversion-and-macro-expansion">A.  
Alpha-conversion and macro-expansion</a><br />
   <a href="#b.-preliminary-analysis">B.   Preliminary
analysis</a><br />
   <a href="#c.-optimization">C.   Optimization</a><br />
   <a href="#d.-conversion-to-continuation-passing-style">D.  
Conversion to Continuation-Passing Style</a><br />
   <a href="#e.-environment-and-closure-analysis">E.   Environment and
closure analysis</a><br />
   <a href="#f.-code-generation">F.   Code generation</a><br />
<a href="#example-compilation-of-iterative-factorial">9.   Example:
Compilation of Iterative Factorial</a><br />
<a href="#performance-measurements">10.   Performance
Measurements</a><br />
<a href="#comparison-with-other-work">11.   Comparison with Other
Work</a><br />
<a href="#conclusions-and-future-work">12.   Conclusions and Future
Work</a><br />
<a href="#notes">Notes</a><br />
  {<a href="#note-aset-is-imperative-1-2"><code>ASET&#39;</code> Is
Imperative</a>}<br />
  {<a href="#note-code-pointers">Code Pointers</a>}<br />
  {<a href="#note-continuation-variable-hack">Continuation Variable
Hack</a>}<br />
  {<a href="#note-dijkstras-opinion">Dijkstra’s Opinion</a>}<br />
  {<a href="#note-evaluation-for-control-1-2">Evaluation for
Control</a>}<br />
  {<a href="#note-evaluation-for-effect">Evaluation for
Effect</a>}<br />
  {<a href="#note-full-funarg-example">Full-Funarg Example</a>}<br />
  {<a href="#note-generalized-labels">Generalized
<code>LABELS</code></a>}<br />
  {<a href="#note-heap-allocated-contours">Heap-Allocated
Contours</a>}<br />
  {<a href="#note-loop-unrolling">Loop Unrolling</a>}<br />
  {<a href="#note-multiple-argument-continuations">Multiple-Argument
Continuations</a>}<br />
  {<a href="#note-non-deterministic-cps-conversion">Non-deterministic
CPS Conversion</a>}<br />
  {<a href="#note-non-deterministic-optimization">Non-deterministic
Optimization</a>}<br />
  {<a href="#note-non-quoted-aset">Non-quoted
<code>ASET</code></a>}<br />
  {<a href="#note-old-cps-algorithm">Old CPS Algorithm</a>}<br />
  {<a href="#note-operations-on-functions">Operations on
Functions</a>}<br />
  {<a href="#note-refinement-of-rabbit">Refinement of <span class="sc">RABBIT</span></a>}<br />
  {<a href="#note-side-effect-classifications">Side-Effect
Classifications</a>}<br />
  {<a href="#note-subroutinization">Subroutinization</a>}<br />
  {<a href="#note-tail-recursive-or">Tail-Recursive
<code>OR</code></a>}<br />
<a href="#references">References</a><br />
<a href="#appendix">Appendix</a></div>
</div>
<p><hr></p>
</section>
<section id="introduction" class="level2">
<h2><a href="#contents">1.   Introduction</a></h2>
<p>The work described here is a continuation (!) of that described in
[<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch1" title="[1] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>], [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp1" title="[1] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>],
and [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd1" title="[1] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>].
Before enumerating the points of the thesis, we summarize here each of
these documents.</p>
<section id="a.-background" class="level3">
<h3><a href="#contents">A.   Background</a></h3>
<p>In [<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch2" title="[2] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>] we (Gerald Jay Sussman and the author)
described the implementation of a dialect of <span class="sc">LISP</span> named <span class="sc">SCHEME</span> with the
properties of lexical scoping and tail-recursion; this implementation is
embedded within <span class="sc">MacLISP</span> [<a href="#moon-1-2-3-4-5" id="xmoon1" title="[1] Moon 1974, MACLISP Reference Manual, Revision 0">Moon</a>], a
version of <span class="sc">LISP</span> which does not have these
properties. The property of lexical scoping (that a variable can be
referenced only from points textually within the expression which binds
it) is a consequence of the fact that all functions are closed in the
“binding environment.” [<a href="#moses-1-2" id="xmoses1" title="[1] Moses 1970, The Function of FUNCTION in LISP">Moses</a>] That
is, <span class="sc">SCHEME</span> is a “full-funarg” <span class="sc">LISP</span> dialect. {Note <a href="#note-full-funarg-example" id="xfull-funarg-example" title="As an example of the difference between lexical and dynamic scoping, consider the classic case of the &#39;funarg problem&#39;. We have defined a function MAPCAR which, given a function and a list, produces a new list of the results of the function applied to each element of the given list ...">Full-Funarg
Example</a>} The property of tail-recursion implies that loops written
in an apparently recursive form will actually be executed in an
iterative fashion. Intuitively, function calls do not “push control
stack”; instead, it is argument evaluation which pushes control stack.
The two properties of lexical scoping and tail-recursion are not
independent. In most <span class="sc">LISP</span> systems [<a href="#lisp1.5m" id="xlisp1.5m" title="[1] McCarthy etal 1962, LISP 1.5 Programmer&#39;s Manual"><span class="sc">LISP1.5M</span></a>] [<a href="#moon-1-2-3-4-5" id="xmoon2" title="[2] Moon 1974, MACLISP Reference Manual, Revision 0">Moon</a>]
[<a href="#teitelman-1-2" id="xteitelman1" title="[1] Teitelman 1975, InterLISP Reference Manual. Revised edition">Teitelman</a>],
which use dynamic scoping rather than lexical, tail-recursion is
impossible because function calls must push control stack in order to be
able to undo the dynamic bindings after the return of the function. On
the other hand, it is possible to have a lexically scoped <span class="sc">LISP</span> which does not tail-recurse, but it is easily
seen that such an implementation only wastes storage space needlessly
compared to a tail-recursing implementation. [<a href="#steele-1-2-3-4-5" id="xste1" title="[1] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele</a>]
Together, these two properties cause <span class="sc">SCHEME</span> to
reflect lambda-calculus semantics much more closely than dynamically
scoped <span class="sc">LISP</span> systems. <span class="sc">SCHEME</span> also permits the treatment of functions as
full-fledged data objects; they may be passed as arguments, returned as
values, made part of composite data structures, and notated as
independent, unnamed (“anonymous”) entities. (Contrast this with most
<span class="sc">ALGOL</span>-like languages, in which a function can be
written only by declaring it and giving it a name; imagine being able to
use an integer value only by giving it a name in a declaration!) The
property of lexical scoping allows this to be done in a consistent
manner without the possibility of identifier conflicts (that is, <span class="sc">SCHEME</span> “solves the <span class="sc">FUNARG</span>
problem” [<a href="#moses-1-2" id="xmoses2" title="[2] Moses 1970, The Function of FUNCTION in LISP">Moses</a>]). In
[<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch3" title="[3] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>] we also discussed the technique of
“continuation-passing style”, a way of writing programs in <span class="sc">SCHEME</span> such that no function ever returns a value.</p>
<p>In [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp2" title="[2] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]
we explored ways of exploiting these properties to implement most
traditional programming constructs, such as assignment, looping, and
call-by-name, in terms of function application. Such applicative
(lambda-calculus) models of programming language constructs are
well-known to theoreticians (see [<a href="#stoy" id="xstoy" title="[1] Stoy 1977, Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory">Stoy</a>],
for example), but have not been used in a practical programming system.
All of these constructs are actually made available in <span class="sc">SCHEME</span> by macros which expand into these applicative
definitions. This technique has permitted the speedy implementation of a
rich user-level language in terms of a very small, easy-to-implement
basis set of primitive constructs. In [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp3" title="[3] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]
we continued the exploration of continuation-passing style, and noted
that the escape operator <code>CATCH</code> is easily modelled by
transforming a program into this style. We also pointed out that
transforming a program into this style enforces a particular order of
argument evaluation, and makes all intermediate computational quantities
manifest as variables.</p>
<p>In [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd2" title="[2] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
we examined more closely the issue of tail-recursion, and demonstrated
that the usual view of function calls as pushing a return address must
lead to an either inefficient or inconsistent implementation, while the
tail-recursive approach of <span class="sc">SCHEME</span> leads to a
uniform discipline in which function calls are treated as
<code>GOTO</code> statements which also pass arguments. We also noted
that a consequence of lexical scoping is that the only code which can
reference the value of a variable in a given environment is code which
is closed in that environment or which receives the value as an
argument; this in turn implies that a compiler can structure a run-time
environment in any arbitrary fashion, because it will compile all the
code which can reference that environment, and so can arrange for that
code to reference it in the appropriate manner. Such references do not
require any kind of search (as is commonly and incorrectly believed in
the <span class="sc">LISP</span> community because of early experience
with LISP interpreters which search a-lists) because the compiler can
determine the precise location of each variable in an environment at
compile time. It is not necessary to use a standard format, because
neither interpreted code nor other compiled code can refer to that
environment.</p>
<p>(This is to be constrasted with “spaghetti stacks” [<a href="#bobrow-and-wegbreit" id="xbobrow-and-wegbreit" title="[1] Bobrow and Wegbreit 1973, A Model and Stack Implementation of Multiple Environments">Bobrow
and Wegbreit</a>].) In [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd3" title="[3] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
we also carried on the analysis of continuation-passing style, and noted
that transforming a program into this style elucidates traditional
compilation issues such as register allocation because user variables
and intermediate quantities alike are made manifest as variables on an
equal footing. Appendix A of [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd4" title="[4] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
contained an algorithm for converting any <span class="sc">SCHEME</span>
program (not containing <code>ASET</code>) to continuation-passing
style.</p>
<p>We have implemented two compilers for the language <span class="sc">SCHEME</span>. The purpose was to explore compilation
techniques for a language modelled on lambda-calculus, using
lambda-calculus-style models of imperative programming constructs. Both
compilers use the strategy of converting the source program to
continuation-passing style.</p>
<p>The first compiler (known as <span class="sc">CHEAPY</span>) was
written as a throw-away implementation to test the concept of conversion
to continuation-passing style. The first half of <span class="sc">CHEAPY</span> is essentially the algorithm which appears in
Appendix A of [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd5" title="[5] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>],
and the second is a simple code generator with almost no optimization.
In conjunction with the writing of <span class="sc">CHEAPY</span>, the
<span class="sc">SCHEME</span> interpreter was modified to interface to
compiled functions. (This interface is described later in this
report.)</p>
<p>The second compiler, with which we are primarily concerned here, is
known as <span class="sc">RABBIT</span>. It, like <span class="sc">CHEAPY</span>, is written almost entirely in <span class="sc">SCHEME</span> (with minor exceptions due only to problems in
interfacing with certain <span class="sc">MacLISP</span> I/O
facilities). Unlike <span class="sc">CHEAPY</span>, it is fairly clever.
It is intended to demonstrate a number of optimization techniques
relevant to lexical environments and tail-recursive control structures.
(The code for <span class="sc">RABBIT</span>, with commentary, appears
in the Appendix.)</p>
</section>
<section id="b.-the-thesis" class="level3">
<h3><a href="#contents">B.   The Thesis</a></h3>
<ol type="1">
<li>Function calls are not expensive when compiled correctly; they
should be thought of as <code>GOTO</code> statements that happen to pass
arguments.</li>
<li>The combination of cheap function calls, lexical scoping,
tail-recursion, and “anonymous” notation of functions (which are not
independent properties of a language, but aspects of a single unified
approach) permits the definition of a wide variety of “imperative”
constructs in applicative terms. Because these properties result from
adhering to the principles of the well-known lambda-calculus [<a href="#church-1-2" id="xchurch1" title="[1] Church 1941, The Calculi of Lambda Conversion">Church</a>],
such definitions can be lifted intact from existing literature and used
directly.</li>
<li>A macro facility (the ability to specify syntactic transformations)
makes it practical to use these as the only definitions of imperative
constructs in a programming system. Such a facility makes it extremely
easy to define new constructs.</li>
<li>A few well-chosen optimization strategies enable the compilation of
these applicative definitions into the imperative low-level code which
one would expect from a traditional compiler.</li>
<li>The macro facility and the optimization techniques used by the
compiler can be conceptually unified. The same properties which make it
easy to write the macros make it easy to define optimizations correctly.
In the same way that many programming constructs are defined in terms of
a small, well- chosen basis set, so a large number of traditional
optimization techniques fall out as special cases of the few used in
<span class="sc">RABBIT</span>. This is no accident. The separate
treatment of a large and diverse set of constructs necessitates separate
optimization techniques for each. As the basis set of constructs is
reduced, so is the set of interesting transformations. If the basis set
is properly chosen, their combined effect is “multiplicative” rather
than “additive”.</li>
<li>The technique of compiling by converting to continuation-passing
style elucidates some important compilation issues in a natural way.
Intermediate quantities are made manifest; so is the precise order of
evaluation. Moreover, this is all expressed in a language isomorphic to
a subset of the source language <span class="sc">SCHEME</span>; as a
result the continuation-passing style version of a program inherits many
of the philosophical and practical advantages. For example, the same
optimization techniques can be applied at this level as at the original
source level. While the use of continuation-passing style may not make
the decisions any easier, it provides an effective and natural way to
express the results of those decisions.</li>
<li>Continuation-passing style, while apparently applicative in nature,
admits a peculiarly imperative interpretation as a consequence of the
facts that it requires no control stack to be evaluated and that no
functions ever return values. As a result, it is easily converted to an
imperative machine language.</li>
<li>A <span class="sc">SCHEME</span> compiler should ideally be a
designer of good data structures, since it may choose any representation
whatsoever for environments. <span class="sc">RABBIT</span> has a
rudimentary design knowledge, involving primarily the preferral of
registers to heap-allocated storage. However, there is room for
knowledge of “bit-diddling” representations.</li>
<li>We suggest that those who have tried to design useful <span class="sc">UNCOL</span>s (UNiversal Computer-Oriented Languages) [<a href="#sammet" id="xsammet" title="[1] Sammet 1969, Programming Languages: History and Fundamentals">Sammet</a>]
[<a href="#coleman" id="xcoleman" title="[1] Coleman 1974, JANUS: A Universal Intermediate Language">Coleman</a>]
have perhaps been thinking too imperatively, and worrying more about
data manipulation primitives than about environment and control issues.
As a result, proposed <span class="sc">UNCOL</span>s have been little
more than generalizations of contemporary machine languages. We suggest
that <span class="sc">SCHEME</span> makes an ideal <span class="sc">UNCOL</span> at two levels. The first level is the fully
applicative level, to which most source-language constructs are easily
reduced; the second is the continuation-passing style level, which is
easily reduced to machine language. We envision building a compiler in
three stages: (a) reduction of a user language to basic <span class="sc">SCHEME</span>, whether by macros, a parser of algebraic
syntax, or some other means; (b) optimization by means of <span class="sc">SCHEME</span>-level source-to-source transformations, and
conversion to continuation-passing style; and (c) generation of code for
a particular machine. <span class="sc">RABBIT</span> addresses itself to
the second stage. Data manipulation primitives are completely ignored at
this stage, and are just passed along from input to output. These
primitives, whether integer arithmetic, string concatenation and
parsing, or list structure manipulators, are chosen as a function of a
particular source language and a particular target machine. <span class="sc">RABBIT</span> deals only with fundamental environment and
control issues common to most modes of algorithmic expression.</li>
<li>While syntactic issues tend to be rather superficial, we point out
that algebraic syntax tends to obscure the fundamental nature of
function calling and tail-recursion by arbitrarily dividing functions
into syntactic classes such as “operators” and “functions”. ([<a href="#standish-1-2-3" id="xstandish1" title="[1] Standish etal 1976, The Irvine Program Transformation Catalogue">Standish</a>],
for example, uses much space to exhibit each conceptually singular
transformation in a multiplicity of syntactic manifestations.) The lack
of an “anonymous” notation for functions in most algebraic languages,
and the inability to treat functions as data objects, is a distinct
disadvantage. The uniformity of <span class="sc">LISP</span> syntax
makes these issues easier to deal with.</li>
</ol>
<p>To the LISP community in particular we address these additional
points:</p>
<ol start="11" type="1">
<li>Lexical scoping need not be as expensive as is commonly thought.
Experience with lexically-scoped <em>interpreters</em> is misleading;
lexical scoping is not inherently slower than dynamic scoping. While
some implementations may entail access through multiple levels of
structure, this occurs only under circumstances (accessing of variables
through multiple levels of closure) which could not even be expressed in
a dynamically scoped language. Unlike deep-bound dynamic variables,
compiled lexical access requires no search; unlike shallow-bound dynamic
variables, lexical binding does not require that values be put in a
canonical value cell. The compiler has complete discretion over the
manipulation of environments and variable values. The “display”
technique used in Algol implementations can be generalized to provide an
efficient solution to the <span class="sc">FUNARG</span> problem.</li>
<li>Lexical scoping does not necessarily make <span class="sc">LISP</span> programming unduly difficult. The very existence
of <span class="sc">RABBIT</span>, a working compiler some fifty pages
in length written in <span class="sc">SCHEME</span>, first implemented
in about a month, part-time, substantiates this claim (which is,
however, admitted to be mostly a matter of taste and experience). {Note
<a href="#note-refinement-of-rabbit" id="xrefinement-of-rabbit" title="Since the original dissertation was written I have continued to refine and improve RABBIT. This effort has included a complete rewriting of the optimizer ...">Refinement
of <span class="sc">RABBIT</span></a>} <span class="sc">SCHEME</span>
has also been used to implement several AI problem-solving languages,
including <span class="sc">AMORD</span> [<a href="#doyle-1-2" id="xdoyle1" title="[1] Doyle etal 1977, AMORD: A Dependency-Based Problem-Solving Language">Doyle</a>].</li>
</ol>
<p><hr></p>
</section>
</section>
<section id="the-source-language---scheme" class="level2">
<h2><a href="#contents">2.   The Source Language - <span class="sc">SCHEME</span></a></h2>
<p>The basic language processed by <span class="sc">RABBIT</span> is a
subset of the <span class="sc">SCHEME</span> language as described in
[<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch4" title="[4] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>] and [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr1" title="[1] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>], the primary restrictions being that the first argument to
<code>ASET</code> must be quoted and that the multiprocessing primitives
are not accommodated. This subset is summarized here. <span class="sc">SCHEME</span> is essentially a lexically scoped (“full
funarg”) dialect of <span class="sc">LISP</span>. Interpreted programs
are represented by S-expressions in the usual manner. Numbers represent
themselves. Atomic symbols are used as identifiers (with the
conventional exception of <code>T</code> and <code>NIL</code>, which are
conceptually treated as constants). All other constructs are represented
as lists.</p>
<p>In order to distinguish the various other constructs, <span class="sc">SCHEME</span> follows the usual convention that a list whose
car is one of a set of distinguished atomic symbols is treated as
directed by a rule associated with that symbol. All other lists (those
with non-atomic cars, or with undistinguished atoms in their cars) are
<em>combinations</em>, or function calls. All subforms of the list are
uniformly evaluated in an unspecified order, and then the value of the
first (the function) is applied to the values of all the others (the
arguments). Notice that the function position is evaluated in the same
way as the argument positions (unlike most other <span class="sc">LISP</span> systems). (In order to be able to refer to <span class="sc">MacLISP</span> functions, global identifiers evaluate to a
special kind of functional object if they have definitions as <span class="sc">MacLISP</span> functions of the <code>EXPR</code>,
<code>SUBR</code>, or <code>LSUBR</code> varieties. Thus
“<code>(PLUS 1 2)</code>” evaluates to <code>3</code> because the values
of the subforms are &lt;functional object for <code>PLUS</code>&gt;,
<code>1</code>, and <code>2</code>; and applying the first to the other
two causes invocation of the <span class="sc">MacLISP</span> primitive
<code>PLUS</code>.)</p>
<p>The atomic symbols which distinguish special constructs are as
follows:</p>
<dl>
<dt><strong><code>LAMBDA</code></strong></dt>
<dd>
This denotes a function. A form
<code>(LAMBDA (var1 var2 ... varn) body)</code> will evaluate to a
function of n arguments. The <strong>parameters</strong>
<code>vari</code> are identifiers (atomic symbols) which may be used in
the body to refer to the respective <strong>arguments</strong> when the
function is invoked. Note that a <code>LAMBDA</code>-expression is not a
function, but <em>evaluates</em> to one, a crucial distinction.
</dd>
<dt><strong><code>IF</code></strong></dt>
<dd>
This denotes a conditional form. <code>(IF a b c)</code> evaluates the
<strong>predicate</strong> <code>a</code>, producing a value
<code>x</code>; if <code>x</code> is non-<code>NIL</code>, then the
<strong>consequent</strong> <code>b</code> is evaluated, and otherwise
the <strong>alternative</strong> <code>c</code>. If <code>c</code> is
omitted, <code>NIL</code> is assumed.
</dd>
<dt><strong><code>QUOTE</code></strong></dt>
<dd>
As in all <span class="sc">LISP</span> systems, this provides a way to
specify any S-expression as a constant. <code>(QUOTE x)</code> evaluates
to the S-expression <code>x</code>. This may be abbreviated to
<code>&#39;x</code>, thanks to the <span class="sc">MacLISP</span>
read-macro-character feature.
</dd>
<dt><strong><code>LABELS</code></strong></dt>
<dd>
This primitive permits the local definition of one or more mutually
recursive functions. The format is:<br />
<code>  (LABELS ((name1 (LAMBDA ...))</code><br />
<code>           (name2 (LAMBDA ...))</code><br />
<code>           ...</code><br />
<code>           (namen (LAMBDA ...)))</code><br />
<code>          body)</code><br />
This evaluates the <code>body</code> in an environment in which the
names refer to the respective functions, which are themselves closed in
that same environment. Thus references to these names in the bodies of
the <code>LAMBDA</code>-expressions will refer to the labelled
functions. {Note <a href="#note-generalized-labels" id="xgeneralized-labels" title="Since the dissertation was written, and indeed after [Revised Report] came out, the format of LABELS in SCHEME was generalized to permit labelled functions to be defined using any of the same three formats permitted by DEFINE in [Revised Report]. RABBIT has been updated to reflect this change, and the code for it appears in the Appendix.">Generalized
<code>LABELS</code></a>}
</dd>
<dt><strong><code>ASET&#39;</code></strong></dt>
<dd>
This is the primitive side-effect on variables.
<code>(ASET&#39; var body)</code> evaluates the <code>body</code>, assigns
the resulting value to the variable <code>var</code>, and returns that
value. {Note <a href="#note-non-quoted-aset" id="xnon-quoted-aset" title="The SCHEME interpreter permits one to compute the name of the variable, but for technical and philosophical reasons RABBIT forbids this. ...">Non-quoted
<code>ASET</code></a>} For implementation-dependent reasons, it is
forbidden by <span class="sc">RABBIT</span> to use <code>ASET&#39;</code> on
a global variable which is the name of a primitive <span class="sc">MacLISP</span> function, or on a variable bound by
<code>LABELS</code>. (<code>ASET&#39;</code> is actually used very seldom in
practice anyway, and all these restrictions are “good programming
practice”. <span class="sc">RABBIT</span> could be altered to lift these
restrictions, at some expense and labor.)
</dd>
<dt><strong><code>CATCH</code></strong></dt>
<dd>
This provides an escape operator facility. [<a href="#landin" id="xlandin" title="[1] Landin 1965, A Correspondence between ALGOL 60 and Church&#39;s Lambda-Notation">Landin</a>]
[<a href="#reynolds" id="xreynolds" title="[1] Reynolds 1972, Definitional Interpreters for Higher Order Programming Languages">Reynolds</a>]
<code>(CATCH var body)</code> evaluates the <code>body</code>, which may
refer to the variable <code>var</code>, which will denote an “escape
function” of one argument which, when called, will return from the
<code>CATCH</code>-form with the given argument as the value of the
<code>CATCH</code>-form. Note that it is entirely possible to return
from the <code>CATCH</code>-form several times. This raises a difficulty
with optimization which will be discussed later.
</dd>
<dt><strong>Macros</strong></dt>
<dd>
Any atomic symbol which has been defined in one of various ways to be a
macro distinguishes a special construct whose meaning is determined by a
macro function. This function has the responsibility of rewriting the
form and returning a new form to be evaluated in place of the old one.
In this way complex syntactic constructs can be expressed in terms of
simpler ones.
</dd>
</dl>
<p><hr></p>
</section>
<section id="the-target-language" class="level2">
<h2><a href="#contents">3.   The Target Language</a></h2>
<p>The “target language” is a highly restricted subset of <span class="sc">MacLISP</span>, rather than any particular machine language
for an actual hardware machine such as the <span class="sc">PDP-10</span>. <span class="sc">RABBIT</span> produces <span class="sc">MacLISP</span> function definitions which are then compiled
by the standard <span class="sc">MacLISP</span> compiler. In this way we
do not need to deal with the uninteresting vagaries of a particular
piece of hardware, nor with the peculiarities of the many and various
data-manipulation primitives (<code>CAR</code>, <code>RPLACA</code>,
<code>+</code>, etc.). We allow the <span class="sc">MacLISP</span>
compiler to deal with them, and concentrate on the issues of environment
and control which are unique to <span class="sc">SCHEME</span>. While
for production use this is mildly inconvenient (since the code must be
passed through two compilers before use), for research purposes it has
saved the wasteful re-implementation of much knowledge already contained
in the <span class="sc">MacLISP</span> compiler.</p>
<p>On the other hand, the use of <span class="sc">MacLISP</span> as a
target language does not by any means trivialize the task of <span class="sc">RABBIT</span>. The <span class="sc">MacLISP</span>
function-calling mechanism cannot be used as a target construct for the
<span class="sc">SCHEME</span> function call, because <span class="sc">MacLISP</span>’s function calls are not guaranteed to behave
tail-recursively. Since tail-recursion is a most crucial characteristic
distinguishing <span class="sc">SCHEME</span> from most <span class="sc">LISP</span> systems, we must implement <span class="sc">SCHEME</span> function calls by more primitive methods.
Similarly, since <span class="sc">SCHEME</span> is a full-funarg dialect
of <span class="sc">LISP</span> while <span class="sc">MacLISP</span> is
not, we cannot in general use <span class="sc">MacLISP</span>’s
variable-binding mechanisms to implement those of <span class="sc">SCHEME</span>. On the other hand, it is a perfectly
legitimate optimization to use <span class="sc">MacLISP</span>
mechanisms in those limited situations where they are applicable.</p>
<p>Aside from ordinary <span class="sc">MacLISP</span> data-manipulation
primitives, the only <span class="sc">MacLISP</span> constructs used in
the target language are <code>PROG</code>, <code>GO</code>,
<code>RETURN</code>, <code>PROGN</code>, <code>COND</code>,
<code>SETQ</code>, and <code>((LAMBDA...) ...)</code>. <code>PROG</code>
is never nested; there is only a single, outer <code>PROG</code>.
<code>RETURN</code> is used only in the form <code>(RETURN NIL)</code>
to exit this outer <code>PROG</code>; it is never used to return a value
of any kind. <code>LAMBDA</code>-expressions are used only to bind
temporary variables. In addition, <code>CONS</code>, <code>CAR</code>,
<code>CDR</code>, <code>RPLACA</code>, and <code>RPLACD</code> are used
in the creation and manipulation of environments.</p>
<p>We may draw a parallel between each of these constructs and an
equivalent machine-language (or rather, assembly language)
construct:</p>
<div class="line-block"><code>PROG     </code> A single program
module.<br />
<br />
<code>GO       </code> A branch instruction. <code>PROG</code> tags
correspond to instruction labels.<br />
<br />
<code>RETURN   </code> Exit from program module.<br />
<br />
<code>PROGN    </code> Sequencing of several instructions.<br />
<br />
<code>COND     </code> Conditional branches, used in a disciplined
manner. One may think of</div>
<div class="in5">
<pre><code>      (COND (pred1 value1)
            (pred2 value2)
            ...
            (predn valuen))</code></pre>
<p>as representing the sequence of code</p>
<pre><code>              &lt;code for pred1&gt;
              JUMP-IF-NIL reg1, TAG1
              &lt;code for value1&gt;
              JUMP ENDTAG
      TAG1:   &lt;code for pred2&gt;
              JUMP-IF-NIL reg1, TAG2
              &lt;code for value2&gt;
              JUMP ENDTAG
      TAG2:   ...
              &lt;code for predn&gt;
              JUMP-IF-NIL reg1, TAGn
              &lt;code for valuen&gt;
              JUMP ENDTAG
      TAGn:   LOAD-VALUE NIL
      ENDTAG:</code></pre>
<p>which admits of some optimizations, but we shall not worry about
this. (The <span class="sc">MacLISP</span> compiler does, but we do not
depend at all on this fact.)</p>
</div>
<div class="line-block"><code>SETQ     </code> Load register, or store
into memory.<br />
<br />
<code>LAMBDA   </code> We use this primarily in the form:</div>
<div class="in5">
<pre><code>      ((LAMBDA (q1 ... qn)
               (SETQ var1 q1)
               ...
               (SETQ varn qn))
       value1 ... valuen)</code></pre>
<p>which we may think of as saving values on a temporary stack and then
popping them into the variables:</p>
<pre><code>      &lt;code for value1&gt;        ;leaves result in reg1
      PUSH reg1
      ...
      &lt;code for valuen&gt;
      PUSH reg1
      POP  varn
      ...
      POP  var1</code></pre>
<p>This is in fact approximately how the <span class="sc">MacLISP</span>
compiler will treat this construct. This is used to effect the
simultaneous assignment of several values to several registers. It would
be possible to do without the <span class="sc">MacLISP</span>
<code>LAMBDA</code> in this case, by using extra intermediate variables,
but it was decided that this task was less interesting than other issues
within <span class="sc">RABBIT</span>, and that assignments of this kind
would occur sufficiently often that it was desirable to get the <span class="sc">MacLISP</span> compiler to produce the best possible code in
this case.<br />
The form <code>((LAMBDA ...) ...)</code> is also used in some situations
where the user wrote such a form in the <span class="sc">SCHEME</span>
code, and the arguments and <code>LAMBDA</code>-body are all “trivial”,
in a sense to be defined later.</p>
</div>
<div class="ti5">
<p><code>CONS</code>            <code>CONS</code> is used, among other
things, to “push” new values onto the current environment. While <span class="sc">SCHEME</span> variables can sometimes be represented as
temporary <span class="sc">MacLISP</span> variables using
<code>LAMBDA</code>, in general they must be kept in a “consed
environment” in the heap; <code>CAR</code> and <code>CDR</code> are used
to “index” the environment “stack” (which is not really a stack, but in
general tree-like). (N.B. By using <code>CONS</code> for this purpose we
can push the entire issue of environment retention off onto the <span class="sc">LISP</span> garbage collector. It would be possible to use
array-like blocks for environments, and an Algol-like “display” pointer
discipline for variable access. However, a retention strategy as opposed
to a deletion strategy must be used in general, because <span class="sc">SCHEME</span>, unlike Algol 60 and 68, permits procedures to
be the values of other procedures. Stack allocation does not suffice in
general – a heap must be used. Later we will see that <span class="sc">RABBIT</span> uses stack allocation of environments and a
deletion strategy in simple cases, and reverts to heap allocation of
environments and a retention strategy in more complicated
situations.)</p>
</div>
<div class="ti5">
<p><code>CAR, +</code>        Primitive <span class="sc">MacLISP</span>
operators such as <code>+</code> and <code>CAR</code> are analogous to
machine-language instructions such as <code>ADD</code> and
<code>LOAD-INDEXED</code>. We leave to the <span class="sc">MacLISP</span> compiler the task of compiling large
expressions involving these; but we are not avoiding the associated
difficult issues such as register allocation, for we shall have to deal
with them in compiling calls to <span class="sc">SCHEME</span>
functions.</p>
</div>
<p><hr></p>
</section>
<section id="the-target-machine" class="level2">
<h2><a href="#contents">4.   The Target Machine</a></h2>
<p>Compiled code is interfaced to the <span class="sc">SCHEME</span>
interpreter in two ways. The interpreter must be able to recognize
functional objects which happen to be compiled and to invoke them with
given arguments; and compiled code must be able to invoke any function,
whether interpreted or compiled, with given arguments. (This latter
interface is traditionally known as the “UUO Handler” as the result of
the widespread use of the <span class="sc">PDP-10</span> in implementing
<span class="sc">LISP</span> systems. [<a href="#dec" id="xdec" title="[1] DEC 1973, DecSystem 10 Assembly Language Handbook">DEC</a>]
[<a href="#moon-1-2-3-4-5" id="xmoon3" title="[3] Moon 1974, MACLISP Reference Manual, Revision 0">Moon</a>]
[<a href="#teitelman-1-2" id="xteitelman2" title="[2] Teitelman 1975, InterLISP Reference Manual. Revised edition">Teitelman</a>])
We define here an arbitrary standard form for functional objects, and a
standard means for invoking them.</p>
<p>In the <span class="sc">PDP-10</span> <span class="sc">MacLISP</span>
implementation of <span class="sc">SCHEME</span>, a function is, in
general, represented as a list whose car contains one of a set of
distinguished atomic symbols. (Notice that <code>LAMBDA</code> is not
one of these; a <code>LAMBDA</code>-expression may evaluate to a
function, but is not itself a valid function.) This set of symbols
includes <code>EXPR</code>, <code>SUBR</code>, and <code>LSUBR</code>,
denoting primitive <span class="sc">MacLISP</span> functions of those
respective types; <code>BETA</code>, denoting a <span class="sc">SCHEME</span> function whose code is interpretive;
<code>DELTA</code>, denoting an escape function created by the
interpreter for a <code>CATCH</code> form, or a continuation given by
the interpreter to compiled code; <code>CBETA</code>, denoting a <span class="sc">SCHEME</span> function or continuation whose code is
compiled; and <code>EPSILON</code>, denoting a continuation created when
compiled code invokes interpreted code. Each of these function types
requires a different invocation convention; the interpreter must
distinguish these types and invoke them in the appropriate manner. For
example, to invoke an <code>EXPR</code> the <span class="sc">MacLISP</span> <code>FUNCALL</code> construct must be used. A
<code>BETA</code> must be invoked by creating an appropriate
environment, using the given arguments, and then interpreting the code
of the function.</p>
<p>We have arbitrarily defined the <code>CBETA</code> interface as
follows: there are a number of “registers”, in the form of global
variables. Nine registers called <code>**CONT**</code>,
<code>**ONE**</code>, <code>**TWO**</code>, …, <code>**EIGHT**</code>
are used to pass arguments to compiled functions. <code>**CONT**</code>
contains the continuation. The others contain the arguments prescribed
by the user; if there are more than eight arguments, however, then they
are passed as a list of all the arguments in register
<code>**ONE**</code>, and the others are unused. (Any of a large variety
of other conventions could have been chosen, such as the first seven
arguments in seven registers and a list of all remaining arguments in
<code>**EIGHT**</code>. We merely chose a convention which would be
workable and convenient, reflect the typical finiteness of hardware
register sets, and mirror familiar <span class="sc">LISP</span>
conventions. The use of a list of arguments is analogous to the passing
of an arbitrary number of arguments on a stack, sometimes known as the
<code>LSUBR</code> convention. [<a href="#moon-1-2-3-4-5" id="xmoon4" title="[4] Moon 1974, MACLISP Reference Manual, Revision 0">Moon</a>]
[<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd6" title="[6] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>])
There is another register called <code>**FUN**</code>. A function is
invoked by putting the functional object in <code>**FUN**</code>, its
arguments in the registers already described, and the number of
arguments in the register <code>**NARGS**</code>, and then exiting the
current function. Control (at the <span class="sc">MacLISP</span> level)
is then transferred to a routine (the “<span class="sc">SCHEME</span>
UUO handler”) which determines the type of the function in
<code>**FUN**</code> and invokes it.</p>
<p>A continuation is invoked in exactly the same manner as any other
kind of function, with two exceptions: a continuation does not itself
require a continuation, so <code>**CONT**</code> need not be set up; and
a continuation always takes a single argument, so <code>**NARGS**</code>
need not be set to 1. {Note <a href="#note-multiple-argument-continuations" id="xmultiple-argument-continuations" title="One could easily define a SCHEME-like language in which continuations could take more than one argument (that is, functions could return several values); see the discussion in [Declarative]. We have elected not to provide for this in SCHEME and RABBIT.">Multiple-Argument
Continuations</a>} A <code>CBETA</code> form has additional fixed
structure. Besides the atomic symbol <code>CBETA</code> in the car,
there is always in the cadr the address of the code, and in the cddr the
environment. The form of the environment is completely arbitrary as far
as the <span class="sc">SCHEME</span> interpreter is concerned; indeed,
the <span class="sc">CHEAPY</span> compiler and the <span class="sc">RABBIT</span> compiler use completely different formats for
environments for compiled functions. (Recall that this cannot matter
since the only code which will ever be able to access that environment
is the code belonging to the functional closure of which that
environment is a part.) The “UUO handler” puts the cddr of
<code>**FUN**</code> in the register <code>**ENV**</code>, and then
transfers to the address in the cadr of <code>**FUN**</code>. When that
code eventually exits, control returns to the “UUO handler”, which
expects the code to have set up <code>**FUN**</code> and any necessary
arguments. There is a set of “memory locations” <code>-11-</code>,
<code>-12-</code>, … which are used to hold intermediate quantities
within a single user function. (Later we shall see that we think of
these as being used to pass values between internally generated
functions within a module. For this purpose we think of the “registers”
and “memory locations” being arranged in a single sequence
<code>**CONT**</code>, <code>**ONE**</code>, <code>**EIGHT**</code>,
<code>-11-</code>, <code>-12-</code>, … There is in principle an
unbounded number of these “memory locations”, but <span class="sc">RABBIT</span> can determine (and in fact outputs as a
declaration for the <span class="sc">MacLISP</span> compiler) the exact
set of such locations used by any given function.) One may think of the
“memory locations” as being local to each module, since they are never
used to pass information between modules; in practice they are
implemented as global <span class="sc">MacLISP</span> variables.</p>
<p>The registers <code>**FUN**</code>, <code>**NARGS**</code>,
<code>**ENV**</code>, and the argument registers are the only global
registers used by compiled <span class="sc">SCHEME</span> code (other
than the “memory locations”). Except for global variables explicitly
mentioned by the user program, all communication between compiled <span class="sc">SCHEME</span> functions is through these registers. It is
useful to note that the continuation in <code>**CONT**</code> is
generally analogous to the usual “control stack” which contains return
addresses, and so we may think of <code>**CONT**</code> as our “stack
pointer register”.</p>
<p><hr></p>
</section>
<section id="language-design-considerations" class="level2">
<h2><a href="#contents">5.   Language Design Considerations</a></h2>
<p><span class="sc">SCHEME</span> is a lexically scoped (“full-funarg”)
dialect of <span class="sc">LISP</span>, and so is an applicative
language which conforms to the spirit of the lambda-calculus. [<a href="#church-1-2" id="xchurch2" title="[2] Church 1941, The Calculi of Lambda Conversion">Church</a>] We
divide the definition of the <span class="sc">SCHEME</span> language
into two parts: the environment and control constructs, and the data
manipulation primitives. Examples of the former are
<code>LAMBDA</code>-expressions, combinations, and <code>IF</code>;
examples of the latter are <code>CONS</code>, <code>CAR</code>,
<code>EQ</code>, and <code>PLUS</code>. Note that we can conceive of a
version of <span class="sc">SCHEME</span> which did not have
<code>CONS</code>, for example, and more generally did not have
S-expressions in its data domain. Such a version would still have the
same environment and control constructs, and so would hold the same
theoretical interest for our purposes here. (Such a version, however,
would be less convenient for purposes of writing a meta-circular
description of the language, however!)</p>
<p>By the “spirit of lambda-calculus” we mean the essential properties
of the axioms obeyed by lambda-calculus expressions. Among these are the
rules of <em>alpha-conversion</em> and <em>beta-conversion</em>. The
first intuitively implies that we can uniformly rename a function
parameter and all references to it without altering the meaning of the
function. An important corollary to this is that we can in fact
effectively locate all the references. The second implies that in a
situation where a known function is being called with known argument
expressions, we may substitute an argument expression for a parameter
reference within the body of the function (provided no naming conflicts
result, and that certain restrictions involving side effects are met).
Both of these operations are of importance to an optimizing compiler.
Another property which follows indirectly is that of
<em>tail-recursion</em>. This property is exploited in expressing
iteration in terms of applicative constructs, and is discussed in some
detail in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd7" title="[7] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>].</p>
<p>We realize that other systems of environment and control constructs
also are reasonably concise, clear, and elegant, and can be axiomatized
in useful ways, for example the guarded commands of Dijkstra. [<a href="#dijkstra-1-2" id="xdijkstra1" title="[1] Dijkstra 1976, A Discipline of Programming">Dijkstra</a>]
However, that of lambda-calculus is extremely well-understood, lends
itself well to certain kinds of optimizations in a natural manner, and
has behind it a body of literature which can be used directly by <span class="sc">RABBIT</span> to express non-primitive constructs.</p>
<p>The desire for uniform lexical scoping arises from other motives as
well. some pragmatic, some philosophical. Many of these are described in
[<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch5" title="[5] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>], [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp4" title="[4] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>],
[<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd8" title="[8] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>],
and [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr2" title="[2] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>]. It is often difficult to explain some of these to those who
are used to dynamically scoped <span class="sc">LISP</span> systems. Any
one advantage of lexical scoping may often be countered with “Yes, but
you can do that in this other way in a dynamically scoped <span class="sc">LISP</span>.” However, we are convinced that lexical scoping
in its totality provides all of the advantages to be described in a
natural, elegant, and integrated manner, largely as a consequence of its
great <em>simplicity</em>.</p>
<p>There are those to whom lexical scoping is nothing new, for example
the <span class="sc">ALGOL</span> community. For this audience, however,
we should draw attention to another important feature of <span class="sc">SCHEME</span>, which is that functions are first-class data
objects. They may be assigned or bound to variables, returned as values
of other functions, placed in arrays, and in general treated as any
other data object. Just as numbers have certain operations defined on
them, such as addition, so functions have an important operation defined
on them, namely invocation.</p>
<p>The ability to treat functions as objects is not at all the same as
the ability to treat <em>representations</em> of functions as objects.
It is the latter ability that is traditionally associated with <span class="sc">LISP</span>; functions can be represented as S-expressions.
In a version of <span class="sc">SCHEME</span> which had no S-expression
primitives, however, one could still deal with functions (i.e. closures)
as such, for that ability is part of the fundamental environment and
control facilities. Conversely, in a <span class="sc">SCHEME</span>
which does have <code>CONS</code>, <code>CAR</code>, and
<code>CDR</code>, there is no defined way to use <code>CONS</code> by
itself to construct a function (although a primitive
<code>ENCLOSE</code> is now provided which converts an S-expression
representation of a function into a function), and the <code>CAR</code>
or <code>CDR</code> of a function is in general undefined. The only
defined operation on a function is invocation. {Note <a href="#note-operations-on-functions" id="xoperations-on-functions" title="It would certainly be possible to define other operations on functions, such as determining the number of arguments required, or the types of the arguments and returned value, etc. ...">Operations
on Functions</a>}</p>
<p>We draw this sharp distinction between environment and control
constructs on the one hand and data manipulation primitives on the other
because only the former are treated in any depth by <span class="sc">RABBIT</span>, whereas much of the knowledge of a “real”
compiler deals with the latter. A <span class="sc">PL/I</span> compiler
must have much specific knowledge about numbers, arrays, strings, and so
on. We have no new ideas to present here on such issues, and so have
avoided this entire area. <span class="sc">RABBIT</span> itself knows
almost nothing about data manipulation primitives beyond being able to
recognize them and pass them along to the output code, which is a small
subset of MacLISP. In this way <span class="sc">RABBIT</span> can
concentrate on the interesting issues of environment and control, and
exploit the expert knowledge of data manipulation primitives already
built into the <span class="sc">MacLISP</span> compiler.</p>
<p><hr></p>
</section>
<section id="the-use-of-macros" class="level2">
<h2><a href="#contents">6.   The Use of Macros</a></h2>
<p>An important characteristic of the <span class="sc">SCHEME</span>
language is that its set of primitive constructs is quite small. This
set is not always convenient for expressing programs, however, and so a
macro facility is provided for extending the expressive power of the
language. A macro is best thought of as a <em>syntax rewrite rule</em>.
As a simple example, suppose we have a primitive <code>GCD</code> which
takes only two arguments, and we wish to be able to write an invocation
of a <code>GCD</code> function with any number of arguments. We might
then define (in a “production-rule” style) the conditional rule:</p>
<pre><code>    (XGCD)          =&gt; 0
    (XGCD x)        =&gt; x
    (XGCD x . rest) =&gt; (GCD x (XGCD . rest))</code></pre>
<p>(Notice the use of <span class="sc">LISP</span> dots to refer to the
rest of a list.) This is not considered to be a definition of a function
<code>XGCD</code>, but a purely syntactic transformation. In principle
all such transformations could be performed before executing the
program. In fact, <span class="sc">RABBIT</span> does exactly this,
although the <span class="sc">SCHEME</span> interpreter naturally does
it incrementally, as each macro call is encountered.</p>
<p>Rather than use a separate production-rule/pattern-matching language,
in practice <span class="sc">SCHEME</span> macros are defined as
transformation functions from macro-call expressions to resulting
S-expressions, just as they are in <span class="sc">MacLISP</span>.
(Here, however, we shall continue to use production rules for purposes
of exposition.) It is important to note that macros need not be written
in the language for which they express rewrite rules; rather, they
should be considered an adjunct to the interpreter, and written in the
same language as the interpreter (or the compiler). To see this more
clearly, consider a version of <span class="sc">SCHEME</span> which does
not have S-expressions in its data domain. If programs in this language
are represented as S-expressions, then the interpreter for that language
cannot be written in that language, but in another meta-language which
does deal with S-expressions. Macros, which transform one S-expression
(representing a macro call) to another (the replacement form, or the
interpretation of the call), clearly should be expressed in this
meta-language also. The fact that in most <span class="sc">LISP</span>
systems the language and the meta-language appear to coincide is a
source of both power and confusion.</p>
<p>In the <span class="sc">PDP-10</span> <span class="sc">MacLISP</span>
implementation of <span class="sc">SCHEME</span>, four separate macro
mechanisms are used in practice. One is the <span class="sc">MacLISP</span> read-macro mechanism [<a href="#moon-1-2-3-4-5" id="xmoon5" title="[5] Moon 1974, MACLISP Reference Manual, Revision 0">Moon</a>],
which performs transformations such as
<code>&#39;FOO =&gt; (QUOTE FOO)</code> when an expression is read from a
file. The other three are as described earlier, processed by the
interpreter or compiler, and differ only in that one kind is recognized
by the <span class="sc">MacLISP</span> interpreter as well while the
other two are used only by <span class="sc">SCHEME</span>, and that of
the latter two one kind is written in <span class="sc">MacLISP</span>
and the other kind in <span class="sc">SCHEME</span> itself.</p>
<p>There is a growing library of <span class="sc">SCHEME</span> macros
which express a variety of traditional programming constructs in terms
of other, more primitive constructs, and eventually in terms of the
small set of primitives. A number of these are catalogued in [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp5" title="[5] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]
and [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr3" title="[3] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>]. Others were invented in the course of writing <span class="sc">RABBIT</span>. We shall give some examples here. The
<code>BLOCK</code> macro is similar to the <span class="sc">MacLISP</span> <code>PROGN</code>; it evaluates all its
arguments and returns the value of the last one. One critical
characteristic is that the last argument is evaluated “tail-recursively”
(I use horror quotes because normally we speak of invocation, not
evaluation, as being tail-recursive). An expansion rule is given for
this in [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp6" title="[6] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]
equivalent to:</p>
<pre><code>    (BLOCK x)         =&gt;  x
    (BLOCK x . rest)  =&gt;  ((LAMBDA (DUMMY) (BLOCK . rest)) x)</code></pre>
<p>This definition exploits the fact that <span class="sc">SCHEME</span>
is evaluated in applicative order, and so will evaluate all arguments
before applying a function to them. Thus, in the second subrule,
<code>x</code> must be evaluated, and then the block of all the
<code>rest</code> is. It is then clear from the first subrule that the
last argument is evaluated “tail-recursively”.</p>
<p>One problem with this definition is the occurrence of the variable
<code>DUMMY</code>, which must be chosen so as not to conflict with any
variable used by the user. This we refer to as the “<code>GENSYM</code>
problem”, in honor of the traditional <span class="sc">LISP</span>
function which creates a “fresh” symbol. It would be nicer to write the
macro in such a way that no conflict could arise no matter what names
were used by the user. There is indeed a way, which <span class="sc">ALGOL</span> programmers will recognize as equivalent to the
use of “thunks”, or call-by-name parameters:</p>
<pre><code>    (BLOCK x)         =&gt;  x
    (BLOCK x . rest)  =&gt;  ((LAMBDA (A B) (B))
                           x
                           (LAMBDA () (BLOCK . rest)))</code></pre>
<p>Consider carefully the meaning of the right-hand side of the second
subrule. First the expression <code>x</code> and the
<code>(LAMBDA () ...)</code> must be evaluated (it doesn’t matter in
which order!); the result of the latter is a function (that is, a
closure), which is later invoked in order to evaluate the rest of the
arguments. There can be no naming conflicts here, because the scope of
the variables <code>A</code> and <code>B</code> (which is
<em>lexical</em>) does not contain any of the arguments to
<code>BLOCK</code> written by the user. (We should note that we have
been sloppy in speaking of the “arguments” to <code>BLOCK</code>, when
<code>BLOCK</code> is properly speaking not a function at all, but
merely a syntactic keyword used to recognize a situation where a
syntactic rewriting rule is applicable. We would do better to speak of
“argument expressions” or “macro arguments”, but we shall continue to be
sloppy where no confusion should arise.)</p>
<p>This is a technique which should be understood quite thoroughly,
since it is the key to writing correct macro rules without any
possibility of conflicts between names used by the user and those needed
by the macro. As another example, let us consider the <code>AND</code>
and <code>OR</code> constructs as used by most <span class="sc">LISP</span> systems. <code>OR</code> evaluates its arguments
one by one, in order, returning the first non-<code>NIL</code> value
obtained (without evaluating any of the following arguments), or
<code>NIL</code> if all arguments produce <code>NIL</code>.
<code>AND</code> is the dual to this; it returns <code>NIL</code> if any
argument does, and otherwise the value of the last argument. A
simple-minded approach to <code>OR</code> would be:</p>
<pre><code>    (OR)           =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  (IF x x (OR . rest))</code></pre>
<p>There is an objection to this, which is that the code for
<code>x</code> is duplicated. Not only does this consume extra space,
but it can execute erroneously if <code>x</code> has any side-effects.
We must arrange to evaluate x only once, and then test its value:</p>
<pre><code>    (OR)           =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  ((LAMBDA (V) (IF V V (OR . rest))) x)</code></pre>
<p>This certainly evaluates <code>x</code> only once, but admits a
possible naming conflict between the variable <code>V</code> and any
variables used by rest. This is avoided by the same technique used for
<code>BLOCK</code>:</p>
<pre><code>    (OR)          =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  ((LAMBDA (V R) (IF V V (R)))
                      x
                      (LAMBDA () (OR . rest)))</code></pre>
<p>Similarly, we can express <code>AND</code> as follows:</p>
<pre><code>    (AND)           =&gt;  &#39;T
    (AND x)         =&gt;  x
    (AND x . rest)  =&gt;  ((LAMBDA (V R) (IF V (R) &#39;NIL))
                         x
                         (LAMBDA () (AND . rest)))</code></pre>
<p>(The macro rules are not precise duals because of the non-duality
between <code>NIL</code>-ness and non-<code>NIL</code>-ness, and the
requirement that a successful <code>AND</code> return the actual value
of the last argument and not just <code>T</code>.) {Note <a href="#note-tail-recursive-or" id="xtail-recursive-or" title="Since the dissertation was written, the SCHEME language was redefined in [Revised Report] to prescribe a &#39;tail-recursive&#39; interpretation for the last form in an AND or OR ...">Tail-Recursive
<code>OR</code></a>}</p>
<p>As yet another example, consider a modification to <code>BLOCK</code>
to allow a limited form of assignment statement: if
<code>(v := x)</code> appears as a statement in a block, it “assigns” a
value to the variable <code>v</code> whose scope is the remainder of the
block. Let us assume that such a statement cannot occur as the last
statement of a block (it would be useless to have one in that position,
as the variable would have a null scope). We can write the rule:</p>
<pre><code>    (BLOCK x)
    (BLOCK (v := x) . rest)  =&gt;  ((LAMBDA (v) (BLOCK . rest)) x)
    (BLOCK x . rest)         =&gt;  ((LAMBDA (A B) (B))
                                  x
                                  (LAMBDA () (BLOCK . rest)))</code></pre>
<p>The second subrule states that an “assignment” causes <code>x</code>
to be evaluated and then bound to <code>v</code>, and that the variable
<code>v</code> is visible to the rest of the block.</p>
<p>We may think of <code>:=</code> as a “sub-macro keyword” which is
used to mark an expression as suitable for transformation, but only in
the context of a certain larger transformation. This idea is easily
extended to allow other constructions, such as “simultaneous
assignments” of the form</p>
<pre><code>    ((var1 var2 ... varn) := value1 value2 ... valuen)</code></pre>
<p>which first compute all the values and then assign to all the
variables, and “exchange assignments” of the form
<code>(X :=: Y)</code>, as follows:</p>
<pre><code>    (BLOCK x)                          =&gt;  x
    (BLOCK (v := x) . rest)            =&gt;  ((LAMBDA (v). (BLOCK . rest)) x)
    (BLOCK (vars := . values) . rest)  =&gt;  ((LAMBDA vars (BLOCK . rest)) . values)
    (BLOCK (x :=: y) . rest)           =&gt;  ((LAMBDA (x y) (BLOCK . rest)) y x)
    (BLOCK x . rest)                   =&gt;  ((LAMBDA (A B) (B))
                                           x
                                           (LAMBDA () (BLOCK . rest)))</code></pre>
<p>Let us now consider a rule for the more complicated <code>COND</code>
construct:</p>
<pre><code>    (COND)                 =&gt;  &#39;NIL
    (COND (x) . rest)      =&gt;  (OR x (COND . rest))
    (COND (x . r) . rest)  =&gt;  (IF x (BLOCK . r) (COND . rest))</code></pre>
<p>This defines the “extended” <code>COND</code> of modern <span class="sc">LISP</span> systems, which produces <code>NIL</code> if no
clauses succeed, which returns the value of the predicate in the case of
a singleton clause, and which allows more than one consequent in a
clause. An important point here is that one can write these rules in
terms of other macro constructs such as <code>OR</code> and
<code>BLOCK</code>; moreover, any extensions to <code>BLOCK</code>, such
as the limited assignment feature described above, are automatically
inherited by <code>COND</code>. Thus with the above definition one could
write</p>
<pre><code>    (COND ((NUMBERP X) (Y := (SQRT X)) (+ Y (SQRT Y)))
           (T (HACK X)))</code></pre>
<p>where the scope of the variable <code>Y</code> is the remainder of
the first <code>COND</code> clause.</p>
<p><span class="sc">SCHEME</span> also provides macros for such
constructs as <code>DO</code> and <code>PROG</code>, all of which expand
into similar kinds of code using <code>LAMBDA</code>, <code>IF</code>,
and <code>LABELS</code> (see below). In particular, <code>PROG</code>
permits the use of <code>GO</code> and <code>RETURN</code> in the usual
manner. In this manner all the traditional imperative constructs are
expressed in an applicative manner. {Note <a href="#note-aset-is-imperative-1-2" id="xaset-is-imperative1" title="It is true that ASET&#39; is an actual imperative which produces a side effect, and is not expressed applicatively. ASET&#39; is used only for two purposes in practice: to initialize global variables (often relating to MacLISP primitives), and to implement objects with state ..."><code>ASET&#39;</code>
Is Imperative</a>}</p>
<p>None of this is particularly new; theoreticians have modelled
imperative constructs in these terms for years. What is new, we think,
is the serious proposal that a practical interpreter and compiler can be
designed for a language in which such models serve as the <em>sole
definitions</em> of these imperative constructs. {Note <a href="#note-dijkstras-opinion" id="xdijkstras-opinion" title="In [Dijkstra] a remark is made to the effect that defining the while-do construct in terms of function calls seems unusually clumsy. In [Steele] we reply that this is due partly to Dijkstra’s choice of ALGOL for expressing the definition. ...">Dijkstra’s
Opinion</a>} This approach has both advantages and disadvantages.</p>
<p>One advantage is that the base language is small. A simple-minded
interpreter or compiler can be written in a few hours. (We have
re-implemented the <span class="sc">SCHEME</span> interpreter from
scratch a dozen times or more to test various representation strategies;
this was practical only because of the small size of the language.
Similarly, the <span class="sc">CHEAPY</span> compiler is fewer than ten
pages of code, and could be rewritten in a day or less.) Once the basic
interpreter is written, the macro definitions for all the complex
constructs can be used without revision. Moreover, the same macro
definitions can be used by both interpreter and compiler (or by several
versions of interpreter and compiler!). Excepting the very few
primitives such as <code>LAMBDA</code> and <code>IF</code>, it is not
necessary to “implement a construct twice”, once each in interpreter and
compiler.</p>
<p>Another advantage is that new macros are very easy to write (using
facilities provided in <span class="sc">SCHEME</span>). One can easily
invent a new kind of <code>DO</code> loop, for example, and implement it
in <span class="sc">SCHEME</span> for both interpreter and all compilers
in less than five minutes. (In practice such new control constructs,
such as the <code>ITERATE</code> loop described in [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr4" title="[4] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>], are indeed installed within five to ten minutes of
conception, in a routine manner.)</p>
<p>A third advantage is that the attention of the compiler can be
focused on the basic constructs. Rather than having specialized code for
two dozen different constructs, the compiler can have much deeper
knowledge about each of a few basic constructs. One might object that
this “deeper knowledge” consists of recognizing the two dozen special
cases represented by the separate constructs of the former case. This is
true to some extent. It is also true, however, that in the latter case
such deep knowledge will carry over to any new constructs which are
invented and represented as macros.</p>
<p>Among the disadvantages of the macro approach are lack of speed and
the discarding of information. Many people have objected that macros are
of necessity slower than, say, the <code>FSUBR</code> implementation
used by most <span class="sc">LISP</span> systems. This is true in many
current interpretive implementations, but need not be true of compilers
or more cleverly designed interpreters. Moreover, the <code>FSUBR</code>
implementation is not general; it is very hard for a user to write a
meaningful <code>FSUBR</code> and then describe to the compiler the best
way to compile it. The macro approach handles this difficulty
automatically. We do not object to the use of the <code>FSUBR</code>
mechanism as a special-case “speed hack” to improve the performance of
an interpreter, but we insist on recognizing the fact that it is not as
generally useful as the macro approach.</p>
<p>Another objection relating to speed is that the macros produce
convoluted code involving the temporary creation and subsequent
invocation of many closures. We feel, first of all, that the macro
writer should concern himself more with producing correct code than fast
code. Furthermore, convolutedness can be eliminated by a few simple
optimization techniques in the compiler, to be discussed below. Finally,
function calls need not be as expensive as is popularly supposed. [<a href="#steele-1-2-3-4-5" id="xste2" title="[2] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele</a>]</p>
<p>Information is discarded by macros in the situation, for example,
where a <code>DO</code> macro expands into a large mess that is not
obviously a simple loop; later compiler analysis must recover this
information. This is indeed a problem. We feel that the compiler is
probably better off having to recover the information anyway, since a
deep analysis allows it to catch other loops which the user did not use
<code>DO</code> to express for one reason or another. Another is the
possibility that <code>DO</code> could leave clues around in the form of
declarations if desired.</p>
<p>Another difficulty with the discarding of information is the issuing
of meaningful diagnostic messages. The user would prefer to see
diagnostics mention the originally-written source constructs, rather
than the constructs into which the macros expanded. (An example of this
problem from another <span class="sc">LISP</span> compiler is that it
may convert <code>(MEMQ X &#39;(A B C))</code> into
<code>(OR (EQ X &#39;A) (EQ X &#39;B) (EQ X &#39;C))</code>; when by the same rule
it converts <code>(MEMQ X &#39;(A))</code> (a piece of code generated by a
macro) into <code>(OR (EQ X &#39;A))</code>, it later issues a warning that
an <code>OR</code> had only one subform.) This problem can be partially
circumvented if the responsibility for syntax-checking is placed on the
macro definition at each level of expansion.</p>
<p><hr></p>
</section>
<section id="the-imperative-treatment-of-applicative-constructs" class="level2">
<h2><a href="#contents">7. The Imperative Treatment of Applicative
Constructs</a></h2>
<p>Given the characteristics of lexical scoping and tail-recursive
invocations, it is possible to assign a peculiarly imperative
interpretation to the applicative constructs of <span class="sc">SCHEME</span>, which consists primarily of treating a
function call as a <code>GOTO</code>. More generally, a function call is
a <code>GOTO</code> that can pass one or more items to its target; the
special case of passing no arguments is precisely a <code>GOTO</code>.
It is never necessary for a function call to save a return address of
any kind. It is true that return addresses are generated, but we adopt
one of two other points of view, depending on context. One is that the
return address, plus any other data needed to carry on the computation
after the called function has returned (such as previously computed
intermediate values and other return addresses) are considered to be
packaged up into an additional argument (the
<strong>continuation</strong>) which is passed to the target. This lends
itself to a non-functional interpretation of <code>LAMBDA</code>, and a
method of expressing programs called the continuation-passing style
(similar to the message-passing actors paradigm [<a href="#hewitt" id="xhewitt" title="[1] Hewitt 1977, Viewing Control Structures as Patterns of Passing Messages">Hewitt</a>]),
to be discussed further below. The other view, more intuitive in terms
of the traditional stack implementation, is that the return address
should be pushed before evaluating arguments rather than before calling
a function. This view leads to a more uniform function-calling
discipline, and is discussed in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd9" title="[9] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
and [<a href="#steele-1-2-3-4-5" id="xste3" title="[3] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele</a>].</p>
<p>We are led by this point of view to consider a compilation strategy
in which function calling is to be considered very cheap (unlike the
situation with <span class="sc">PL/I</span> and <span class="sc">ALGOL</span>, where programmers avoid procedure calls like
the plague — see [<a href="#steele-1-2-3-4-5" id="xste4" title="[4] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele</a>]
for a discussion of this). In this light the code produced by the sample
macros above does not seem inefficient, or even particularly convoluted.
Consider the expansion of <code>(OR a b c)</code>:</p>
<pre><code>    ((LAMBDA (V R) (IF V V (R)))
     a
     (LAMBDA () ((LAMBDA (V R) (IF V V (R)))
                 b
                 (LAMBDA () ((LAMBDA (V R) (IF V V (R)))
                             c (LAMBDA () &#39;NIL))))))</code></pre>
<p>Then we might imagine the following (slightly contrived) compilation
scenario. First, for expository purposes, we shall rename the variables
in order to be able to distinguish them.</p>
<pre><code>    ((LAMBDA (V1 R1) (IF V1 V1 (R1)))
     a
     (LAMBDA () ((LAMBDA (V2 R2) (IF V2 V2 (R2)))
                 b
                 (LAMBDA () ((LAMBDA (V3 R3) (IF V3 V3 (R3)))
                             c
                             (LAMBDA () &#39;NIL))))))</code></pre>
<p>We shall assign a generated name to each
<code>LAMBDA</code>-expression, which we shall notate by writing the
name after the word <code>LAMBDA</code>. These names will be used as
tags in the output code.</p>
<pre><code>    ((LAMBDA name1 (V1 R1) (IF V1 V1 (R1)))
     a
     (LAMBDA name2 () ((LAMBDA name3 (V2 R2) (IF V2 V2 (R2)))
                       b
                       (LAMBDA name4 () ((LAMBDA name5 (V3 R3) (IF V3 V3 (R3)))
                                         c
                                         (LAMBDA name6 () &#39;NIL))))))</code></pre>
<p>Next, a simple analysis shows that the variables <code>R1</code>,
<code>R2</code>, and <code>R3</code> always denote the
<code>LAMBDA</code>-expressions named <code>name2</code>,
<code>name4</code>, and <code>name6</code>, respectively. Now an
optimizer might simply have substituted these values into the bodies of
<code>name1</code>, <code>name3</code>, and <code>name5</code> using the
rule of beta-conversion, but we shall not apply that technique here.
Instead we shall compile the six functions in a straightforward manner.
We make use of the additional fact that all six functions are closed in
identical environments (we count two environments as identical if they
involve the same variable bindings, regardless of the number of “frames”
involved; that is, the environment is the same inside and outside a
<code>(LAMBDA () ...))</code>. Assume a simple target machine with
argument registers called <code>reg1</code>, <code>reg2</code>, etc.</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
            LOAD reg2,[name2]       ;[name2] is the closure for name2
            CALL-FUNCTION 2,[namel] ;call name1 with 2 arguments

    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1
    name1a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name2:  &lt;code for b&gt;            ;result in reg1
            LOAD reg2,[name4]       ;[name4] is the closure for name4
            CALL-FUNCTION 2,[name3] ;call name3 with 2 arguments

    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1
    name3a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name4:  &lt;code for c&gt;            ;result in reg1
            LOAD reg2,[name6]       ;[name6] is the closure for name6
            CALL-FUNCTION 2,[name5] ;call name5 with 2 arguments

    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1
    name5a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>Now we make use of our knowledge that certain variables always denote
certain functions, and convert <code>CALL-FUNCTION</code> of a known
function to a simple <code>GOTO</code>. (We have actually done things
backwards here; in practice this knowledge is used <em>before</em>
generating any code. We have fudged over this issue here, but will
return to it later. Our purpose here is merely to demonstrate the
treatment of function calls as <code>GOTO</code>s.)</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
            LOAD reg2,[name2]       ;[name2] is the closure for name2
            GOTO name1

    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1
    name1a: GOTO name2

    name2:  &lt;code for b&gt;            ;result in reg1
            LOAD reg2,[name4]       ;[name4] is the closure for name4
            GOTO name3

    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1
    name3a: GOTO name4

    name4:  &lt;code for c&gt;            ;result in reg1
            LOAD reg2,[name6]       ;[name6] is the closure for name6
            GOTO name5

    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1
    name5a: GOTO name6

    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>The construction <code>[foo]</code> indicates the creation of a
closure for <code>foo</code> in the current environment. This will
actually require additional instructions, but we shall ignore the
mechanics of this for now since analysis will remove the need for the
construction in this case. The fact that the <em>only</em> references to
the variables <code>R1</code>, <code>R2</code>, and <code>R3</code> are
function calls can be detected and the unnecessary <code>LOAD</code>
instructions eliminated. (Once again, this would actually be determined
ahead of time, and no <code>LOAD</code> instructions would be generated
in the first place. All of this is determined by a general pre-analysis,
rather than a peephole post-pass.) Moreover, a <code>GOTO</code> to a
tag which immediately follows the <code>GOTO</code> can be
eliminated.</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1

    name1a:
    name2:  &lt;code for b&gt;            ;result in reg1
    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1

    name3a:
    name4:  &lt;code for c&gt;            ;result in reg1
    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1

    name5a:
    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>This code is in fact about what one would expect out of an ordinary
<span class="sc">LISP</span> compiler. (There is admittedly room for a
little more improvement.) <span class="sc">RABBIT</span> indeed produces
code of essentially this form, by the method of analysis outlined
here.</p>
<p>Similar considerations hold for the <code>BLOCK</code> macro.
Consider the expression <code>(BLOCK a b c)</code>; conceptually this
should perform <code>a</code>, <code>b</code>, and <code>c</code>
sequentially. Let us examine the code produced:</p>
<pre><code>    ((LAMBDA (A B) (B))
     a
     (LAMBDA () ((LAMBDA (A B) (B))
                  b
                  (LAMBDA () C))))</code></pre>
<p>Renaming the variables and assigning names to
<code>LAMBDA</code>-expressions:</p>
<pre><code>    ((LAMBDA name1 (A1 B1) (B1))
     a
     (LAMBDA name2 () ((LAMBDA name3 (A2 B2) (B2))
                       b
                       (LAMBDA name4 () c))))</code></pre>
<p>Producing code for the functions:</p>
<pre><code>    main:   &lt;code for a&gt;
            LOAD reg2,[name2]
            CALL-FUNCTION 2,[name1]

    name1:  CALL-FUNCTION 0,reg2

    name2:  &lt;code for b&gt;
            LOAD reg2,[name4]
            CALL-FUNCTION 2,[name3]

    name3:  CALL-FUNCTION 0,reg2
    name4:  &lt;code for c&gt;
            RETURN</code></pre>
<p>Turning general function calls into direct <code>GO</code>’s, on the
basis of analysis of what variables must refer to constant
functions:</p>
<pre><code>    main:   &lt;code for a&gt;
            LOAD reg2,[name2]
            GOTO name1

    name1:  GOTO name2

    name2:  &lt;code for b&gt;
            LOAD reg2,[name4]
            GOTO name3

    name3:  GOTO name4

    name4:  &lt;code for c&gt;
            RETURN</code></pre>
<p>Eliminating useless <code>GOTO</code> and <code>LOAD</code>
instructions:</p>
<pre><code>    main:   &lt;code for a&gt;
    name1:
    name2:  &lt;code for b&gt;
    name3:
    name4:  &lt;code for c&gt;
            RETURN</code></pre>
<p>What more could one ask for?</p>
<p>Notice that this has fallen out of a general strategy involving only
an approach to compiling <em>function calls</em>, and has involved no
special knowledge of <code>OR</code> or <code>BLOCK</code> not encoded
in the macro rules. The cases shown so far are actually special cases of
a more general approach, special in that all the conceptual closures
involved are closed in the same environment, and called from places that
have not disturbed that environment, but only used “registers.” In the
more general case, the environments of caller and called function will
be different. This divides into two subcases, corresponding to whether
the closure was created by a simple <code>LAMBDA</code> or by a
<code>LABELS</code> construction. The latter involves circular
references, and so is somewhat more complicated; but it is easy to show
that in the former case the environment of the caller must be that of
the (known) called function, possibly with additional values added on.
This is a consequence of lexical scoping. As a result, the function call
can be compiled as a <code>GOTO</code> preceded by an environment
adjustment which consists merely of lopping off some leading portion of
the current one (intuitively, one simply “pops the unnecessary crud off
the stack”). <code>LABELS</code>-closed functions also can be treated in
this way, if one closes all the functions in the same way (which <span class="sc">RABBIT</span> presently does, but this is not always
desirable). If one does, then it is easy to see the effect of expanding
a <code>PROG</code> into a giant <code>LABELS</code> as outlined in [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp7" title="[7] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]
and elsewhere: normally, a <code>GOTO</code> to a tag at the same level
of PROG will involve no adjustment of environment, and so compile into a
simple <code>GOTO</code> instruction, whereas a <code>GOTO</code> to a
tag at an outer level of PROG probably will involve adjusting the
environment from that of the inner <code>PROG</code> to that of the
outer. All of this falls out of the proper imperative treatment of
function calls.</p>
<p><hr></p>
</section>
<section id="compilation-strategy" class="level2">
<h2><a href="#contents">8.   Compilation Strategy</a></h2>
<p>The overall approach <span class="sc">RABBIT</span> takes to the
compilation of <span class="sc">SCHEME</span> code may be summarized as
follows:</p>
<ol type="1">
<li>Alpha-conversion (renaming of variables) and macro-expansion
(expansion of syntactic rewrite rules).</li>
<li>Preliminary analysis (variable references, “trivial” expressions,
and side effects).</li>
<li>Optimization (meta-evaluation).</li>
<li>Conversion to continuation-passing style.</li>
<li>Environment and closure analysis.</li>
<li>Code generation.</li>
</ol>
<p>During (1) a data structure is built which is structurally a copy of
the user program but in which all variables have been renamed and in
which at each “node” of the program tree are additional slots for extra
information. These slots are filled in during (2). In (3) the topology
of the structure may be modified to reflect transformations made to the
program; routines from (2) may be called to update the information
slots. In (4) a new data structure is contructed from the old one,
radically different in structure, but nevertheless also tree-like in
form. During (5) information is added to slots in the second structure.
In (6) this information is used to produce the final code.</p>
<section id="a.-alpha-conversion-and-macro-expansion" class="level3">
<h3><a href="#contents">A.   Alpha-conversion and
macro-expansion</a></h3>
<p>In this phase a copy of the user program is made. The user program is
conceptually a tree structure; each node is one of several kinds of
construct (constant, variable, <code>LAMBDA</code>-expression,
<code>IF</code>-expression, combination, etc.). Some kinds of nodes have
subnodes; for example, a <code>LAMBDA</code>-expression node has a
subnode representing the body, and a combination node has a subnode for
each argument. The copying is performed in the obvious way by a
recursive tree-walk. In the process all bound variables are renamed.
Each bound variable is assigned a new generated name at the point of
binding, and each node for a reference to a bound variable contains this
generated name, not the original name. From this point on all variables
are dealt with in terms of their new names. (This is possible because,
as a consequence of lexical scoping, we can identify <em>all</em>
references to each bound variable.) These new names are represented as
atomic symbols, and the property lists of these symbols will later be
used to store information about the variables.</p>
<p>As each subform of the user program is examined, a check is made for
a macro call, which is a list whose car is an atomic symbol with one of
several macro-defining properties. When such a call is encountered, the
macro call is expanded, and the tree-walk is resumed on the code
returned by the expansion process.</p>
</section>
<section id="b.-preliminary-analysis" class="level3">
<h3><a href="#contents">B.   Preliminary analysis</a></h3>
<p>The preliminary analysis (“phase 1”) is in three passes, each
involving a tree-walk of the node structure, filling in information
slots at each node. (Two passes would have sufficed, but for reasons of
clarity and modularity there is one pass for each type of analysis.)</p>
<p>The first pass (<code>ENV-ANALYZE</code>) analyzes variable
references. For each node we determine the set of all <em>local</em>
(bound) variables referenced at or below that node. For example, for a
variable-reference node this set is empty (for a global variable), or
the singleton set of the variable itself (for a local variable); for a
<code>LAMBDA</code>-expression, it is the set for its body minus the
variables bound by that <code>LAMBDA</code>-expression; for an
<code>IF</code>-expression, it is the union of the sets for the
predicate, consequent, and alternative; and so on. We also compute for
each node the set of bound variables which appear in an
<code>ASET&#39;</code> at or below the node. (This set will be a subset of
the first set, but no non-trivial use of this property is used in this
pass.) Finally, for each variable we store several properties on its
property list, including a list of all nodes which reference the
variable (for “reading”) and a list of of all <code>ASET&#39;</code> nodes
which modify the variable. These lists are built incrementally, with an
entry added as each reference is encountered during the tree walk. (This
exemplifies the general strategy for passing data around; any
information which cannot be passed conveniently up and down the tree,
but which must jump laterally between branches, is accumulated on the
property lists of the variables. It may appear to be “lucky” that all
such information has to do with variables, but this is actually an
extremely deep property of our notation. The entire point of using
identifiers is to relate textually separated constructions. We depend on
alpha-conversion to give all variables distinct names (by “names” we
really mean “compile-time data structures”) so that the information for
variables which the user happened to give the same name will not be
confused.</p>
<p>The second pass (<code>TRIV-ANALYZE</code>) locates “trivial”
portions of the program. (Cf. [<a href="#wand-and-friedman-1-2-3" id="xwand1" title="[1] Wand and Friedman 1976, Compiling Lambda Expressions Using Continuations">Wand
and Friedman</a>].) Constants and variables are trivial; an
<code>IF</code>-expression is trivial iff the predicate, consequent, and
alternative are all trivial; an <code>ASET&#39;</code> is trivial iff its
body is trivial; a combination is trivial iff the function is either a
global variable which is the name of a <span class="sc">MacLISP</span>
primitive, or a <code>LAMBDA</code>-expression whose body is trivial,
and the arguments are all trivial. <code>LAMBDA</code>-expressions,
<code>LABELS</code>-forms (which contain
<code>LAMBDA</code>-expressions), and <code>CATCH</code>-forms are never
trivial. The idea is that a trivial expression is one that <span class="sc">MacLISP</span> could evaluate itself, without benefit of
<span class="sc">SCHEME</span> control structures. (No denigration of
<span class="sc">MacLISP</span>’s ability is intended by this
terminology!) Note particularly the two special casess of combinations
distinguished here (in which the function position contains either the
name of a <span class="sc">MacLISP</span> primitive or a
<code>LAMBDA</code>-expression); they are very important, and shall be
referred to respectively as <code>TRIVFN</code>-combinations and
<code>LAMBDA</code>-combinations.</p>
<p>The third pass (<code>EFFS-ANALYZE</code>) analyzes the possible
side-effects caused by each node, and the side-effects which could
affect it. It actually produces two sets of analyses, one liberal and
one conservative. Where there is any uncertainty as to what side-effects
may be involved, it assumes none in one case and all possible in the
other. The liberal estimation is used only to issue error messages to
the user about possible conflicts which might result as a consequence of
the freedom to evaluate arguments to combinations in any order. The user
is given the benefit of doubt, and warned only of a “provable” conflict.
(Actually, the “proof” is a little sloppy, and can err in both
directions, but in practice it has issued no false alarms and a number
of helpful warnings.) The conservative estimation is used by the
optimizer, which will move expressions only if it can prove that there
will be no conflict.</p>
<p>Side effects are grouped into classes: <code>ASET</code>,
<code>RPLACA</code> and <code>RPLACD</code> (which are considered
distinct), <code>FILE</code> (input/output operations), and
<code>CONS</code>. These are not intended to be exhaustive; there is
also an internal notation for “any side-effect whatever” The use of
classes enables the analysis to realize, for example, that
<code>RPLACA</code> cannot affect the value of a variable per se. There
is a moderately large body of data in <span class="sc">RABBIT</span>
about the side-effects of <span class="sc">MacLISP</span> primitive
functions. For example, <code>CAR</code>, <code>CDR</code>,
<code>CAAR</code>, <code>CADR</code>, and so on are known not to have
side-effects, and to be respectively affected only by
<code>RPLACA</code>, <code>RPLACD</code>, <code>RPLACA</code>,
<code>RPLACA</code> or <code>RPLACD</code>, and so on. Similarly, <span class="sc">RABBIT</span> knows that <code>ASET&#39;</code> affects the
values of variables, but cannot affect the outcome of a <code>CAR</code>
operation. (It may affect the value of the expression
<code>(CAR X)</code>, but only because a variable reference is a subnode
of the combination. The effects, or affectability, of a combination are
the union of the effects, or affectibility, of all arguments plus those
of the function.) The <code>CONS</code> side-effect is a special case.
This side-effect cannot affect anything, and two instances of it may be
performed in the “wrong” order, but performing a single instance twice
will produce distinct (as determined by <code>EQ</code>) and therefore
incorrect results. In particular, closures of
<code>LAMBDA</code>-expressions involve the <code>CONS</code>
side-effect. (The definition of <span class="sc">SCHEME</span> says
nothing about whether <code>EQ</code> is a valid operation on closures,
but in general it is not a good idea to produce unnecessary multiple
copies. On the other hand, <code>LAMBDA</code>-expressions occurring in
function position of a <code>LAMBDA</code>-combination do not incur the
<code>CONS</code> side-effect. The <code>CONS</code> side-effect is
given special treatment in the optimizer. {Note <a href="#note-side-effect-classifications" id="xside-effect-classifications" title="The division of side-effects into classes in RABBIT was not really necessary to the primary goals of RABBIT, but was undertaken as an interesting experiment for our own edification ...">Side-Effect
Classifications</a>}</p>
</section>
<section id="c.-optimization" class="level3">
<h3><a href="#contents">C.   Optimization</a></h3>
<p>Once the preliminary analysis is done, the optimization phase
performs certain transformations on the code. The result is an
equivalent program which will (probably) compile into more efficient
code. This new program is itself structurally a valid <span class="sc">SCHEME</span> program; that is, all transformations are
contained within the language. The transformations are thus similar to
those performed on macro calls, consisting of a syntactic rewriting of
an expression, except that the situations where such transformations are
applicable are more easily recognized in the case of macro calls. It
should be clear that the optimizer and the macro-functions are
conceptually at the same level in that they may be written in the same
meta-language that operates on representations of <span class="sc">SCHEME</span> programs. {Note <a href="#note-non-deterministic-optimization" id="xnon-deterministic-optimization" title="To simplify the implementation, RABBIT uses only a deterministic (and very conservative) optimizer. Ideally, an optimizer would be non-deterministic in structure ...">Non-deterministic
Optimization</a>}</p>
<p>The simplest transformation is that a combination whose function
position contains a <code>LAMBDA</code>-expression and which has no
arguments can be replaced by the body of the
<code>LAMBDA</code>-expression:</p>
<pre><code>    ((LAMBDA () body))  =&gt;  body</code></pre>
<p>Another is that, in the case of a <code>LAMBDA</code>-combination, if
some parameter of the <code>LAMBDA</code>-expression is not referenced
and the corresponding argument can be proved to have no side-effects
(with an exception discussed below), then the parameter and argument can
be eliminated:</p>
<pre><code>    ((LAMBDA (x1 x2 x3) body) al a2 a3)
                    =&gt;  ((LAMBDA (x1 x3) body) a1 a3)
    if x2 is unreferenced in body and a2 has no side-effects</code></pre>
<p>Repeated applications of this rule can lead to the preceding
case.</p>
<p>A third rule is that, in a <code>LAMBDA</code>-combination, an
argument can be substituted for one or more occurrences of a parameter
in the body of the <code>LAMBDA</code>- expression. (This rule is
related to the view of <code>LAMBDA</code> as a renaming operator
discussed in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd10" title="[10] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>],
and together with the two preceding rules make up the rule of
beta-conversion.) Such a substitution is permissible only if (a) either
the parameter is referred to only once or the argument has no side
effects, and (b) the substitution will not alter the order in which
expressions are evaluated in such a way as to allow possible
side-effects to produce different results. Before performing the
substitution it is necessary to show that side-effects will not
interfere in this manner. This issue is discussed in [<a href="#allen-and-cocke-1-2-3-4-5" id="xaac1" title="[1] Allen and Cocke 1972, A Catalogue of Optimizing Transformations">Allen
and Cocke</a>], [<a href="#geschke-1-2" id="xgeschke1" title="[1] Geschke 1972, Global program optimizations">Geschke</a>], and
[<a href="#wulf-1-2-3-4" id="xwulf1" title="[1] Wulf 1975, The Design of an Optimizing Compiler">Wulf</a>],
and characterized more accurately in [<a href="#standish-1-2-3" id="xstandish2" title="[2] Standish etal 1976, The Irvine Program Transformation Catalogue">Standish</a>].
There is also some difficulty if the parameter appears in an
<code>ASET&#39;</code>. Presently <span class="sc">RABBIT</span> does not
attempt any form of substitution for such a parameter.
(<code>ASET&#39;</code> is so seldom used in <span class="sc">SCHEME</span>
programs that this restriction makes very little difference.)</p>
<p>This third rule creates an exception to the second. If an argument
with a side effect is referred to once, and is substituted for the
reference, then the second rule must be invoked to eliminate the
original occurrence of the argument, so that the side effect will not
occur twice. This requires a little collusion between the two rules.</p>
<p>Even if such a substitution is permissible, it is not always
desirable; time/space tradeoffs are involved. The current heuristic is
that a substitution is desirable if (1) the parameter is referred to
only once; or (2) the argument to be substituted in is a constant or
variable; or (3) the argument is a <code>LAMBDA</code>-expression whose
body is (3a) a constant, or (3b) a variable reference, or (3c) a
combination which has no more arguments than the
<code>LAMBDA</code>-expression requires and for which the arguments are
all constants or variables. This heuristic was designed to be as
conservative as possible while handling most cases which arise from
typical macro-expansions.</p>
<p>The case where the expression substituted for a variable is a
<code>LAMBDA</code>-expression constitutes an instance of procedure
integration [<a href="#allen-and-cocke-1-2-3-4-5" id="xaac2" title="[2] Allen and Cocke 1972, A Catalogue of Optimizing Transformations">Allen
and Cocke</a>]. The more general kind of procedure integration proposed
in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd11" title="[11] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>],
which would involve block compilation of several user functions, and
possibly also user declarations or data type analysis, has not been
implemented yet.</p>
<p>It would be possible to substitute a <code>LAMBDA</code>-expression
for a variable reference in the case of a variable bound by a
<code>LABELS</code>. This might be useful in the case of a
<code>LABELS</code> produced by a simple-minded <code>PROG</code> macro,
which produced a labelled function for each statement of the
<code>PROG</code>; in such a case most labelled functions would be
referred to only once. We have not implemented this yet in <span class="sc">RABBIT</span>. {Note <a href="#note-loop-unrolling" id="xloop-unrolling" title="In the case of a LABELS used to implement a loop, the substitution of a labelled function for the variable which names it would constitute an instance of loop unrolling [Allen and Cocke], particularly if the substitution permitted subsequent optimizations such as eliminating dead code. Here, as elsewhere, a specific optimization technique falls out as a consequence of the more general technique of beta-conversion.">Loop
Unrolling</a>}</p>
<p>Currently there is not any attempt to perform the inverse of
beta-conversion. This process would be that of locating common
subexpressions of some single large expression, making that large
expression the body of a <code>LAMBDA</code>-expression of one
parameter, replacing all occurrences of the common subexpression by a
reference to the parameter, and replacing the large expression by a
combination whose function position contained the
<code>LAMBDA</code>-expression and whose argument was a copy of the
common subexpression. More generally, several common subexpressions
could be isolated at once and made into several parameters of the
<code>LAMBDA</code>-expression. For example, consider:</p>
<pre><code>    (LAMBDA (A B C)
            (LIST (/ (+ (- B) (SQRT (- (^ B 2) (* 4 AC))))
                    (* 2 A))
                  (1 (- (- B) (SQRT (- (^ B 2) (* 4 A C))))
                    (* 2 A))))</code></pre>
<p>Within the large expression <code>(LIST...)</code> we might detect
the common subexpressions <code>(- B), (SQRT ...)</code>, and
<code>(* 2 A)</code>. Thus we would invent three parameters
<code>Q1</code>, <code>Q2</code>, <code>Q3</code> and transform the
expression into:</p>
<pre><code>    (LAMBDA (A B C)
            ((LAMBDA (Q1 Q2 Q3)
                     (LIST (/ (+ Q1 Q2) Q3)
                           (/ (- Q1 Q2) Q3)))
             (- B)
             (SQRT (- (^ B 2) (* 4 A C)))
             (* 2 A)))</code></pre>
<p>(There would be no problem of conflicting names as there is for macro
rules, because we are operating on code for which all variables have
already been renamed; <code>Q1</code>, <code>Q2</code>, and
<code>Q3</code> can be chosen as the next variables in the renaming
sequence.)</p>
<p>This approach doesn’t always work if side-effects are present; the
abstracted (!) common subexpression may be evaluated too soon, or the
wrong number of times. This can be solved by wrapping
<code>(LAMBDA () •)</code> around the common subexpression, and
replacing references by a combination instead of a simple variable
reference. For example:</p>
<pre><code>    (IF (HAIRYP X)
        (BLOCK (PRINT &#39;|Here is some hair:|)
               (PRINT X)
               (PRINT &#39;|End of hair.|))
        (BLOCK (PRINT &#39;|This one is bald:|)
               (PRINT X)
               PRINT &#39;|End of baldness.|)))</code></pre>
<p>We could not transform it into this:</p>
<pre><code>    ((LAMBDA (Q1)
             (IF (HAIRYP X)
                 (BLOCK (PRINT &#39;|Here is some hair:|)
                        Q1
                        (PRINT &#39;|End of hair.|))
                 (BLOCK (PRINT &#39;|This one is bald:|)
                        Q1
                        (PRINT &#39;|End of baldness.|))))
     (PRINT X))</code></pre>
<p>because <code>X</code> would be printed before the appropriate
leading message. Instead, we transform it into:</p>
<pre><code>    ((LAMBDA (Q1)
             (IF (HAIRYP X)
                 (BLOCK (PRINT &#39;|Here is some hair:|)
                        (Q1)
                        (PRINT &#39;|End of hair.|))
                 (BLOCK (PRINT &#39;|This one is bald:|)
                        (Q1)
                        (PRINT &#39;|End of baldness.|))))
     (LAMBDA () (PRINT X)))</code></pre>
<p>This is similar to the call-by-name trick used in writing macro
rules.</p>
<p>A more general transformation would detect <em>nearly</em> common
subexpressions as follows:</p>
<pre><code>    ((LAMBDA (Q1)
             (IF (HAIRYP X)
                 (Q1 &#39;|Here is some hair:|
                     &#39;|End of hair.|)
                 (Q1 &#39;|This one is bald:|
                     &#39;|End of baldness.|)))
     (LAMBDA (Q2 Q3)
             (BLOCK (PRINT Q2) (PRINT X) (PRINT Q3))))</code></pre>
<p>In this way we can express the notion of subroutinization. {Note <a href="#note-subroutinization" id="xsubroutinization" title="We have not said anything about how to locate candidate expressions for subroutinization. For examples of appropriate strategies, see ...">Subroutinization</a>}</p>
<p>We point out these possibilities despite the fact that they have not
been implemented in <span class="sc">RABBIT</span> because the problem
of isolating common subexpressions seems not to have been expressed in
quite this way in the literature on compilation strategies. We might
speculate that this is because most compilers which use complex
optimization strategies have been for <span class="sc">ALGOL</span>-like
languages which do not treat functions as full-fledged data objects, or
even permit the writing of “anonymous” functions in functions calls as
<span class="sc">LISP</span> does.</p>
<p><span class="sc">RABBIT</span> does perform folding on constant
expressions [<a href="#allen-and-cocke-1-2-3-4-5" id="xaac3" title="[3] Allen and Cocke 1972, A Catalogue of Optimizing Transformations">Allen
and Cocke</a>]; that is, any combination whose function is a
side-effect-less <span class="sc">MacLISP</span> primitive and whose
arguments are all constants is replaced by the result of applying the
primitive to the arguments. There is presently no attempt to do the same
thing for side-effect-less <span class="sc">SCHEME</span> functions,
although this is conceptually no problem.</p>
<p>Finally, there are two transformations on <code>IF</code>
expressions. One is simply that an <code>IF</code> expression with a
constant predicate is simplified to its consequent or alternative
(resulting in elimination of dead code). The other was adapted from [<a href="#standish-1-2-3" id="xstandish3" title="[3] Standish etal 1976, The Irvine Program Transformation Catalogue">Standish</a>],
which does not have this precise transformation listed, but gives a more
general rule. In its original form this transformation is:</p>
<pre><code>    (IF (IF a b c) d e)  =&gt;  (IF a (IF b d e) (IF c d e))</code></pre>
<p>One problem with this is that the code for d and e is duplicated.
This can be avoided by the use of <code>LAMBDA</code>-expressions:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF a
                 (IF b (Q1) (Q2))
                 (IF c (Q1) (Q2))))
     (LAMBDA () d)
     (LAMBDA () e))</code></pre>
<p>As before, there is no problem of name conflicts with Q1 and Q2.
While this code may appear unnecessarily complex, the calls to the
functions <code>Q1</code> and <code>Q2</code> will, typically, as shown
above, be compiled as simple <code>GOTO</code>s. As an example, consider
the expression:</p>
<pre><code>    (IF (AND PRED1 PRED2) (PRINT &#39;WIN) (ERROR &#39;LOSE))</code></pre>
<p>Expansion of the <code>AND</code> macro will result in:</p>
<pre><code>    (IF ((LAMBDA (V R) (IF V (R) &#39;NIL))
         PRED1
         (LAMBDA () PRED2))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>(For expository clarity we will not bother to rename all the
variables, inasmuch as they are already distinct.) Because
<code>V</code> and <code>R</code> have only one reference apiece (and
there are no possible interfering side-effects), the corresponding
arguments can be substituted for them.</p>
<pre><code>    (IF ((LAMBDA (V R) (IF PRED1 ((LAMBDA () PRED2)) &#39;NIL))
         PRED1
         (LAMBDA () PRED2))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE) )</code></pre>
<p>Now, since <code>V</code> and <code>R</code> have no referents at
all, they and the corresponding arguments can be eliminated, since the
arguments have no side-effects.</p>
<pre><code>    (IF ((LAMBDA () (IF PRED1 ((LAMBDA () PRED2)) &#39;NIL)))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>Next, the combination <code>((LAMBDA () ...))</code> is eliminated in
two places:</p>
<pre><code>    (IF (IF PRED1 PRED2 &#39;NIL)
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>Now, the transformation on the nested <code>IF</code>’s:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF PRED1
                 (IF PRED2 (Q1) (Q2))
                 (IF &#39;NIL (Q1) (Q2))))
     (LAMBDA () (PRINT &#39;WIN))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>Now one <code>IF</code> has a constant predicate and can be
simplified:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF PRED1
                 (IF PRED2 (Q1) (Q2))
                 (Q2)))
     (LAMBDA () (PRINT &#39;WIN))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>The variable <code>Q1</code> has only one referent, and so we
substitute in, eliminate the variable and argument, and collapse a
<code>((LAMBDA () ...))</code>:</p>
<pre><code>    ((LAMBDA (Q2)
             (IF PRED1
                 (IF PRED2 (PRINT &#39;WIN) (Q2))
                 (Q2)))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>Recalling that <code>(Q2)</code> is, in effect, a <code>GOTO</code>
branching to the common piece of code, and that by virtue of later
analysis no actual closure will be created for either
<code>LAMBDA</code>-expression, this result is quite reasonable. {Note
<a href="#note-evaluation-for-control-1-2" id="xevaluation1" title="It is usual in a compiler to distinguish at least three &#39;evaluation contexts&#39;: value, control, and effect. (See [Wulf], for example.) Evaluation for control occurs in the predicate of an IF, where the point is not so much to produce a data object as simply to decide whether it is true or false. ...">Evaluation
for Control</a>}</p>
<p><hr></p>
</section>
<section id="d.-conversion-to-continuation-passing-style" class="level3">
<h3><a href="#contents">D.   Conversion to Continuation-Passing
Style</a></h3>
<p>This phase is the real meat of the compilation process. It is of
interest primarily in that it transforms a program written in <span class="sc">SCHEME</span> into an equivalent program (the
<em>continuation-passing-style version</em>, or <em>CPS version</em>),
written in a language <em>isomorphic to a subset of <span class="sc">SCHEME</span></em> with the property that interpreting it
requires <em>no control stack or other unbounded temporary storage</em>
and <em>no decisions as to the order of evaluation of (non-trivial)
subexpressions</em>. The importance of these properties cannot be
overemphasized. The fact that it is essentially a subset of <span class="sc">SCHEME</span> implies that its semantics are as clean,
elegant, and well-understood as those of the original language. It is
easy to build an interpreter for this subset, given the existence of a
<span class="sc">SCHEME</span> interpreter, which can execute the
transformed program directly at this level. This cannot be said for
other traditional intermediate compilation forms; building an
interpreter for triples [<a href="#gries" id="xgries" title="[1] Gries 1971, Compiler Construction for Digital Computers">Gries</a>],
for example, would be a tremendous undertaking. The continuation-passing
version expresses all temporary intermediate results explicitly as
variables appearing in the program text, and all temporary control
structure in the form of <code>LAMBDA</code>-expressions (that is,
closures). It is explicit in directing the order of operations; there is
no non-trivial freedom at any point in the evaluation process.</p>
<p>As a result, once the CPS version of a program has been generated,
the remainder of the compilation process is fairly easy. There is a
reasonably direct correspondence between constructs in the CPS language
and “machine-language” operations (if one assumes <code>CONS</code> to
be a “machine-language” primitive for augmenting environment structure,
which we do). The later passes are complicated only by the desire to
handle certain special cases in an optimal manner, most particularly the
case of a function call whose function position contains a variable
which can be determined to refer to a known
<code>LAMBDA</code>-expression. This analysis must be done after the CPS
conversion because it applies to continuations as well as
<code>LAMBDA</code>-expressions written by the user or generated by
macros.</p>
<p>The CPS language differs from <span class="sc">SCHEME</span> in only
two respects. First, each primitive function is different, in that it
returns no value; instead, it accepts an additional argument, the
<em>continuation</em>, which must be a “function” of one argument, and
by definition invokes the continuation tail-recursively, giving it as an
argument the computed “value” of the primitive function. We extend this
by convention to non-primitive functions, and so <em>all</em> functions
are considered to take a continuation as one of its arguments (by
convention the first – this differs from the convention used in the
examples in [<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch6" title="[6] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>], [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp8" title="[8] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>],
and [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd12" title="[12] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]).
Continuations, however, do not themselves take continuations as
arguments.</p>
<p>Second, no combination may have a non-trivial argument. In strict
continuation-passing style (as described in note {Evalorder} of [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp9" title="[9] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]),
this implies that no combination can have another combination as an
argument, or an <code>IF</code>-expression with a non-trivial consequent
or alternative, etc. We relax this to allow as arguments any trivial
form in the sense described above for the preliminary triviality
analysis. We note that, in principle, trivial expressions require no
unbounded space on the part of the <span class="sc">SCHEME</span>
interpreter to evaluate, and that the compiler need not worry about
control and environment issues for trivial expressions. (Trivial
expressions do require unbounded space on the part of the <span class="sc">MacLISP</span> run-time system, because the point of the
triviality analysis is that trivial expressions can be handled by <span class="sc">MacLISP</span>! The question of what should be considered
trivial is actually a function of the characteristics of our target
machine. We note that, at the least, variables, constants, and
<code>LAMBDA</code>-expressions should be considered trivial. That the
preliminary triviality analysis does not consider
<code>LAMBDA</code>-expressions trivial is a trick so that all closures
will be processed by the CPS-conversion process, and the fact that we
call it a triviality analysis is a white lie. See, however, [<a href="#wand-and-friedman-1-2-3" id="xwand2" title="[2] Wand and Friedman 1976, Compiling Lambda Expressions Using Continuations">Wand
and Friedman</a>].)</p>
<p>The effect of the restriction on combinations is startling. On the
one hand, they do not so constrain the language as to be useless; on the
other hand, they require a radically different approach to the
expression of algorithms. It is easy to see that no control stack is
necessary to evaluate such code, for, as mentioned in [<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch7" title="[7] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>], control stack is used only to keep track
of intermediate values and return addresses, and these arise only in the
case of combinations with non-trivial arguments, and conditionals with
non-trivial predicates.</p>
<p>An algorithm for converting <span class="sc">SCHEME</span> programs
to continuation-passing style was given in Appendix A of [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd13" title="[13] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>].
{Note <a href="#note-old-cps-algorithm" id="xold-cps-algorithm" title="Here we present a set of functions, written in SCHEME, which convert a SCHEME expression from functional style to pure continuation-passing style. ...">Old
CPS Algorithm</a>} The one used in <span class="sc">RABBIT</span> is
almost identical, except that for the convenience of the code-generation
phase a distinction is made between ordinary
<code>LAMBDA</code>-expressions and continuations, and between
combinations used to invoke “functions” and those used to invoke
continuations. These sets can in fact be consistently distinguished, and
it affords a certain amount of error-checking; for example, a
<code>LAMBDA</code>-expression should never appear in the “function”
position of a continuation-invoking combination. Another fine point is
that <code>ASET&#39;</code> can never be applied to a variable bound by a
continuation. Except for such differences arising from their uses, the
two sets of constructs are treated more or less identically in later
phases. An additional difference between the algorithm in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd14" title="[14] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
and the one in <span class="sc">RABBIT</span> is that trivial subforms
are treated as single nodes in the CPS version; these nodes have
pointers to the non-CPS versions of the relevant code, which are largely
ignored by later processing until the final code is to be generated.</p>
<p>It must be emphasized that there is not necessarily a unique CPS
version for a given <span class="sc">SCHEME</span> program; there is as
much freedom as there is in the original program to re-order the
evaluation of subexpressions. In the course of the conversion process
decisions must be made as to what order to use in evaluating arguments
to combinations. The current decision procedure is fairly simple-minded,
consisting mostly of not making copies of constants and the values of
variables. The point here, as earlier, is not so much that <span class="sc">RABBIT</span> has a much better algorithm than other
compilers as that it has a far cleaner way of expressing the result.
(For a complex decision procedure for argument ordering, see [<a href="#wulf-1-2-3-4" id="xwulf2" title="[2] Wulf 1975, The Design of an Optimizing Compiler">Wulf</a>].)
{Note <a href="#note-non-deterministic-cps-conversion" id="xnon-deterministic-cps-conversion" title="As with optimization, so the conversion to continuation-passing style involves decisions which ideally could be made non-deterministically. The decisions made at this level will affect later decisions involving register allocation, etc., which cannot easily be foreseen at this stage.">Non-deterministic
CPS Conversion</a>}</p>
<p><hr></p>
</section>
<section id="e.-environment-and-closure-analysis" class="level3">
<h3><a href="#contents">E.   Environment and closure analysis</a></h3>
<p>This phase consists of four passes over the CPS version of the
program. As with the earlier preliminary analysis, each pass determines
one related set of information and attaches this information to nodes of
the program tree and to property lists.</p>
<p>The first pass (<code>CENV-ANALYZE</code>) analyzes variable
references for the CPS version in a manner similar to that of the first
pass of the preliminary analysis. The results of this previous analysis
are used here in the case of trivial expressions; with this exception
the analysis is redone completely, because additional variables are
introduced by the CPS conversion. (None of these new variables can
appear in an <code>ASET&#39;</code>, however, and so the analysis of written
variables need not be done over.) In addition, for each variable
reference which does not occur in the function position of a
combination, we mark that variable with a non-nil
<code>VARIABLE-REFP</code> property, used later to determine whether
closures need to be created for known functions. The second pass
(<code>BIND-ANALYZE</code>) determines for each
<code>LAMBDA</code>-expression whether a closure will be needed for it
at run time. There are three possibilities:</p>
<ol type="1">
<li>If the function denoted by the <code>LAMBDA</code>-expression is
bound to some variable, and that variable is referenced other than in
function position, then the closure is being treated as data, and must
be a full (standard <code>CBETA</code> format) closure. If the function
itself occurs in non-function position other than in a
<code>LAMBDA</code>-combination, it must be fully closed.</li>
<li>If the closure is bound to some variable, and that variable is
referenced only in function position, but some of these references occur
within other partially or fully closed functions, then this function
must be partially closed. By this we mean that the environment for the
closure must be “consed up”, but no pointer to the code need be added on
as for a full closure. This function will always be called from places
that know the name of the function and so can just perform a
<code>GO</code> to the code, but those such places which are within
closures must have a complete copy of the necessary environment.</li>
<li>In other cases (functions bound to variables referenced only in
function position and never within a closed function, or functions
occurring in function position of <code>LAMBDA</code>-combinations), the
function need not be closed. This is because the environment can always
be fully recovered from the environment at the point of call.</li>
</ol>
<p>In order to determine this information, it is necessary to determine,
for each node, the set of variables referred to from within closed
functions at or below that node. Thus this process and the process of
determining functions to close are highly interdependent, and so must be
accomplished in a single pass.</p>
<p>The second pass also generates a name for each
<code>LAMBDA</code>-expression (to be used as tags in the output code,
as discussed in the examples earlier), and for non-closed functions
determines which variables will be assigned to “registers” or “memory
locations”. For these non-closed functions it may determine that certain
variables need not be assigned locations at all (they are never
referenced, or are bound to other non-closed functions – the latter
circumstance is important when a variable is known to denote a certain
function, but the optimizer was too conservative to perform
beta-substitution for fear of duplicating code and thus wasting space).
Finally, for each variable which is (logically, at run time not
necessarily actually) bound to a known function (and which never appears
in an <code>ASET&#39;</code>), a property <code>KNOWN-FUNCTION</code> is put
on its property list whose value is the node of the CPS version of that
function. This property is used later in generating code for
combinations in whose function positions such variables appear.</p>
<p>The third pass (<code>DEPTH-ANALYZE</code>) examines each
<code>LAMBDA</code>-expression and determines the precise registers or
memory locations through which arguments are to be passed to each.
Closed functions take their arguments in the standard registers
described earlier; non-closed functions may take their arguments in any
desired places. (Partially closed functions could also, but there is
little advantage to this.) The allocation strategy in <span class="sc">RABBIT</span> for non-closed functions is presently merely
stack-like; the deeper the nesting of a function, the higher in the
ordering of “registers” and “memory locations” are the locations
assigned. (See e.g. [<a href="#johnsson-1-2" id="xjohnsson1" title="[1] Johnsson 1975, An Approach to Global Register Allocation">Johnsson</a>]
for a detailed analysis of the register allocation problem.)</p>
<p>The fourth pass (<code>CLOSE-ANALYZE</code>) determines the precise
format of the environment to be constructed for each closure. That is,
while the third pass handles cases for which stack-allocation of
environments will suffice, the fourth pass deals with heap-allocated
environment structures. Recall that the format of an environment can be
completely arbitrary, since the only code which can possibly refer to an
environment is the function for a closure of which the environment was
created. Therefore the compiler which compiles that function has a free
hand in determining the structure of the environment. For the sake of
simplicity, <span class="sc">RABBIT</span> chooses to generate code
which represents environments simply as a list of variable values.
Several environment lists may share a common tail. The environment for a
closure need not contain any variables not needed by the closed
function, but it may if this will allow the sharing of a single
structure among several closures. (There is a problem with variables
modified by <code>ASET&#39;</code> which is discussed in the next
paragraph.)</p>
<p>For each <code>LAMBDA</code>-expression which must be closed, three
sets of variables are computed: 1) the variables which will already be
in the “consed™ environment structure at the time the closure is to be
created; (2) additional variables which must be added (”consed on”) to
the existing structure to create the closure (because at that point they
are spread out in “registers”) {Note <a href="#note-heap-allocated-contours" id="xheap-allocated-contours" title="RABBIT maintains heap-allocated environments as a simple chained list of variable values. However, all the variables which are added on at once as a single set may be regarded as a new &#39;contour&#39; in the Algol sense. Such contours could be heap-allocated ...">Heap-Allocated
Contours</a>}; (3) variables which must be added to the environment
immediately after entering the function because they must eventually be
added in for closures later and they are referred to in
<code>ASET&#39;</code> constructs. The third set arises from a requirement
that <code>ASET&#39;</code> constructs must have a consistent effect, and
confusion can arise if a variable’s value can be in more than one place.
If the value were allowed to be both in a “register” and in an
environment structure, or in several different environment structures,
then altering the value in one place would not affect the other places.
To assure consistency, this third set is computed, and such variables
must at run time be placed in an environment structure to be shared by
all others which refer to such variables.</p>
<p>For every <code>LABELS</code> statement a set of variables is
computed which is the set of variables to be added to the existing
environment on entry to the <code>LABELS</code> body, in order to share
this new structure among all the closures to be created for the
<code>LABELS</code> functions.</p>
<p><hr></p>
</section>
<section id="f.-code-generation" class="level3">
<h3><a href="#contents">F.   Code generation</a></h3>
<p>Given the foregoing analysis, the generation of code is
straightforward, and largely consists of using the information already
gathered to detect special cases. The special cases of interest relate
almost entirely to function calls and closures (indeed, there is little
else in the language for <span class="sc">RABBIT</span>’s purposes!
).</p>
<p><span class="sc">RABBIT</span> has provision for “block compiling” a
number of functions into a single module. This permits an optimization
in which one function can transfer control directly to another without
going through the “UUO handler”. Even if several <em>user</em> functions
are not compiled into a single module, this is still of advantage,
because a single user function can produce a large number of output
functions, as a consequence of the code-generation techniques.</p>
<p>A module consists of a single <span class="sc">MacLISP</span>
function whose body is a single <code>PROG</code>. This
<code>PROG</code> has no local variables, but does have a number of
tags, one for each function in the module. On entry to the module, the
register <code>**ENV**</code> will contain the “environment” for the
function to be executed. As noted above, the format of this is
arbitrary. For functions compiled by <span class="sc">RABBIT</span>,
this is a list whose car is a tag within the <code>PROG</code> and whose
cdr is the “real environment”. {Note <a href="#note-code-pointers" id="xcode-pointers" title="Conceptually a closure is made up of a pointer to some code (a &#39;script&#39; [Smith and Hewitt]) and an environment. In a RABBIT-formatted CBETA, the pointer to the code is encoded into two levels: a pointer to a particular piece of MacLISP code, plus a tag within that PROG. ...">Code
Pointers</a>} At the beginning of the <code>PROG</code> there is always
the code</p>
<pre><code>    (GO (PROG2 NIL (CAR **ENV**)
               (SETQ **ENV** (CDR **ENV**))))</code></pre>
<p>the effect of which is to put the “real environment” in
<code>**ENV**</code> and then perform a computed <code>GO</code> to the
appropriate tag. (This is the only circumstance in which the <span class="sc">MacLISP</span> <code>PROG2</code> and computed
<code>GO</code> constructs are used by <span class="sc">RABBIT</span>-compiled code. Either could be eliminated at
the expense of more bookkeeping, the former by using a temporary
intermediate variable, the latter by using a giant <code>COND</code>
with non-computed <code>GO</code> statements (which is effectively how
the <span class="sc">MacLISP</span> compiler compiler compiles a
computed <code>GO</code> anyway). As always, such trivial issues are
left to the <span class="sc">MacLISP</span> compiler when they do not
bear on the issues of interest in compiling <span class="sc">SCHEME</span> code.) For small functions, often the “main
entry point” is the only closed function, and it would be possible to
eliminate the computed <code>GO</code>, but <span class="sc">RABBIT</span> always outputs one, because is is cheap and
provides a useful error check.</p>
<p>Once the computed <code>GO</code> has been performed, the code
following the tag is responsible for performing its bit of computation
and then exiting. It may exit setting the <code>**FUN**</code> register
to another function, setting up appropriate argument registers, and then
doing <code>(RETURN NIL)</code> to exit the module and enter the UUO
handler; or it may exit by directly transferring control to another
function within the module by performing a <code>GO</code> to the
appropriate tag, after setting up the arguments and
<code>**ENV**</code>. In the latter case the arguments may actually be
passed through “memory locations” rather than the standard “registers”.
(Conceptually, in this optimized case the environment needed for the
function being called is being passed, not in <code>**ENV**</code>, but
spread out in those registers and locations lower than those being used
to pass the arguments.)</p>
<p>Starting with the CPS version of one or more user functions, the
generation of the code for a module proceeds iteratively. Code for each
function is generated in turn, producing one segment of code and a tag;
this tag and code will become part of the body of the module. In
processing a function, other functions may be encountered; in general,
each such function is added to the list of outstanding functions for the
module, and is replaced by code to generate a closure for that function.
When all functions have been processed, the outer structure of the
module is created.</p>
<p>Many situations are treated specially. For example,</p>
<pre><code>    ((LAMBDA ...) ...)</code></pre>
<p>does not cause the <code>LAMBDA</code>-expression to be added to the
list of outstanding functions; rather, a <span class="sc">MacLISP</span>
<code>PROGN</code> is constructed consisting of the argument set-up
followed by the code for the body of the <code>LAMBDA</code>-expression.
A more subtle case is</p>
<pre><code>    (FOO (LAMBDA ...) ...)</code></pre>
<p>where <code>FOO</code> is the name of a <span class="sc">MacLISP</span> primitive and the
<code>LAMBDA</code>-expression is the continuation. In this case a
<code>PROGN</code> is constructed consisting of calling the <span class="sc">MacLISP</span> primitive on the other arguments, putting this
value into the appropriate location, and then executing the body of the
<code>LAMBDA</code>-expression. (It should be noted that all these
special cases must be anticipated by the analysis preceding the code
generation phase.)</p>
<p>In the case of <code>((LAMBDA ...) ...)</code>, we must also handle
the argument set-up a little carefully, because parameters which are
never referred to or which represent known non-closed functions need not
actually be passed. However, the corresponding argument for the first
case must nevertheless be evaluated because it may have a side-effect. A
good example is the result of expanding <code>BLOCK</code> (neglecting
the effects of optimization): there is a (continuation-passing style)
combination of the form:</p>
<pre><code>    ((LAMBDA (C A B) (B C)) cont x (LAMBDA (C) y))</code></pre>
<p>The argument <code>x</code> need not be passed, but presumably has a
side effect and so must be evaluated. The second
<code>LAMBDA</code>-expression need not be closed, and so requires
neither evaluation nor passing. The output code uses a
<code>PROGN</code> to evaluate the arguments which are potentially for
effect. In this way the end result of a <code>BLOCK</code> construct
actually turns out to be a <span class="sc">MacLISP</span>
<code>PROGN</code>. (The routine <code>LAMBDACATE</code> in the Appendix
is responsible for this analysis.) {Note <a href="#note-evaluation-for-effect" id="xevaluation-for-effect" title="This is the point where the notion of evaluation for effect is handled (see {Note Evaluation for Control}). It is detected as the special case of evaluation for value where no one refers to the value! This may be construed as the distinction between “statement” and “expression” made in Algol-like languages.">Evaluation
for Effect</a>}</p>
<p>Another case of interest is a combination whose function position
contains a variable with a <code>KNOWN-FUNCTION</code> property. The
value of this property is the node for the CPS version of the function,
which provides information about possible code generation strategies. We
can decide which arguments needn’t be passed as for the
<code>((LAMBDA ...) ...)</code> case, and can also arrange to call the
function with a direct (<span class="sc">MacLISP</span>) <code>GO</code>
to the appropriate tag within the module. The set-up of the environment
depends on whether the function is non-closed or partially closed; in
the latter case the partial closure is the environment, and in the
former the environment can be recovered from the current one (and may
even be the same).</p>
<p>A certain amount of “peephole optimization” [<a href="#mckeeman" id="xmckeeman" title="[1] McKeeman 1965, Peephole optimization">McKeeman</a>] is also
performed, primarily to make it easier for people to inspect the code
produced, since the <span class="sc">MacLISP</span> compiler will handle
them anyway. Examples of these are avoiding the generation of
<code>SETQ</code> of a variable to the value of that same variable;
reduction of car-cdr chains to single functions, such as
<code>(CAR (CDR (CDR x)))</code> to <code>(CADDR x)</code>; removal of
nested <code>PROGN</code>’s such as</p>
<pre><code>    (PROGN a (PROGN b c) d)  =&gt;  (PROGN a b c d)</code></pre>
<p>and the like; and simplification of nested <code>COND</code>’s, such
as</p>
<pre><code>    (COND (a b)                (COND (a b)
          (T (COND (c d)   =&gt;        (c d)
                   ...)))            ...)</code></pre>
<p>One of the effects of this last peephole optimization is that many
times, when the user writes a <code>COND</code> in a piece of <span class="sc">SCHEME</span> code, that <code>COND</code> is expanded into
<code>IF</code> constructs, and then re-contracted by the peephole
optimization into an equivalent <code>COND</code>! (This fact is of no
practical consequence, but looks cute.)</p>
<p><hr></p>
</section>
</section>
<section id="example-compilation-of-iterative-factorial" class="level2">
<h2><a href="#contents">9.   Example: Compilation of Iterative
Factorial</a></h2>
<p>Here we shall provide a complete example of the compilation of a
simple function <code>IFACT</code> (iterative factorial), to show what
quantities are computed in the course of analyzing the code. We shall
need some notation for the data structures involved. Every node of the
program is represented by a small data structure which has a type and
several named components. (In the actual implementation, a node is
represented as two such structures; one contains named components common
to all program nodes, and the other contains components specific to a
given node type. We shall gloss over this detail here.) For example, a
<code>LAMBDA</code>-expression is represented by a structure of type
<code>LAMBDA</code> with components named <code>UVARS</code> (user
variable names), <code>VARS</code> (the alpha-converted names),
<code>BODY</code> (the node representing the body), <code>ENV</code>
(the environment of the node), and so on. We shall represent a data
structure as the name of its type, with the components written below it
and indented, with colons after each component name. For example:</p>
<pre><code>    LAMBDA
        UVARS:  (A B)
        VARS:   (VAR-43 VAR-44)
        BODY:   COMBINATION
                    ARGS: VARIABLE
                              VAR:   F
                          VARIABLE
                              VAR:   VAR-44
                          VARIABLE
                              VAR:   VAR-43</code></pre>
<p>Notice that the value of a component may itself be a structure. These
structures are always arranged in a tree, so no notation for cycles will
be needed. In the case where a component contains a list of things, we
will write the things as a <span class="sc">LISP</span> list unless the
things are structures, in which case we will simply write them in a
vertical stack, as shown in the example above. To conserve space, in any
single diagram we will show only the named components of interest.
Components may seem to appear and then disappear in the series of
diagrams, but in practice they all exist simultaneously.</p>
<p>The source code for our example:</p>
<pre><code>    (DEFINE IFACT
            (LAMBDA (N)
                    (LABELS ((F (LAMBDA (M A)
                                        (IF (= M 0) A
                                            (F (- M 1) (* M A))))))
                            (F N 1))))</code></pre>
<p>The alpha-conversion process copies the program and produces a tree
of structures. All the bound variables are renamed, and
<code>VARIABLE</code> nodes refer to these new names. The
<code>GLOBALP</code> component in a <code>VARIABLE</code> node is
non-<code>NIL</code> iff the reference is to a global variable. The
<code>ENV</code> component is simply an a-list relating the user names
of variables to the new names; this a-list is computed during the
conversion as the new names are created at <code>LAMBDA</code>,
<code>LABELS</code>, and <code>CATCH</code> nodes.</p>
<pre><code>LAMBDA
    ENV:    ()
    UVARS:  (N)
    VARS:   (VAR-1)
    BODY:
        LABELS
            ENV:        ((N VAR-1))
            UFNVARS:    (F)
            FNVARS:     (FNVAR-2)
            FNDEFS:
                LAMBDA
                    ENV:    ((F FNVAR-2) (N VAR-1))
                    UVARS:  (M A)
                    VARS:   (VAR-3 VAR-4)
                    BODY:   IF
                                ENV:    ((A VAR-4) (M VAR-3) (F FNVAR-2) (N VAR-1))
                                PRED:   COMBINATION
                                            ENV:    ***   (see below)
                                            ARGS:   VARIABLE
                                                        ENV:    ***
                                                        VAR:    =
                                                        GLOBALP: T
                                                    VARIABLE
                                                        ENV:    ***
                                                        VAR:    VAR-3
                                                        GLOBALP: NIL
                                                    CONSTANT
                                                        ENV:    ***
                                                        VALUE:  0
                                CON:   VARIABLE
                                           ENV:    ***
                                           VAR:    VAR-4
                                           GLOBALP: NIL
                                ALT:   COMBINATION
                                           ENV:    ***
                                           ARGS:   VARIABLE
                                                       ENV:    ***
                                                       VAR:    FNVAR-2
                                                       GLOBALP: NIL
                                                   COMBINATION
                                                       ENV:    ***
                                                       ARGS:   VARIABLE
                                                                   ENV:    ***
                                                                   VAR:    -
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   ENV:    ***
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               CONSTANT
                                                                   ENV:    ***
                                                                   VALUE:  1
                                                   COMBINATION
                                                       ENV:    ***
                                                       ARGS:   VARIABLE
                                                                   ENV:    ***
                                                                   VAR:    *
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   ENV:    ***
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               VARIABLE
                                                                   ENV:    ***
                                                                   VAR:    VAR-4
                                                                   GLOBALP: NIL
            BODY:   COMBINATION
                        ENV:    ((F FNVAR-2) (N VAR-1))
                        ARGS:   VARIABLE
                                    ENV:    ((F FNVAR-2) (N VAR-1))
                                    VAR:    FNVAR-2
                                    GLOBALP: NIL
                                VARIABLE
                                    ENV:    ((F FNVAR-2) (N VAR-1))
                                    VAR:    VAR-1
                                    GLOBALP: NIL
                                CONSTANT
                                    ENV:    ((F FNVAR-2) (N VAR-1))
                                    VALUE:  1</code></pre>
<p>The reader is asked to imagine that the expression</p>
<pre><code>    ((A VAR-4) (M VAR-3) (F FNVAR-2) (N VAR-1))</code></pre>
<p>occurs where <code>***</code> appears in the diagram. It should be
clear how the <code>ENV</code> components are computed on the basis of
variables bound at the <code>LAMBDA</code> and <code>LABELS</code>
nodes. The <code>ENV</code> information propagates down the tree to
<code>VARIABLE</code> nodes, where it is used to supply the correct new
name for the one used by the original code.</p>
<p>The first step in the preliminary analysis is the determination of
referenced variables:</p>
<pre><code>LAMBDA
    REFS:   ()
    VARS:   (VAR-1)
    BODY:
        LABELS
            REFS:       (VAR-1)
            FNVARS:     (FNVAR-2)
            FNDEFS:
                LAMBDA
                    REFS:   (FNVAR-2)
                    VARS:   (VAR-3 VAR-4)
                    BODY:   IF
                                REFS:   (FNVAR-2 VAR-3 VAR-4)
                                PRED:   COMBINATION
                                            REFS:   (VAR-3)
                                            ARGS:   VARIABLE
                                                        REFS:   ()
                                                        VAR:    =
                                                        GLOBALP: T
                                                    VARIABLE
                                                        REFS:   (VAR-3)
                                                        VAR:    VAR-3
                                                        GLOBALP: NIL
                                                    CONSTANT
                                                        REFS:   ()
                                                        VALUE:  0
                                CON:   VARIABLE
                                           REFS:   (VAR-4)
                                           VAR:    VAR-4
                                           GLOBALP: NIL
                                ALT:   COMBINATION
                                           REFS:   (FNVAR-2 VAR-3 VAR-4)
                                           ARGS:   VARIABLE
                                                       REFS:   (FNVAR-2)
                                                       VAR:    FNVAR-2
                                                       GLOBALP: NIL
                                                   COMBINATION
                                                       REFS:   (VAR-3)
                                                       ARGS:   VARIABLE
                                                                   REFS:   ()
                                                                   VAR:    -
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   REFS:   (VAR-3)
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               CONSTANT
                                                                   REFS:   ()
                                                                   VALUE:  1
                                                   COMBINATION
                                                       REFS:   (VAR-3 VAR-4)
                                                       ARGS:   VARIABLE
                                                                   REFS:   ()
                                                                   VAR:    *
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   REFS:   (VAR-3)
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               VARIABLE
                                                                   REFS:   (VAR-4)
                                                                   VAR:    VAR-4
                                                                   GLOBALP: NIL
            BODY:   COMBINATION
                        REFS:    (FNVAR-2 VAR-1)
                        ARGS:   VARIABLE
                                    REFS:   (FNVAR-2)
                                    VAR:    FNVAR-2
                                    GLOBALP: NIL
                                VARIABLE
                                    REFS:   (VAR-1)
                                    VAR:    VAR-1
                                    GLOBALP: NIL
                                CONSTANT
                                    REFS:   ()
                                    VALUE:  1</code></pre>
<p>The <code>REFS</code> component is a list of all <em>local</em>
variables referenced at or below the node. Notice that, in general, the
<code>REFS</code> component of a node is the union (considering them as
sets) of the <code>REFS</code> components of its subnodes. In this way
the information sifts up from the <code>VARIABLE</code> nodes. At a
<code>LAMBDA</code>, <code>LABELS</code>, or <code>CATCH</code>, the
variables bound at that node are filtered out of the <code>REFS</code>
sifting up. The <code>REFS</code> for the outer function must always be
<code>()</code>, a useful error check. In this example, we see that
<code>VAR-1</code> (<code>N</code>) is not referenced by the function
<code>FNVAR-2</code> (<code>F</code>). This indicates that a closure for
this function need not contain the value for <code>VAR-1</code> in its
environment. (We will not actually use the information for this purpose,
since later analysis will determine that the function need not have a
closure constructed for it.) Another component <code>ASETVARS</code> is
computed for each node, which contains the set of variables appearing in
an <code>ASET&#39;</code> at or below the node. We have omitted this
information from the diagram since the value is the empty set in all
cases. Certain properties are placed on the property list of each
variable as well, which are not shown here.</p>
<p>The next pass locates trivial subforms:</p>
<pre><code>LAMBDA
    TRIVP:  NIL
    VARS:   (VAR-1)
    BODY:
        LABELS
            TRIVP:      NIL
            FNVARS:     (FNVAR-2)
            FNDEFS:
                LAMBDA
                    TRIVP:  NIL
                    VARS:   (VAR-3 VAR-4)
                    BODY:   IF
                                TRIVP:  NIL
                                PRED:   COMBINATION
                                            TRIVP:  T
                                            ARGS:   VARIABLE
                                                        TRIVP:  T
                                                        VAR:    =
                                                        GLOBALP: T
                                                    VARIABLE
                                                        TRIVP:  T
                                                        VAR:    VAR-3
                                                        GLOBALP: NIL
                                                    CONSTANT
                                                        TRIVP:  T
                                                        VALUE:  0
                                CON:   VARIABLE
                                           TRIVP:  T
                                           VAR:    VAR-4
                                           GLOBALP: NIL
                                ALT:   COMBINATION
                                           TRIVP:  NIL
                                           ARGS:   VARIABLE
                                                       TRIVP:  T
                                                       VAR:    FNVAR-2
                                                       GLOBALP: NIL
                                                   COMBINATION
                                                       TRIVP:  T
                                                       ARGS:   VARIABLE
                                                                   TRIVP:  T
                                                                   VAR:    -
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   TRIVP:  T
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               CONSTANT
                                                                   TRIVP:  T
                                                                   VALUE:  1
                                                   COMBINATION
                                                       TRIVP:  T
                                                       ARGS:   VARIABLE
                                                                   TRIVP:  T
                                                                   VAR:    *
                                                                   GLOBALP: T
                                                               VARIABLE
                                                                   TRIVP:  T
                                                                   VAR:    VAR-3
                                                                   GLOBALP: NIL
                                                               VARIABLE
                                                                   TRIVP:  T
                                                                   VAR:    VAR-4
                                                                   GLOBALP: NIL
            BODY:   COMBINATION
                        TRIVP:  NIL
                        ARGS:   VARIABLE
                                    TRIVP:  T
                                    VAR:    FNVAR-2
                                    GLOBALP: NIL
                                VARIABLE
                                    TRIVP:  T
                                    VAR:    VAR-1
                                    GLOBALP: NIL
                                CONSTANT
                                    TRIVP:  T
                                    VALUE:  1</code></pre>
<p>Constants and variables are always trivial, and trivial combinations
(involving only <span class="sc">MacLISP</span> primitives) are located.
As before, in this pass information sifts up from below. One possibility
not yet explored in <span class="sc">RABBIT</span> is to isolate entire
<span class="sc">SCHEME</span> functions (for example
<code>FNVAR-2</code>), determine that it is, as a whole, trivial,
compile it as a simple <span class="sc">MacLISP</span>
<code>SUBR</code>, and reference it as a primitive. This would in turn
render trivial the combination <code>(F N 1)</code> in the body of the
<code>LABELS</code>, for example.</p>
<p>The analysis of side-effects merely determines that no side-effects
are present, and is uninteresting for our example. The optimization pass
finds no transformations worth making. We will skip over these steps to
the conversion to continuation-passing style. As a simple S-expression,
this may be rendered as:</p>
<pre><code>    (LAMBDA (CONT-5 VAR-1)
            (LABELS ((FNVAR-2
                      (LAMBDA (CONT-6 VAR-3 VAR-4)
                              (IF (= VAR-3 0)
                                  (CONT-6 VAR-4)
                                  (FNVAR-2 CONT-6
                                           (- VAR-3 1)
                                           (* VAR-3 VAR-4))))))
                    (FNVAR-2 CONT-5 VAR-1 1)))</code></pre>
<p>In rendering this as a tree of data structures, we use structures of
type <code>CLAMBDA</code> instead of <code>LAMBDA</code>, etc., in order
to prevent confusion. Trivial forms are represented by structures of
type <code>TRIVIAL</code> with pointers to the data structures from
before. We will not notate such data structures in the following
diagrams, but will simply write an S-expression as a reminder of what
the trivial form was. The types <code>RETURN</code> and
<code>CONTINUATION</code> are like <code>CCOMBINATION</code> and
<code>CLAMBDA</code>, but are distinguished as discussed above for
convenience and for purposes of consistency checking.</p>
<pre><code>CLAMBDA
    VARS:   (CONT-5 VAR-1)
    BODY:   CLABELS
                FNVARS: (FNVAR-2)
                FNDEFS: CLAMBDA
                            VARS:   (CONT-6 VAR-3 VAR-4)
                            BODY:   CIF
                                        PRED:   TRIVIAL
                                                    (= VAR-3 0)
                                        CON:    RETURN
                                                    CONT:   CVARIABLE
                                                                VAR:    CONT-6
                                                    VAL:    TRIVIAL
                                                                VAR-4
                                        ALT:    CCOMBINATION
                                                    ARGS:   TRIVIAL
                                                                FNVAR-2
                                                            CVARIABLE
                                                                VAR:    CONT-6
                                                            TRIVIAL
                                                                (- VAR-3 1)
                                                            TRIVIAL
                                                                (* VAR-3 VAR-4)
                BODY:   CCOMBINATION
                            ARGS:   TRIVIAL
                                        FNVAR-2
                                    CVARIABLE
                                        VAR:    CONT-5
                                    TRIVIAL
                                        VAR-1
                                    TRIVIAL
                                        1</code></pre>
<p>The first post-conversion analysis pass computes <code>ENV</code> and
<code>REFS</code> components as before, this time including the
variables introduced to represent continuations. The <code>ENV</code> in
this case is not an a-list, but simply a list of variables, since no
renaming is taking place. The <code>ENV</code> information sifts down
from above during the tree walk, and on the way back the
<code>REFS</code> information sifts up. For a <code>TRIVIAL</code> node,
the <code>REFS</code> information is taken from the pre-conversion node
referenced by the <code>TRIVIAL</code> node; this <code>REFS</code>
information is shown here as a reminder. As before, the
<code>REFS</code> information for a node is always a subset of the
<code>ENV</code> information.</p>
<pre><code>CLAMBDA
    ENV:    ()
    REFS:   ()
    VARS:   (CONT-5 VAR-1)
    BODY:   CLABELS
                ENV:    (CONT-5 VAR-1)
                REFS:   (CONT-5 VAR-1)
                FNVARS: (FNVAR-2)
                FNDEFS:
                    CLAMBDA
                        ENV:    (FNVAR-2 CONT-5 VAR-1)
                        REFS:   (FNVAR-2)
                        VARS:   (CONT-6 VAR-3 VAR-4)
                        BODY:   CIF
                                    ENV:    ***
                                    REFS:   (FNVAR-2 CONT-6 VAR-3 VAR-4)
                                    PRED:   TRIVIAL
                                                REFS:   (VAR-3)
                                                (= VAR-3 0)
                                    CON:    RETURN
                                                ENV:    ***
                                                REFS:   (CONT-6 VAR-4)
                                                CONT:   CVARIABLE
                                                            ENV:    ***
                                                            REFS:   (CONT-6)
                                                            VAR:    CONT-6
                                                VAL:    TRIVIAL
                                                            REFS:   (VAR-4)
                                                            VAR-4
                                    ALT:    CCOMBINATION
                                                ENV:    ***
                                                REFS:   (FNVAR-2 CONT-6 VAR-3 VAR-4)
                                                ARGS:   TRIVIAL
                                                            REFS:   (FNVAR-2)
                                                            FNVAR-2
                                                        CVARIABLE
                                                            ENV:    ***
                                                            REFS:   (CONT-6)
                                                            VAR:    CONT-6
                                                        TRIVIAL
                                                            REFS:   (VAR-3)
                                                            (- VAR-3 1)
                                                        TRIVIAL
                                                            REFS:   (VAR-3 VAR-4)
                                                            (* VAR-3 VAR-4)
                BODY:   CCOMBINATION
                            ENV:    (FNVAR-2 CONT-5 VAR-1)
                            REFS:   (FNVAR-2 CONT-5 VAR-1)
                            ARGS:   TRIVIAL
                                        REFS:   (FNVAR-2)
                                        FNVAR-2
                                    CVARIABLE
                                        ENV:    (FNVAR-2 CONT-5 VAR-1)
                                        REFS:   (CONT-5)
                                        VAR:    CONT-5
                                    TRIVIAL
                                        REFS    (VAR-1)
                                        VAR-1
                                    TRIVIAL
                                        REFS:   ()
                                        1</code></pre>
<p>The reader is asked to imagine that where <code>***</code> occurs the
expression</p>
<pre><code>    (CONT-6 VAR-3 VAR-4 FNVAR-2 CONT-5 VAR-1)</code></pre>
<p>had been written instead. An additional operation performed on this
pass is to flag all variables referenced in other than function
position. These include <code>VAR-1</code>, <code>VAR-3</code>, etc.;
but <code>FNVAR-2</code> is <em>not</em> among them. This will be of
importance below.</p>
<p>The next pass determines all variables referenced by closures at or
below each node, and also decides which functions will actually be
closed. It is determined that <code>FNVAR-2</code> need not be closed,
because it is referred to only in function position (as determined by
the previous pass), and is not referred to by any other closures. As a
result, no closures are created at all in this function, and so all the
computed sets of variables are empty. This pass also assigns the name
<code>F-7</code> to the outer function, for use later as a tag.</p>
<p>The third pass computes the “depth” of each function, which
determines through what registers or other locations arguments will be
passed for each function. In this case the outer <code>CLAMBDA</code> is
assigned depth 0, and the one labelled <code>FNVAR-2</code> is assigned
depth 2, because it is not closed, and is contained in a depth 0
function of 2 arguments. In this way registers are allocated in a purely
stack-like manner; all closed functions are of depth 0, and all unclosed
ones are at a depth determined by that of the containing function and
its number of arguments.</p>
<p>One way to think about this trick is as follows. A closure consists
of a pointer to a piece of code and a set of values determined at the
time of closure. When the closure is invoked, we execute the code,
making available to it (a) the set of values (its environment), and (b)
some additional arguments. Slicing these components a different way, we
may think of calling the bare code, supplying all the values as
arguments; we pass the arguments in some registers, and the environment
values in some other registers. Put yet another way, if we can determine
that every caller of the closed function can reconstruct the necessary
environment at the time of the call (because it will have available the
necessary values anyway), then we can avoid constructing the closure at
the point where the function should be closed, and instead arrange for
each caller to pass the environment through specified registers. As
mentioned earlier, the compiler has a completely free hand in
determining the format of an environment!</p>
<p>As it happens, the function labelled <code>FNVAR-2</code> does not
reference <code>CONT-5</code> or <code>VAR-1</code>, and so this
argument is of no importance here. It is determined that the following
register assignments will apply:</p>
<pre><code>    CONT-5      **CONT**
    VAR-1       **ONE**
    FNVAR-2     &lt;none&gt;
    CONT-6      **TWO**
    VAR-3       **THREE**
    VAR-4       **FOUR**</code></pre>
<p>{Note <a href="#note-continuation-variable-hack" id="xcontinuation-variable-hack" title="Since the dissertation was written, a simple modification to the routine which converts to continuation-passing style has eliminated some of the register shuffling. The effect of the change was to perform substitutions of one continuation variable for another ...">Continuation
Variable Hack</a>} We will see below that some unnecessary shuffling of
values results; a more complicated register assignment technique would
be useful here. (One was outlined in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd15" title="[15] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>],
but it has not been implemented. See also [<a href="#wulf-1-2-3-4" id="xwulf3" title="[3] Wulf 1975, The Design of an Optimizing Compiler">Wulf</a>]
and [<a href="#johnsson-1-2" id="xjohnsson2" title="[2] Johnsson 1975, An Approach to Global Register Allocation">Johnsson</a>].)</p>
<p>The fourth post-conversion analysis pass determines the format of
environments for closed functions. Since there are none in this example,
this analysis is of little interest here.</p>
<p>Finally, we are ready to generate code. Consider the S-expression
form:</p>
<pre><code>    (LAMBDA (CONT-5 VAR-1)
            (LABELS ((FNVAR-2
                      (LAMBDA (CONT-6 VAR-3 VAR-4)
                              (IF (= VAR-3 0)
                                  (CONT-6 VAR-4)
                                  (FNVAR-2 CONT-6
                                           (- VAR-3 1)
                                           (* VAR-3 VAR-4))))))
                    (FNVAR-2 CONT-5 VAR-1 1)))</code></pre>
<p>The first function encountered is the outer one (named
<code>F-7</code>). In analyzing its body we note the
<code>LABELS</code>, and place all the labelled functions (that is,
<code>FNVAR-2</code>) on the queue of functions yet to be processed. We
then analyze the body of the <code>LABELS</code>. This is a combination,
and so we analyze each argument, producing code for each. Each argument
must be <code>TRIVIAL</code>, a (<code>C</code>)<code>VARIABLE</code>,
or a (<code>C</code>)<code>LAMBDA</code>-expression. (We shall refer to
this set of possibilities as “meta-trivial” which means what “trivial”
did in [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp10" title="[10] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>].)
The variable <code>FNVAR-2</code> refers to a known function which is
not closed, and so we need not set up <code>**FUN**</code>. The others
may be referred to as <code>**CONT**</code>, <code>**ONE**</code>, and
the constant <code>1</code>, respectively. These are to be passed to
<code>FNVAR-2</code> through the registers <code>**TWO**</code>,
<code>**THREE**</code>, and <code>**FOUR**</code> (as determined by the
register allocation pass). Thus the code for <code>F-7</code> looks like
this:</p>
<pre><code>    F-7     ((LAMBDA (Q-40 Q-41 Q-42)
                     (SETQ **FOUR** Q-42)
                     (SETQ **THREE** Q-41)
                     (SETQ **TWO** Q-40))
             **CONT** **ONE** &#39;1)
            (GO FNVAR-2)</code></pre>
<p>The first form sets up the arguments, using a standard “simultaneous
assignment” construction. The second branches to the code for
<code>FNVAR-2.</code> Because a known function is being called, it is
not necessary to set up <code>**NARGS**</code>. Because
<code>FNVAR-2</code> requires no closure, it is not necessary to set up
<code>**ENV**</code>.</p>
<p>The next function on the queue to process is <code>FNVAR-2</code>.
Its body is an <code>IF</code> (actually a <code>CIF</code>); this is
compiled into a <code>COND</code> containing the code for the predicate,
consequent, and alternative:</p>
<pre><code>    (COND (&lt;predicate&gt; &lt;consequent&gt;)
          (T &lt;alternative&gt;))</code></pre>
<p>The predicate is guaranteed to be meta-trivial. It is, in this
example, a trivial combination; this is compiled by changing all the
variable references appropriately, producing
<code>(= **THREE** &#39;0)</code>.</p>
<p>The consequent involves calling an unknown continuation which is in
<code>**TWO**</code>. The returned value is in <code>**FOUR**</code>.
The code produced is:</p>
<pre><code>    (SETQ **FUN** **TWO**)
    (SETQ **ONE** **FOUR**)
    (RETURN NIL)</code></pre>
<p>The <code>(RETURN NIL)</code> exits the module, passing control to
the dispatcher in the <span class="sc">SCHEME</span> interpreter, which
will arrange to invoke the continuation.</p>
<p>The code for the alternative is similar to that for the body of
<code>F-7</code>, because we are calling the known function
<code>FNVAR-2</code>. The generated code is:</p>
<pre><code>    ((LAMBDA (Q-43 Q-44)
             (SETQ **FOUR** Q-44)
             (SETQ **THREE** Q-43))
     (- **THREE** &#39;1)
     (* **THREE** **FOUR**))
    (GO FNVAR-2)</code></pre>
<p>The argument set-up ought to involve copying <code>**TWO**</code>
into <code>**TWO**</code>, but a peephole optimization eliminates that
<code>SETQ</code>.</p>
<p>Putting all this together, the code for <code>FNVAR-2</code> is:</p>
<pre><code>    FNVAR-2 (COND ((= **THREE** &#39;0)
                   (SETQ **FUN** **TWO**)
                   (SETQ **ONE** **FOUR**)
                   (RETURN NIL))
                  (T ((LAMBDA (Q-43 Q-44)
                              (SETQ **FOUR** Q-44)
                              (SETQ **THREE** Q-43))
                      (- **THREE** &#39;1)
                      (* **THREE** **FOUR**))
                     (GO FNVAR-2)))</code></pre>
<p>(We have glossed over the peephole optimizations which eliminate
occurrences of <code>PROGN</code> in such places as <code>COND</code>
clauses.)</p>
<p>There are no more functions to be processed, and so we now create the
final module. The final output, with comments inserted by <span class="sc">RABBIT</span> for debugging purposes, and declarations
supplied by <span class="sc">RABBIT</span> for the benefit of the <span class="sc">MacLISP</span> compiler, looks like this:</p>
<pre><code>(PROGN &#39;COMPILE
       (COMMENT MODULE FOR FUNCTION IFACT)
       (DEFUN ?-37 ()
              (PROG ()
                    (DECLARE (SPECIAL ?-37))
                    (GO (PROG2 NIL (CAR **ENV**) (SETQ **ENV** (CDR **ENV**))))
               F-7  (COMMENT (DEPTH = 0) (FNP = NIL) (VARS = (CONT-5 N)))
                    ((LAMBDA (Q-40 Q-41 Q-42)
                             (SETQ **FOUR** Q-42)
                             (SETQ **THREE** Q-41)
                             (SETQ **TWO** Q-40))
                     **CONT** **ONE** &#39;1)
                    (COMMENT (DEPTH = 2) (FNP = NOCLOSE) (VARS = (CONT-6 M A)))
                    (GO FNVAR-2)
               FNVAR-2
                    (COMMENT (DEPTH = 2) (FNP = NOCLOSE) (VARS = (CONT-6 M A)))
                    (COND ((= **THREE** &#39;0)
                           (SETQ **FUN** **TWO**)
                           (SETQ **ONE** **FOUR**)
                           (RETURN NIL))
                          (T ((LAMBDA (Q-43 Q-44)
                                      (SETQ **FOUR** Q-44)
                                      (SETQ **THREE** Q-43))
                              (- **THREE** &#39;1)
                              (* **THREE** **FOUR**))
                          (COMMENT (DEPTH = 2) (FNP = NOCLOSE) (VARS = (CONT-6 M A)))
                          (GO FNVAR-2)))))
        (SETQ ?-37 (GET &#39;?-37 &#39;SUBR))
        (SETQ IFACT (LIST &#39;CBETA ?-37 &#39;F-7))
        (DEFPROP ?-37 IFACT USER-FUNCTION))</code></pre>
<p>In the interpolated comments, <code>FNP</code> refers to whether the
function being entered or being called is closed or not (the
possibilities are <code>NIL</code>, <code>NOCLOSE</code>, and
<code>EZCLOSE</code>) . The <code>VARS</code> are the passed variables,
expressed as the names from the original source code, except for those
introduced by the CPS conversion. The form <code>(SETQ IFACT ...)</code>
constructs the closure for the globally defined function
<code>IFACT</code>. The <code>DEFPROP</code> form provides debugging
information.</p>
<p>The points of interest in this example are the isolation of trivial
subforms, and the analysis of the function <code>FNVAR-2</code> which
allows it to be called with <code>GO</code>. Examination of the output
code will show that <code>FNVAR-2</code> is coded as an iterative loop.
While the register allocation leaves something to be desired, the inner
loop does surprisingly little shuffling. (This should be compared with
the code suggested in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd16" title="[16] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
for this function.) For those who prefer “real” machine language, we
give a plausible transcription of the <span class="sc">MacLISP</span>
code into our hypothetical machine language:</p>
<pre><code>    IFACT:  PUSH CONT                ;CONT contains the return address
            PUSH ONE
            PUSH 1
            POP FOUR
            POP THREE
            POP TWO
            GOTO FNVAR2
    FNVAR2: JUMP-IF-ZERO THREE,FNV2A
            MOVE ONE,FOUR
            RETURN (TWO)             ;return to address in TWO
    FNV2A:  MOVE TEMP,THREE          ;TEMP is used to evaluate
            ADD TEMP,1               ; trivial forms
            PUSH TEMP
            MOVE TEMP,THREE
            MUL TEMP,FOUR
            PUSH TEMP
            POP FOUR
            POP THREE
            GOTO FNVAR2</code></pre>
<p>While this is not the world’s most impressively tight code, it again
shows the essential iterative structure of the inner loop. The primary
problem is the absence of analysis of which registers are used when.
Leaving aside the question of allocating registers, one could at least
determine when assigning values to registers for argument set-up can
occur sequentially rather than simultaneously.</p>
<p>There are a few other obvious optimizations which have not been
performed, for example the elimination of <code>(GO FNVAR-2)</code> just
before the tag <code>FNVAR-2</code>. While this would not have been
difficult, we knew that the <span class="sc">MacLISP</span> compiler
would take care of this for us; since it is not a very interesting
issue, we let it slide.</p>
<p><hr></p>
</section>
<section id="performance-measurements" class="level2">
<h2><a href="#contents">10.   Performance Measurements</a></h2>
<p><span class="sc">RABBIT</span> has provision for metering runtime
usage, and for controlling whether certain options in the optimizer are
used. The standard test case has been <span class="sc">RABBIT</span>
compiling itself (!); by running both interpreted and compiled version
of this task, some comparisons have been made. Two different compiled
versions have also been tested, where the code was produced with or
without using the optimizer.</p>
<p>The overall speed gain of unoptimized compiled code over interpreted
code has been measured to be a factor of 25. The speed gain ratio
excluding time for garbage collection was 17, and the garbage collection
time ratio was 34. (The <span class="sc">SCHEME</span> interpreter does
a lot of consing. The straight runtime ratio of 17 is roughly typical
for standard <span class="sc">LISP</span> compilers on non-numeric
code.)</p>
<p>The overall speed ratio of optimized compiled code to unoptimized
compiled code has been measured to be 1.2. The speed ratio excluding
garbage collection was 1.37, and the garbage collection time ratio was
1.07. We conclude that the amount of consing was reduced very little,
despite optimizations which may eliminate closures, because the phase-2
analysis of closures eliminated most consing from that source anyway.
Eliminations of register shuffling because of substitutions of one
variable for another were probably more significant.</p>
<p>Combining these figures yields an overall speed ratio for optimized
compiled code over interpreted code of about 30.</p>
<p>Turning now to the analysis of compilation time, as opposed to
running time, we have found that using the optimizer approximately
doubles the cost of compilation. It might be possible to reduce this
with a more clever optimizer; presently <span class="sc">RABBIT</span>
wastes much time re-doing certain analysis unnecessarily. The extra time
needed by the optimizer excluding garbage collection is only half again
the overall compilation time, but the garbage collection time triples,
because the optimizer copies and re-copies parts of the program.</p>
<p>There is also one error check which is very expensive; it checks
every argument of a combination against every other argument to check
for possible side-effect conflicts (this is the “liberal” analysis in
<code>EFFS-ANALYZE</code>, and the testing done by
<code>CHECK-COMBINATION-PEFFS</code>). Use of this error check increased
compilation time by thirty percent.</p>
<p><hr></p>
</section>
<section id="comparison-with-other-work" class="level2">
<h2><a href="#contents">11.   Comparison with Other Work</a></h2>
<p>The only other work we know of similar to ours is that in [<a href="#wand-and-friedman-1-2-3" id="xwand3" title="[3] Wand and Friedman 1976, Compiling Lambda Expressions Using Continuations">Wand
and Friedman</a>]. They use a technique from category theory known as
factorization to isolate trivial expressions. As far as they go, their
work is similar to ours; they have written a compiler for <span class="sc">LISP</span> code, producing output code which uses
continuations. However, they indicate that they cannot interface
compiled and interpreted code correctly. Moreover, while they use
continuations, they do not make general use of closures, and in fact
there is no clue that closures are permitted in their source language,
or that functions are permissible as data objects. (In fact, there is
evidence to the contrary in several examples they give involving an
expression</p>
<pre><code>    (MAPCAR (QUOTE (LAMBDA ...)) ...)</code></pre>
<p>These seem to indicate that they have not made the crucial
distinction between treating a function as a data object and treating a
representation of a function as data.) Wand and Friedman do realize the
importance of tail-recursion, but fail to mention the necessity for
lexical scoping (perhaps taking it for granted). We feel that the
contributions of category theory may provide interesting new ways to
analyze programs, but also feel that Wand and Friedman have not, in the
work cited, explored it thoroughly, since they have not even explored
the issue of closures as such.</p>
<p>Somewhat more distantly related is the work of Carter and others at
the IBM T.J. Watson Research Lab. [<a href="#carter-1-2" id="xcarter1" title="[1] Carter 1977, A Case Study of a New Code Generation Technique for Compilers">Carter</a>]
This work is similar in spirit, in that it uses “macro definitions” of
complex operators, which are integrated into the program being compiled,
followed by source-to-source program transformations which optimize the
resulting code. However, they have primarily worked with definitions of
complex data manipulations, such as string concatenation, whereas this
report has dealt exclusively with environment and control operations.
(Also, as a matter of taste, we find <span class="sc">SCHEME</span> a
simpler and more tractable language to deal with than the low-level
dialect of <span class="sc">PL/I</span> used in [<a href="#carter-1-2" id="xcarter2" title="[2] Carter 1977, A Case Study of a New Code Generation Technique for Compilers">Carter</a>],
partly because of its closeness to lambda-calculus and partly because
<span class="sc">SCHEME</span> inherits from <span class="sc">LISP</span> the natural ability to deal with representations
of its own programs.)</p>
<p><hr></p>
</section>
<section id="conclusions-and-future-work" class="level2">
<h2><a href="#contents">12. Conclusions and Future Work</a></h2>
<p>Lexical scoping, tail-recursion, the conceptual treatment of
functions (as opposed to representations thereof) as data objects, and
the ability to notate “anonymous” functions make <span class="sc">SCHEME</span> an excellent language in which to express
program transformations and optimizations. Imperative constructs are
easily modelled by applicative definitions. Anonymous functions make it
easy to avoid needless duplication of code and conflict of variable
names. A language with these properties is useful not only at the
preliminary optimization level, but for expressing the results of
decisions about order of evaluation and storage of temporary quantities.
These properties make <span class="sc">SCHEME</span> as good a candidate
as any for an <span class="sc">UNCOL</span>. The proper treatment of
functions and function calls leads to generation of excellent imperative
low-level code.</p>
<p>We have emphasized the ability to treat functions as data objects. We
should point out that one might want to have a very simple run-time
environment which did not support complex environment structures, or
even stacks. Such an end environment does not preclude the use of the
techniques described here. Many optimizations result in the elimination
of <code>LAMBDA</code>-expressions; post CPS-conversion analysis
eliminates the need to close many of the remaining
<code>LAMBDA</code>-expressions. One could use the macros and internal
representations of <span class="sc">RABBIT</span> to describe
intermediate code transformations, and require that the final code not
actually create any closures. As a concrete example, imagine writing an
operating system in <span class="sc">SCHEME</span>, with machine words
as the data domain (and functions excluded from the run-time data
domain). We could still meaningfully write, for example:</p>
<pre><code>    (IF (OR (STOPPED (PROCESS I))
            (AWAITING-INPUT (PROCESS I)))
        (SCHEDULE-LOOP (+ I 1))
        (SCHEDULE-PROCESS I))</code></pre>
<p>While the intermediate expansion of this code would conceptually
involve the use of functions as data objects, optimizations would reduce
the final code to a form which did not require closures at run time.</p>
<p>An experiment we would like to try would be to use <span class="sc">CGOL</span> [<a href="#pratt" id="xpratt" title="[1] Pratt 1976, CGOL - An Alternative External Representation for LISP Users">Pratt</a>],
a program which parses <span class="sc">ALGOL</span>-like syntax and
produces <span class="sc">LISP</span> code, as a front end for <span class="sc">RABBIT</span>. The result would be a compiler for an <span class="sc">ALGOL</span>-like language which would produce code by the
processes of parsing (by <span class="sc">CGOL</span>); macro-expansion,
optimization, and output of <span class="sc">MacLISP</span> code (by
<span class="sc">RABBIT</span>); and generation of <span class="sc">PDP-10</span> machine language (by the <span class="sc">MacLISP</span> compiler).</p>
<p>Among the interesting issues we have not dealt with or have not yet
implemented in <span class="sc">RABBIT</span> are: compilation of data
manipulation primitives, interaction of such primitives, procedure
integration of the most general form, and complex register allocation. A
particularly interesting issue is that of data type analysis. Such
analysis would solve certain problems which cannot easily be solved now
by <span class="sc">RABBIT</span>. For example, consider the piece of
code:</p>
<pre><code>    (IF (OR A B) X Y)</code></pre>
<p>The macro-expansion and optimization phases will reduce this to:</p>
<pre><code>    (IF A (IF A X Y) (IF B X Y))</code></pre>
<p>The difficulty is that <span class="sc">RABBIT</span> has no way of
knowing that <code>A</code> is known to be non-null in the first inner
<code>IF</code> by virtue of the testing of <code>A</code> in the outer
<code>IF</code>. If it could realize this, then the code would reduce to
the more reasonable:</p>
<pre><code>    (IF A X (IF B X Y))</code></pre>
<p>Compare this with the case of <code>(IF (AND ...) ...)</code>
presented earlier.</p>
<p>One particularly nagging difficulty concerns an interaction between
<code>CATCH</code> and optimization by substituting expressions for
variables. The problem is that if an expression with a side-effect is
substituted into a place which is evaluated after the return of a call
to an unknown function (where it had been written at a place normally
evaluated before the call), and if a <code>CATCH</code> is performed
within that unknown function, and the escape function is subsequently
called more than once, then the expression with a side-effect will be
evaluated twice instead of once. There is no possible way to decide
whether this can happen, other than to be fearful of all unknown
function calls. In practice this defeats most optimization. We have
ignored this difficulty in <span class="sc">RABBIT</span>. It probably
indicates that escape functions are even more intractable than we had
earlier believed. It would not be so bad if we could insist that an
escape function be called no more than once (or rather, that a
<code>CATCH</code> be returned from no more than once, implying that if
the escape function is used it must be dynamically within the body of
the <code>CATCH</code>). If this restriction is enforced, or if
<code>CATCH</code> is forbidden, then in fact no continuation can be
invoked more than once, which, with other suitable restrictions,
accounts for the ability of most languages to use stacks instead of
trees for their control stacks.</p>
<p><hr></p>
</section>
<section id="notes" class="level2">
<h2><a href="#contents">Notes</a></h2>
<section id="section" class="level3">
<h3></h3>
<section id="note-aset-is-imperative-1-2" class="level4">
<h4>{Note <code>ASET&#39;</code> Is Imperative} <span class="fr"><a href="#xaset-is-imperative1">1</a>, <a href="#xaset-is-imperative2">2</a></span><br />
</h4>
<p>It is true that <code>ASET&#39;</code> is an actual imperative which
produces a side effect, and is not expressed applicatively.
<code>ASET&#39;</code> is used only for two purposes in practice: to
initialize global variables (often relating to <span class="sc">MacLISP</span> primitives), and to implement objects with
state (cells, in the <span class="sc">PLASMA</span> sense [<a href="#smith-and-hewitt-1-2" id="xsmith1" title="[1] Smith and Hewitt 1975, A PLASMA Primer (draft)">Smith and
Hewitt</a>] [<a href="#hewitt-and-smith" id="xhewitt-and-smith" title="[1] Hewitt and Smith 1975, Towards a Programming Apprentice">Hewitt
and Smith</a>]). If we were to redesign <span class="sc">SCHEME</span>
from scratch, I imagine that we would introduce cells as our primitive
side-effect rather than <code>ASET&#39;</code>. The decision to use
<code>ASET&#39;</code> was motivated primarily by the desire to interface
easily to the <span class="sc">MacLISP</span> environment (and, as a
corollary, to be able to implement <span class="sc">SCHEME</span> in
three days instead of three years!).</p>
<p>We note that in approximately one hundred pages of <span class="sc">SCHEME</span> code written by three people, the non-quoted
<code>ASET</code> has never been used, and <code>ASET&#39;</code> has been
used only a dozen times or so, always for one of the two purposes
mentioned above. In most situations where one would like to write an
assignment of some kind, macros which expand into applicative
constructions suffice.</p>
</section>
<section id="note-code-pointers" class="level4">
<h4>{Note Code Pointers} <span class="fr"><a href="#xcode-pointers">^</a></span><br />
</h4>
<p>Conceptually a closure is made up of a pointer to some code (a
“script” [<a href="#smith-and-hewitt-1-2" id="xsmith2" title="[2] Smith and Hewitt 1975, A PLASMA Primer (draft)">Smith and
Hewitt</a>]) and an environment. In a <span class="sc">RABBIT</span>-formatted <code>CBETA</code>, the pointer to
the code is encoded into two levels: a pointer to a particular piece of
<span class="sc">MacLISP</span> code, plus a tag within that
<code>PROG</code>. This implementation was forced upon us by <span class="sc">MacLISP</span>. If we could easily create pointers into the
middle of a <code>PROG</code>, we could avoid this two-level
encoding.</p>
<p>On the other hand, this is not just an engineering kludge, but can be
provided with a reasonable semantic explanation: rather than compiling a
lot of little functions, we compile a single big function which is a
giant <code>CASE</code> statement. Wherever we wish to make a closure of
a little function, we actually close a different little function which
calls the big function with an extra argument to dispatch on.</p>
</section>
<section id="note-continuation-variable-hack" class="level4">
<h4>{Note Continuation Variable Hack} <span class="fr"><a href="#xcontinuation-variable-hack">^</a></span><br />
</h4>
<p>Since the dissertation was written, a simple modification to the
routine which converts to continuation-passing style has eliminated some
of the register shuffling. The effect of the change was to perform
substitutions of one continuation variable for another, in situations
such as:</p>
<pre><code>    ((CLAMBDA (CONT-3 ...) ...)
     CONT-2 ...)</code></pre>
<p>where <code>CONT-2</code> would be substituted for
<code>CONT-3</code> in the body of the <code>CLAMBDA</code>-expression.
Once this is done, <code>CONT-3</code> is unreferenced, and so is not
really passed at all by virtue of the phase-2 analysis. The result is
that continuations are not copied back and forth from register to
register. In the iterative factorial example in the text, the actual
register assignment would be:</p>
<pre><code>    CONT-5      **CONT**
    VAR-1       **ONE**
    FNVAR-2     &lt;none&gt;
    VAR-3       **TWO**
    VAR-4       **THREE**</code></pre>
<p>This optimization is discussed more thoroughly in the Appendix near
the routine <code>CONVERT-COMBINATION</code>.</p>
</section>
<section id="note-dijkstras-opinion" class="level4">
<h4>{Note Dijkstra’s Opinion} <span class="fr"><a href="#xdijkstras-opinion">^</a></span><br />
</h4>
<p>In [<a href="#dijkstra-1-2" id="xdijkstra2" title="[2] Dijkstra 1976, A Discipline of Programming">Dijkstra</a>] a
remark is made to the effect that defining the
<strong>while</strong>-<strong>do</strong> construct in terms of
function calls seems unusually clumsy. In [<a href="#steele-1-2-3-4-5" id="xste5" title="[5] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele</a>]
we reply that this is due partly to Dijkstra’s choice of <span class="sc">ALGOL</span> for expressing the definition. Here we would add
that, while such a definition is completely workable and is useful for
compilation purposes, we need never tell the user that we defined
<strong>while</strong>-<strong>do</strong> in this manner! Only the
writer of the macros needs to know the complexity involved; the user
need not, and should not, care as long as the construction works when he
uses it.</p>
</section>
<section id="note-evaluation-for-control-1-2" class="level4">
<h4>{Note Evaluation for Control} <span class="fr"><a href="#xevaluation1">1</a>, <a href="#xevaluation2">2</a></span><br />
</h4>
<p>It is usual in a compiler to distinguish at least three “evaluation
contexts”: value, control, and effect. (See [<a href="#wulf-1-2-3-4" id="xwulf4" title="[4] Wulf 1975, The Design of an Optimizing Compiler">Wulf</a>],
for example.) Evaluation for control occurs in the predicate of an
<code>IF</code>, where the point is not so much to produce a data object
as simply to decide whether it is true or false. The results of
<code>AND</code>, <code>OR</code>, and <code>NOT</code> operations in
predicates are “encoded in the program counter”. When compiling an
<code>AND</code>, <code>OR</code>, or <code>NOT</code>, a flag is passed
down indicating whether it is for value or for control; in the latter
case, two tags are also passed down, indicating the branch targets for
success or failure. (This is called “anchor pointing” in [<a href="#allen-and-cocke-1-2-3-4-5" id="xaac4" title="[4] Allen and Cocke 1972, A Catalogue of Optimizing Transformations">Allen
and Cocke</a>].)</p>
<p>In <span class="sc">RABBIT</span> this notion falls out automatically
without any special handling, thanks to the definition of
<code>AND</code> and <code>OR</code> as macros expanding into
<code>IF</code> statements. If we were also to define <code>NOT</code>
as a macro</p>
<pre><code>    (NOT x)  =&gt;  (IF x &#39;NIL &#39;T)</code></pre>
<p>then nearly all such special “evaluation for control” cases would be
handled by virtue of the nested-<code>IF</code> transformation in the
optimizer.</p>
<p>One transformation which ought to be in the optimizer is</p>
<pre><code>    (IF ((LAMBDA (X Y ...) &lt;body&gt;) A B ...) &lt;con&gt; &lt;alt&gt;)
       =&gt;  ((LAMBDA (X Y ...) (IF &lt;body&gt; &lt;con&gt; &lt;alt&gt;)) A B ...)</code></pre>
<p>which could be important if the <code>&lt;body&gt;</code> is itself
an <code>IF</code>. (This transformation would occur at a point (in the
optimizer) where no conflicts between <code>X</code>, <code>Y</code>,
and variables used in <code>&lt;con&gt;</code> and
<code>&lt;alt&gt;</code> could occur.)</p>
</section>
<section id="note-evaluation-for-effect" class="level4">
<h4>{Note Evaluation for Effect} <span class="fr"><a href="#xevaluation-for-effect">^</a></span><br />
</h4>
<p>This is the point where the notion of evaluation for effect is
handled (see {Note <a href="#note-evaluation-for-control-1-2" id="xevaluation2" title="It is usual in a compiler to distinguish at least three &#39;evaluation contexts&#39;: value, control, and effect. (See [Wulf], for example.) Evaluation for control occurs in the predicate of an IF, where the point is not so much to produce a data object as simply to decide whether it is true or false. ...">Evaluation
for Control</a>}). It is detected as the special case of evaluation for
value where no one refers to the value! This may be construed as the
distinction between “statement” and “expression” made in Algol-like
languages.</p>
</section>
<section id="note-full-funarg-example" class="level4">
<h4>{Note Full-Funarg Example} <span class="fr"><a href="#xfull-funarg-example">^</a></span><br />
</h4>
<p>As an example of the difference between lexical and dynamic scoping,
consider the classic case of the “funarg problem”. We have defined a
function <code>MAPCAR</code> which, given a function and a list,
produces a new list of the results of the function applied to each
element of the given list:</p>
<pre><code>    (DEFINE MAPCAR
            (LAMBDA (FN L)
                    (IF (NULL L) NIL
                        (CONS (FN (CAR L)) (MAPCAR FN (CDR L))))))</code></pre>
<p>Now suppose in another program we have a list <code>X</code> and a
number <code>L</code>, and want to add <code>L</code> to every element
of <code>X</code>:</p>
<pre><code>    (MAPCAR (LAMBDA (Z) (+ Z L)) X)</code></pre>
<p>This works correctly in a lexically scoped language such as <span class="sc">SCHEME</span>, because the <code>L</code> in the function
<code>(LAMBDA (Z) (+ Z L))</code> refers to the value of <code>L</code>
at the point the <code>LAMBDA</code>-expression is evaluated. In a
dynamically scoped language, such as standard <span class="sc">LISP</span>, the <code>L</code> refers to the most recent
run-time binding of <code>L</code>, which is the binding in the
definition of <code>MAPCAR</code> (which occurs between the time the
<code>LAMBDA</code>-expression is passed to <code>MAPCAR</code> and the
time the <code>LAMBDA</code>-expression is invoked).</p>
</section>
<section id="note-generalized-labels" class="level4">
<h4>{Note Generalized <code>LABELS</code>} <span class="fr"><a href="#xgeneralized-labels">^</a></span><br />
</h4>
<p>Since the dissertation was written, and indeed after [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr5" title="[5] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>] came out, the format of <code>LABELS</code> in <span class="sc">SCHEME</span> was generalized to permit labelled functions to
be defined using any of the same three formats permitted by
<code>DEFINE</code> in [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr6" title="[6] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>]. <span class="sc">RABBIT</span> has been updated to reflect
this change, and the code for it appears in the Appendix.</p>
</section>
<section id="note-heap-allocated-contours" class="level4">
<h4>{Note Heap-Allocated Contours} <span class="fr"><a href="#xheap-allocated-contours">^</a></span><br />
</h4>
<p><span class="sc">RABBIT</span> maintains heap-allocated environments
as a simple chained list of variable values. However, all the variables
which are added on at once as a single set may be regarded as a new
“contour” in the Algol sense. Such contours could be heap-allocated
arrays (vectors), and so an environment would be a chained list of such
little arrays. The typical Algol implementation technique using a
“display” (a margin array whose elements point at successive elements
(contours) of the environment chain) is clearly applicable here. One
advantage of the list-of-all-values representation actually used in
<span class="sc">RABBIT</span> is that null contours automatically add
no content to the environment structure, which makes it easier to
recognize later, in the code generator, that no environment adjustments
are necessary in changing between two environments which differ only by
null contours (see the code for <code>ADJUST-KNOWNFN-CENV</code> in the
Appendix).</p>
</section>
<section id="note-loop-unrolling" class="level4">
<h4>{Note Loop Unrolling} <span class="fr"><a href="#xloop-unrolling">^</a></span><br />
</h4>
<p>In the case of a <code>LABELS</code> used to implement a loop, the
substitution of a labelled function for the variable which names it
would constitute an instance of loop unrolling [<a href="#allen-and-cocke-1-2-3-4-5" id="xaac5" title="[5] Allen and Cocke 1972, A Catalogue of Optimizing Transformations">Allen
and Cocke</a>], particularly if the substitution permitted subsequent
optimizations such as eliminating dead code. Here, as elsewhere, a
specific optimization technique falls out as a consequence of the more
general technique of beta-conversion.</p>
</section>
<section id="note-multiple-argument-continuations" class="level4">
<h4>{Note Multiple-Argument Continuations} <span class="fr"><a href="#xmultiple-argument-continuations">^</a></span><br />
</h4>
<p>One could easily define a <span class="sc">SCHEME</span>-like
language in which continuations could take more than one argument (that
is, functions could return several values); see the discussion in [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd17" title="[17] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>].
We have elected not to provide for this in <span class="sc">SCHEME</span> and <span class="sc">RABBIT</span>.</p>
</section>
<section id="note-non-deterministic-cps-conversion" class="level4">
<h4>{Note Non-deterministic CPS Conversion} <span class="fr"><a href="#xnon-deterministic-cps-conversion">^</a></span><br />
</h4>
<p>As with optimization, so the conversion to continuation-passing style
involves decisions which ideally could be made non-deterministically.
The decisions made at this level will affect later decisions involving
register allocation, etc., which cannot easily be foreseen at this
stage.</p>
</section>
<section id="note-non-deterministic-optimization" class="level4">
<h4>{Note Non-deterministic Optimization} <span class="fr"><a href="#xnon-deterministic-optimization">^</a></span><br />
</h4>
<p>To simplify the implementation, <span class="sc">RABBIT</span> uses
only a deterministic (and very conservative) optimizer. Ideally, an
optimizer would be non-deterministic in structure; it could try an
optimization, see how the result interacted with other optimizations,
and back out if the end result is not as good as desired. We have
experimented briefly with the use of the <span class="sc">AMORD</span>
language [<a href="#doyle-1-2" id="xdoyle2" title="[2] Doyle etal 1977, AMORD: A Dependency-Based Problem-Solving Language">Doyle</a>]
to build a non-deterministic compiler, but have no significant results
yet.</p>
<p>We can see more clearly the fundamental unity of macros and other
optimizations in the light of this hypothetical non-deterministic
implementation. Rather than trying to guess ahead of time whether a
macro expansion or optimization is desirable, it goes ahead and tries,
and then measures the utility of the result. The only difference between
a macro and other optimizations is that a macro call is an
all-or-nothing situation: if it cannot be expanded for some reason, it
is of infinite disutility, while if it can its disutility is finite.
This leads to the idea of non-deterministic macro expansions, which we
have not pursued.</p>
</section>
<section id="note-non-quoted-aset" class="level4">
<h4>{Note Non-quoted ASET} <span class="fr"><a href="#xnon-quoted-aset">^</a></span><br />
</h4>
<p>The <span class="sc">SCHEME</span> interpreter permits one to compute
the name of the variable, but for technical and philosophical reasons
<span class="sc">RABBIT</span> forbids this. We shall treat
“<code>ASET&#39;</code>” as a single syntactic object (think
“<code>ASETQ</code>”).</p>
<p>Hewitt (private communication) and others have objected that the
<code>ASET</code> primitive is “dangerous” in that one cannot predict
what variable may be clobbered, and in that it makes one dependent on
the representation of variables (since one can “compute up” an arbitrary
variable to be set). The first is a valid objection on the basis of
programming style or programming philosophy. (Indeed, on this basis
alone it was later decided to remove <code>ASET</code> from the <span class="sc">SCHEME</span> language, leaving only <code>ASET&#39;</code> in
[<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr7" title="[7] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>].) The second is only slightly true; the compiler can treat
<code>ASET</code> with an non-quoted first argument as a sort of macro.
Let <code>V1</code>, <code>V2</code>, …, <code>VN</code> be the names of
the bound variables accessible to the occurrence of <code>ASET</code> in
question. These names are all distinct, for if two are the same, one
variable “shadows” another, and so we may omit the one shadowed (and so
inaccessible). Then we may write the transformation:</p>
<pre><code>    (ASET a b)  =&gt;  ((LAMBDA (Q1 Q2)
                             (COND ((EQ Q1 &#39;V1) (ASET&#39; V1 Q2))
                                   ((EQ Q1 &#39;V2) (ASET&#39; V2 Q2))
                                   ...
                                   ((EQ Q1 &#39;VN) (ASET&#39; VN Q2))
                                   (T (GLOBAL-SET P Q1 Q2))))
                     a
                     b)</code></pre>
<p>This transformation is to be made after the alpha-conversion process,
which renames all variables; <code>Q1</code> and <code>Q2</code> are two
more generated variables guaranteed not to conflict with
<code>V1</code>, …, <code>VN</code>. This expansion makes quite explicit
the fact that we are comparing against a list of <em>symbols</em> to
decide which <em>variable</em> to modify. The actual run-time
representation of variables is not exploited, the one exception being
the <code>GLOBAL-SET</code> operator, which raises questions about the
meaning of the global environment and the user interface which we are
not prepared to answer.</p>
<p>(See also {Note <a href="#note-aset-is-imperative-1-2" id="xaset-is-imperative2" title="It is true that ASET&#39; is an actual imperative which produces a side effect, and is not expressed applicatively. ASET&#39; is used only for two purposes in practice: to initialize global variables (often relating to MacLISP primitives), and to implement objects with state ..."><code>ASET&#39;</code>
Is Imperative</a>}.)</p>
</section>
<section id="note-old-cps-algorithm" class="level4">
<h4>{Note Old CPS Algorithm} <span class="fr"><a href="#xold-cps-algorithm">^</a></span><br />
</h4>
<p>We reproduce here Appendix A of [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd18" title="[18] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]:</p>
<p>Here we present a set of functions, written in <span class="sc">SCHEME</span>, which convert a <span class="sc">SCHEME</span>
expression from functional style to pure continuation-passing style.
{Note <a href="#note-old-cps-algorithm" title="Hewitt has performed similar experiments on PLASMA programs (personal communication and talks)"><span class="sc">PLASMA</span> CPS</a>} {{See [<a href="#declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" id="xd19" title="[19] Steele 1976, LAMBDA: The Ultimate Declarative">Declarative</a>]
for this note.}}</p>
<pre><code>(ASET&#39; GENTEMPNUM O)

(DEFINE GENTEMP
        (LAMBDA (X)
                (IMPLODE (CONS X (EXPLODEN (ASET&#39; GENTEMPNUM (+ GENTEMPNUM 1)))))))</code></pre>
<p><code>GENTEMP</code> creates a new unique symbol consisting of a
given prefix and a unique number.</p>
<pre><code>(DEFINE CPS (LAMBDA (SEXPR) (SPRINTER (CPC SEXPR NIL &#39;#CONT#))))</code></pre>
<p><code>CPS</code> (Continuation-Passing Style) is the main function;
its argument is the expression to be converted. It calls
<code>CPC</code> (C-P Conversion) to do the real work, and then calls
<code>SPRINTER</code> to pretty-print the result, for convenience. The
symbol <code>#CONT#</code> is used to represent the implied continuation
which is to receive the value of the expression.</p>
<pre><code>(DEFINE CPC
        (LAMBDA (SEXPR ENV CONT)
                (COND ((ATOM SEXPR) (CPC-ATOM SEXPR ENV CONT))
                      ((EQ (CAR SEXPR) &#39;QUOTE)
                       (IF CONT &quot;(,CONT ,SEXPR) SEXPR))
                      ((EQ (CAR SEXPR) &#39;LAMBDA)
                       (CPC-LAMBDA SEXPR ENV CONT))
                      ((EQ (CAR SEXPR) &#39;IF)
                       (CPC-IF SEXPR ENV CONT))
                      ((EQ (CAR SEXPR) &#39;CATCH)
                       (CPC-CATCH SEXPR ENV CONT))
                      ((EQ (CAR SEXPR) &#39;LABELS)
                       (CPC-LABELS SEXPR ENV CONT))
                      ((AND (ATOM (CAR SEXPR))
                            (GET (CAR SEXPR) &#39;AMACRO))
                       (CPC (FUNCALL (GET (CAR SEXPR) &#39;AMACRO)
                                     SEXPR) ENV CONT))
                      (T (CPC-FORM SEXPR ENV CONT)))))</code></pre>
<p><code>CPC</code> merely dispatches to one of a number of subsidiary
routines based on the form of the expression <code>SEXPR</code>.
<code>ENV</code> represents the environment in which <code>SEXPR</code>
will be evaluated; it is a list of the variable names. When
<code>CPS</code> initially calls <code>CPC</code>, <code>ENV</code> is
<code>NIL</code>. <code>CONT</code> is the continuation which will
receive the value of <code>SEXPR</code>. The double-quote
(<code>&quot;</code>) is like a single quote, except that within the quoted
expression any subexpressions preceded by comma (<code>,</code>) are
evaluated and substituted in (also, any subexpressions preceded by
atsign (<code>@</code>) are substituted in a list segments). One special
case handled directly by <code>CPC</code> is a quoted expression;
<code>CPC</code> also expands any SCHEME macros encountered.</p>
<pre><code>(DEFINE CPC-ATOM
        (LAMBDA (SEXPR ENV CONT)
                ((LAMBDA (AT) (IF CONT &quot;(,CONT ,AT) AT))
                 (COND ((NUMBERP SEXPR) SEXPR)
                       ((MEMQ SEXPR ENV) SEXPR)
                       ((GET SEXPR &#39;CPS-NAME ))
                       (T (IMPLODE (CONS &#39;% (EXPLODEN SEXPR))))))))</code></pre>
<p>For convenience, <code>CPC-ATOM</code> will change the name of a
global atom. Numbers and atoms in the environment are not changed;
otherwise, a specified name on the property list of the given atom is
used (properties defined below convert “<code>+</code>” into
“<code>++</code>”, etc.); otherwise, the name is prefixed with
“<code>%</code>”. Once the name has been converted, it is converted to a
form which invokes the continuation on the atom. (If a null continuation
is supplied, the atom itself is returned.)</p>
<pre><code>(DEFINE CPC-LAMBDA
        (LAMBDA (SEXPR ENV CONT)
                ((LAMBDA (CN)
                         ((LAMBDA (LX) (IF CONT &quot;(,COMT, LX) LX))
                          &quot;(LAMBDA (@(CADR SEXPR) ,CN)
                                   ,(CPC (CADDR SEXPR)
                                         (APPEND (CADR SEXPR)
                                                 (CONS CN ENV))
                                         CN))))
                 (GENTEMP &#39;C))))</code></pre>
<p>A <code>LAMBDA</code> expression must have an additional parameter,
the continuation supplied to its body, added to its parameter list.
<code>CN</code> holds the name of this generated parameter. A new
<code>LAMBDA</code> expression is created, with <code>CN</code> added,
and with its body converted in an environment containing the new
variables. Then the same test for a null <code>CONT</code> is made as in
<code>CPC-ATOM</code>.</p>
<pre><code>(DEFINE CPC-IF
    (LAMBDA (SEXPR ENV CONT)
        ((LAMBDA (KN)
             &quot;((LAMBDA (,KN)
                       ,(CPC (CADR SEXPR)
                             ENV
                             ((LAMBDA (PN)
                                  &quot;(LAMBDA (,PN)
                                           (IF ,PN
                                               ,(CPC (CADDR SEXPR)
                                                     ENV
                                                     KN)
                                               ,(CPC (CADDDR SEXPR)
                                                     ENV
                                                     KN))))
                              (GENTEMP &#39;P))))
               ,CONT))
         (GENTEMP &#39;K))))</code></pre>
<p>First, the continuation for an <code>IF</code> must be given a name
<code>KN</code> (rather, the name held in <code>KN</code>; but for
convenience, we will continue to use this ambiguity, for the form of the
name is indeed <code>Kn</code> for some number <code>n</code>), for it
will be referred to in two places and we wish to avoid duplicating the
code. Then, the predicate is converted to continuation-passing style,
using a continuation which will receive the result and call it
<code>PN</code>. This continuation will then use an <code>IF</code> to
decide which converted consequent to invoke. Each consequent is
converted using continuation <code>KN</code>.</p>
<pre><code>(DEFINE CPC-CATCH
        (LAMBDA (SEXPR ENV CONT)
                ((LAMBDA (EN)
                         &quot;((LAMBDA (,EN)
                                   ((LAMBDA (,(CADR SEXPR))
                                            ,(CPC (CADDR SEXPR)
                                                  (CONS (CADR SEXPR) ENV)
                                                  EN))
                                    (LAMBDA (V C) (,EN V))))
                           ,CONT))
                 (GENTEMP &#39;E))))</code></pre>
<p>This routine handles <code>CATCH</code> as defined in <del>[Sussman
75]</del> [<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch8" title="[8] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>], and in converting it to
continuation-passing style eliminates all occurrences of
<code>CATCH</code>. The idea is to give the continuation a name
<code>EN</code>, and to bind the <code>CATCH</code> variable to a
continuation <code>(LAMBDA (V C) ...)</code> which ignores its
continuation and instead exits the catch by calling <code>EN</code> with
its argument <code>V</code>. The body of the <code>CATCH</code> is
converted using continuation <code>EN</code>.</p>
<pre><code>(DEFINE CPC-LABELS
        (LAMBDA (SEXPR ENV CONT)
                (DO ((X (CADR SEXPR) (CDR X))
                     (Y ENV (CONS (CAAR X) Y)))
                    ((NULL X)
                     (DO ((W (CADR SEXPR) (CDR W))
                          (Z NIL (CONS (LIST (CAAR W)
                                             (CPC (CADAR W) Y NIL))
                                       Z)))
                         ((NULL W)
                          &quot;(LABELS ,(REVERSE Z)
                                   ,(CPC (CADDR SEXPR) Y CONT))))))))</code></pre>
<p>Here we have used <code>DO</code> loops as defined in <span class="sc">MacLISP</span> (<code>DO</code> is implemented as a macro in
<span class="sc">SCHEME</span>). There are two passes, one performed by
each <code>DO</code>. The first pass merely collects in <code>Y</code>
the names of all the labelled <code>LAMBDA</code> expressions. The
second pass converts all the <code>LAMBDA</code> expressions using a
null continuation and an environment augmented by all the collected
names in <code>Y</code>, collecting them in <code>Z</code>. At the end,
a new <code>LABELS</code> is constructed using the results in
<code>Z</code> and a converted <code>LABELS</code> body.</p>
<pre><code>(DEFINE CPC-FORM
    (LAMBDA (SEXPR ENV CONT)
        (LABELS ((LOOP1
                    (LAMBDA (X Y Z)
                        (IF (NULL X)
                            (DO ((F (REVERSE (CONS CONT Y))
                                    (IF (NULL (CAR Z)) F
                                        (CPC (CAR Z)
                                             ENV
                                             &quot;(LAMBDA (,(CAR Y) ,F)))))
                                 (Y Y (CDR Y))
                                 (Z Z (CDR Z)))
                                ((NULL Z) F))
                            (COND ((OR (NULL (CAR X))
                                       (ATOM (CAR X)))
                                   (LOOP1 (CDR X)
                                          (CONS (CPC (CAR X) ENV NIL) Y)
                                          (CONS NIL Z)))
                                  ((EQ (CAAR X) &#39;QUOTE)
                                   (LOOP1 (CDR X)
                                          (CONS (CAR X) Y)
                                          (CONS NIL Z)))
                                  ((EQ (CAAR X) &#39;LAMBDA)
                                   (LOOP1 (CDR X)
                                          (CONS (CPC (CAR X) ENV NIL) Y)
                                          (CONS NIL Z)))
                                  (T (LOOP1 (CDR X)
                                            (CONS (GENTEMP &#39;T) Y)
                                            (CONS (CAR X) Z))))))))
                (LOOP1 SEXPR NIL NIL))))</code></pre>
<p>This, the most complicated routine, converts forms (function calls).
This also operates in two passes. The first pass, using
<code>LOOP1</code>, uses <code>X</code> to step down the expression,
collecting data in <code>Y</code> and <code>Z</code>. At each step, if
the next element of <code>X</code> can be evaluated trivially, then it
is converted with a null continuation and added to <code>Y</code>, and
<code>NIL</code> is added to <code>Z</code>. Otherwise, a temporary name
<code>TN</code> for the result of the subexpression is created and put
in <code>Y</code>, and the subexpression itself is put in
<code>Z</code>. On the second pass (the <code>DO</code> loop), the final
continuation-passing form is constructed in <code>F</code> from the
inside out. At each step, if the element of <code>Z</code> is non-null,
a new continuation must be created. (There is actually a bug in
<code>CPC-FORM</code>, which has to do with variables affected by
side-effects. This is easily fixed by changing <code>LOOP1</code> so
that it generates temporaries for variables even though variables
evaluate trivially. This would only obscure the examples presented
below, however, and so this was omitted.)</p>
<pre><code>(LABELS ((BAR
          (LAMBDA (DUMMY X Y)
                  (IF (NULL X) &#39;|CPS ready to go!|
                      (BAR (PUTPROP (CAR X) (CAR Y) &#39;CPS-NAME)
                           (CDR X)
                           (CDR Y))))))
        (BAR NIL
             &#39;(+  -  *  //   ^  T  NIL)
             &#39;(++ -- ** //// ^^ &#39;T &#39;NIL)))</code></pre>
<p>This loop sets up some properties so that “<code>+</code>” will
translate into “<code>++</code>” instead of “<code>%+</code>”, etc.</p>
<p>Now let us examine some examples of the action of <code>CPS</code>.
First, let us try our old friend <code>FACT</code>, the iterative
factorial program.</p>
<pre><code>(DEFINE FACT
        (LAMBDA (N)
                (LABELS ((FACT1 (LAMBDA (M A)
                                        (IF (= M 0) A
                                            (FACT1 (- M 1) (* M A))))))
                        (FACT1 N 1))))</code></pre>
<p>Applying <code>CPS</code> to the <code>LAMBDA</code> expression for
<code>FACT</code> yields:</p>
<pre><code>(#CONT#
    (LAMBDA (N C7)
        (LABELS ((FACT1
            (LAMBDA (M A C10)
                ((LAMBDA (K11)
                    (%= M 0
                        (LAMBDA (P12)
                            (IF P12 (K11 A)
                                (-- M 1
                                    (LAMBDA (T13)
                                        (** M A
                                            (LAMBDA (T14)
                                                (FACT1 T13 T14 K11)
                                                ))))))))
                     C10))))
                 (FACT1 N 1 C7))))</code></pre>
<p>As an example of <code>CATCH</code> elimination, here is a routine
which is a paraphrase of the <code>SQRT</code> routine from
<del>[Sussman 75]</del> [<a href="#scheme-1-2-3-4-5-6-7-8-9" id="xsch9" title="[9] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus"><span class="sc">SCHEME</span></a>]:</p>
<pre><code>(DEFINE SQRT
        (LAMBDA (X EPS)
                ((LAMBDA (ANS LOOPTAG)
                         (CATCH RETURNTAG
                                (BLOCK (ASET&#39; LOOPTAG (CATCH M M))
                                       (IF ---
                                           (RETURNTAG ANS)
                                           NIL)
                                       (ASET&#39; ANS ===)
                                       (LOOPTAG LOOPTAG))))
                 1.0
                 NIL)))</code></pre>
<p>Here we have used “<code>---</code>” and “<code>===</code>” as
ellipses for complicated (and relatively uninteresting) arithmetic
expressions. Applying <code>CPS</code> to the <code>LAMBDA</code>
expression for <code>SQRT</code> yields:</p>
<pre><code>(#CONT#
 (LAMBDA (X EPS C33)
     ((LAMBDA (ANS LOOPTAG C34)
          ((LAMBDA (E35)
               ((LAMBDA (RETURNTAG)
                    ((LAMBDA (E52)
                         ((LAMBDA (M) (E52 M))
                          (LAMBDA (V C) (E52 V))))
                     (LAMBDA (T51)
                             (%ASET&#39; LOOPTAG T51
                                (LAMBDA (T37)
                                  ((LAMBDA (A B C36) (B C36))
                                   T37
                                   (LAMBDA (C40)
                                       ((LAMBDA (K47)
                                          ((LAMBDA (P50)
                                               (IF P50
                                                   (RETURNTAG ANS K47)
                                                   (K47 &#39;NIL)))
                                           %---))
                                        (LAMBDA (T42)
                                            ((LAMBDA (A B C41) (B C41))
                                             T42
                                             (LAMBDA (C43)
                                                 (%ASET&#39; ANS %===
                                                    (LAMBDA (T45)
                                                       ((LAMBDA (A B C44)
                                                                (B C44))
                                                        T45
                                                        (LAMBDA (C46)
                                                           (LOOPTAG
                                                            LOOPTAG
                                                            C46))
                                                        C43))))
                                             C40))))
                                    E35))))))
                (LAMBDA (V C) (E35 V))))
           C34))
      1.0
      &#39;NIL
      C33)))</code></pre>
<p>Note that the <code>CATCH</code>es have both been eliminated. It is
left as an exercise for the reader to verify that the
continuation-passing version correctly reflects the semantics of the
original.</p>
</section>
<section id="note-operations-on-functions" class="level4">
<h4>{Note Operations on Functions} <span class="fr"><a href="#xoperations-on-functions">^</a></span><br />
</h4>
<p>It would certainly be possible to define other operations on
functions, such as determining the number of arguments required, or the
types of the arguments and returned value, etc. (Indeed, after the
dissertation was written, it was decided to include such an operator
<code>PROCP</code> in [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr8" title="[8] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>].) The point is that functions need not conform to a specific
representation such as S-expressions. At a low level, it may be useful
to think of invocation as a generic operator which dispatches on the
particular representation and invokes the function in an appropriate
manner. Similarly, a debugging package might need to be able to
distinguish the various representations. At the user level, however, it
is perhaps best to hide this issue, and answer a type inquiry with
merely “function”.</p>
</section>
<section id="note-refinement-of-rabbit" class="level4">
<h4>{Note Refinement of <span class="sc">RABBIT</span>} <span class="fr"><a href="#xrefinement-of-rabbit">^</a></span><br />
</h4>
<p>Since the original dissertation was written I have continued to
refine and improve <span class="sc">RABBIT</span>. This effort has
included a complete rewriting of the optimizer to make it more
efficienct and at the same time more lucid. It also included
accommodation of changes to <span class="sc">SCHEME</span> as documented
in [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr9" title="[9] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>]. This work has spanned perhaps eight months’ time, because
the availability of computer time restricted me to testing <span class="sc">RABBIT</span> only once or twice a night. Thus, the actual
time expended for the improvements was much less than ten hours a
week.</p>
</section>
<section id="note-side-effect-classifications" class="level4">
<h4>{Note Side-Effect Classifications} <span class="fr"><a href="#xside-effect-classifications">^</a></span><br />
</h4>
<p>The division of side-effects into classes in <span class="sc">RABBIT</span> was not really necessary to the primary goals
of <span class="sc">RABBIT</span>, but was undertaken as an interesting
experiment for our own edification. One could easily imagine a more
complex taxonomy. A case of particular interest not handled by <span class="sc">RABBIT</span> is dividing the <code>ASET</code> side-effect
into <code>ASET</code> of each particular variable; thus an
<code>ASET</code> on <code>FOO</code> would not affect a reference to
the variable <code>BAR</code>. This could have been done in an ad hoc
manner, but we are interested in a more general method dealing only with
sets of effects and affectabilities.</p>
</section>
<section id="note-subroutinization" class="level4">
<h4>{Note Subroutinization} <span class="fr"><a href="#xsubroutinization">^</a></span><br />
</h4>
<p>We have not said anything about how to locate candidate expressions
for subroutinization. For examples of appropriate strategies, see [<a href="#geschke-1-2" id="xgeschke2" title="[2] Geschke 1972, Global program optimizations">Geschke</a>] and
[<a href="#aho-johnson-and-ullman" id="xaho-johnson-and-ullman" title="[1] Aho, Johnson, and Ullman 1977, Code Generation for Expressions with Common Subexpressions">Aho,
Johnson, and Ullman</a>]. Our point here is that <span class="sc">SCHEME</span>, thanks to the property of lexical scoping and
the ability to write “anonymous” functions as
<code>LAMBDA</code>-expressions, provides an ideal way to represent the
result of such transformations.</p>
</section>
<section id="note-tail-recursive-or" class="level4">
<h4>{Note Tail-Recursive <code>OR</code>} <span class="fr"><a href="#xtail-recursive-or">^</a></span><br />
</h4>
<p>Since the dissertation was written, the <span class="sc">SCHEME</span> language was redefined in [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr10" title="[10] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>] to prescribe a “tail-recursive” interpretation for the last
form in an <code>AND</code> or <code>OR</code>. This requirement
necessitated a redefinition of <code>OR</code> which is in fact dual to
the definition of <code>AND</code>.</p>
<p><hr></p>
</section>
</section>
</section>
<section id="references" class="level2">
<h2><a href="#contents">References</a></h2>
<section id="section-1" class="level3">
<h3></h3>
<section id="aho-johnson-and-ullman" class="level4">
<h4>[Aho, Johnson, and Ullman] <span class="fr"><a href="#xaho-johnson-and-ullman">^</a></span><br />
</h4>
<p>Aho, A.V., Johnson, S.C., and Ullman, J.D. <a href="https://dl.acm.org/doi/abs/10.1145/800168.811537" title="dl.acm.org/doi/abs/10.1145/800168.811537"><em>Code Generation for
Expressions with Common Subexpressions</em></a>. J. ACM 24, 1 (January
1977), 146-160.</p>
</section>
<section id="allen-and-cocke-1-2-3-4-5" class="level4">
<h4>[Allen and Cocke] <span class="fr"><a href="#xaac1">1</a>, <a href="#xaac2">2</a>, <a href="#xaac3">3</a>, <a href="#xaac4">4</a>, <a href="#xaac5">5</a></span><br />
</h4>
<p>Allen, Frances E., and Cocke, John. <a href="https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf" title="www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf"><em>A
Catalogue of Optimizing Transformations</em></a>. In Rustin, Randall
(ed.), Design and Optimization of Compilers. Proc. Courant Comp. Sci.
Symp. 5. Prentice-Hall (Englewood Cliffs, N.J., 1972).</p>
</section>
<section id="bobrow-and-wegbreit" class="level4">
<h4>[Bobrow and Wegbreit] <span class="fr"><a href="#xbobrow-and-wegbreit">^</a></span><br />
</h4>
<p>Bobrow, Daniel G. and Wegbreit, Ben. <a href="https://dl.acm.org/doi/10.1145/362375.362379" title="dl.acm.org/doi/10.1145/362375.362379"><em>A Model and Stack
Implementation of Multiple Environments</em></a>. CACM 16, 10 (October
1973) pp. 591-603.</p>
</section>
<section id="carter-1-2" class="level4">
<h4>[Carter] <span class="fr"><a href="#xcarter1">1</a>, <a href="#xcarter2">2</a></span><br />
</h4>
<p>Carter, J. Lawrence. <a href="https://dl.acm.org/doi/abs/10.1145/359897.359902" title="dl.acm.org/doi/abs/10.1145/359897.359902"><em>A Case Study of a
New Code Generation Technique for Compilers</em></a>. Comm. ACM 20, 12
(December 1977), 914-920.</p>
</section>
<section id="church-1-2" class="level4">
<h4>[Church] <span class="fr"><a href="#xchurch1">1</a>, <a href="#xchurch2">2</a></span><br />
</h4>
<p>Church, Alonzo. <a href="https://archive.org/details/AnnalsOfMathematicalStudies6ChurchAlonzoTheCalculiOfLambdaConversionPrincetonUniversityPress1941" title="archive.org/details/AnnalsOfMathematicalStudies6ChurchAlonzoTheCalculiOfLambdaConversionPrincetonUniversityPress1941"><em>The
Calculi of Lambda Conversion</em></a>. Annals of Mathematics Studies
Number 6. Princeton University Press (Princeton, 1941). Reprinted by
Klaus Reprint Corp. (New York, 1965).</p>
</section>
<section id="coleman" class="level4">
<h4>[Coleman] <span class="fr"><a href="#xcoleman">^</a></span><br />
</h4>
<p>Coleman, Samuel S. <a href="https://.invalid/_no_online_copy_found_" title="No online copy found"><em>JANUS: A Universal Intermediate
Language</em></a>, PhD thesis, University of Colorado, 1974.<br />
{{see Coleman etal 1974 <a href="https://onlinelibrary.wiley.com/doi/10.1002/spe.4380040103" title="onlinelibrary.wiley.com/doi/10.1002/spe.4380040103"><em>The
mobile programming system, Janus</em></a> }}</p>
</section>
<section id="dec" class="level4">
<h4>[DEC] <span class="fr"><a href="#xdec">^</a></span><br />
</h4>
<p>Digital Equipment Corporation. <a href="http://www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-10-NRZC-D%20decsystem-10%20Assemblly%20Language%20Handbook.pdf" title="www.bitsavers.org/www.computer.museum.uq.edu.au/pdf/DEC-10-NRZC-D%20decsystem-10%20Assemblly%20Language%20Handbook.pdf"><em>DecSystem
10 Assembly Language Handbook</em></a> (third edition). (Maynard, Mass.,
1973).</p>
</section>
<section id="declarative-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19" class="level4">
<h4>[Declarative] <span class="fr"><a href="#xd1">1</a>, <a href="#xd2">2</a>, <a href="#xd3">3</a>, <a href="#xd4">4</a>, <a href="#xd5">5</a>, <a href="#xd6">6</a>, <a href="#xd7">7</a>, <a href="#xd8">8</a>, <a href="#xd9">9</a>, <a href="#xd10">10</a>, <a href="#xd11">11</a>, <a href="#xd12">12</a>, <a href="#xd13">13</a>, <a href="#xd14">14</a>, <a href="#xd15">15</a>, <a href="#xd16">16</a>, <a href="#xd17">17</a>, <a href="#xd18">18</a>, <a href="#xd19">19</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr. <a href="https://dspace.mit.edu/handle/1721.1/6091" title="dspace.mit.edu/handle/1721.1/6091"><em>LAMBDA: The Ultimate
Declarative</em></a>. AI Memo 379. MIT AI Lab (Cambridge, November
1976).<br />
{{HTML transcription: <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</section>
<section id="dijkstra-1-2" class="level4">
<h4>[Dijkstra] <span class="fr"><a href="#xdijkstra1">1</a>, <a href="#xdijkstra2">2</a></span><br />
</h4>
<p>Dijkstra, Edsger W. <a href="https://archive.org/details/disciplineofprog0000dijk" title="archive.org/details/disciplineofprog0000dijk"><em>A Discipline of
Programming</em></a>. Prentice-Hall (Englewood Cliffs, N.J., 1976)</p>
</section>
<section id="doyle-1-2" class="level4">
<h4>[Doyle] <span class="fr"><a href="#xdoyle1">1</a>, <a href="#xdoyle2">2</a></span><br />
</h4>
<p>Doyle, Jon, de Kleer, Johan, Sussman, Gerald Jay, and Steele, Guy L.
Jr. <a href="https://.invalid/_no_online_copy_found_/" title="No online copy found"><em>AMORD: A Dependency-Based
Problem-Solving Language</em></a>. Submitted to the 1977 SIGART/SIGPLAN
Artificial Intelligence and Programming Languages Conference.</p>
<div class="ti">
<p>{{See <a href="https://dl.acm.org/doi/pdf/10.1145/872734.806940" title="dl.acm.org/doi/pdf/10.1145/872734.806940"><em>AMORD: Explicit
Control of Reasoning</em></a>, Proc. AI and Programming Languages Conf.,
SIGPLAN Notices 12, 8, SIGART Newsletter 64, 1977. }}</p>
</div>
</section>
<section id="geschke-1-2" class="level4 npb">
<h4>[Geschke] <span class="fr"><a href="#xgeschke1">1</a>, <a href="#xgeschke2">2</a></span><br />
</h4>
<p>Geschke, Charles M. <a href="https://www.proquest.com/openview/257cdb472f7f80955f5e5be70cb1f2f6/1.pdf" title="www.proquest.com/openview/257cdb472f7f80955f5e5be70cb1f2f6/1.pdf"><em>Global
program optimizations</em></a>, PhD thesis. Carnegie-Mellon University
(Pittsburgh, October 1972).</p>
</section>
<section id="gries" class="level4">
<h4>[Gries] <span class="fr"><a href="#xgries">^</a></span><br />
</h4>
<p>Gries, David <a href="https://archive.org/details/compilerconstruc0000grie" title="archive.org/details/compilerconstruc0000grie (Table of Contents only)"><em>Compiler
Construction for Digital Computers</em></a>, John Wiley &amp; Sons (New
York, 1971), 252-257.</p>
</section>
<section id="hewitt" class="level4">
<h4>[Hewitt] <span class="fr"><a href="#xhewitt">^</a></span><br />
</h4>
<p>Hewitt, Carl. <a href="https://doi.org/10.1016/0004-3702(77)90033-9" title="doi.org/10.1016/0004-3702(77)90033-9"><em>Viewing Control
Structures as Patterns of Passing Messages</em></a> AI Journal 8, 3
(June 1977), 323-364.</p>
</section>
<section id="hewitt-and-smith" class="level4">
<h4>[Hewitt and Smith] <span class="fr"><a href="#xhewitt-and-smith">^</a></span><br />
</h4>
<p>Hewitt, Carl, and Smith, Brian. <a href="https://dl.acm.org/doi/abs/10.1109/TSE.1975.6312818" title="dl.acm.org/doi/abs/10.1109/TSE.1975.6312818"><em>Towards a
Programming Apprentice</em></a>. IEEE Transactions on Software
Engineering SE-1, 1 (March 1975), 26-45.</p>
</section>
<section id="imperative-1-2-3-4-5-6-7-8-9-10-11" class="level4">
<h4>[Imperative] <span class="fr"><a href="#ximp1">1</a>, <a href="#ximp2">2</a>, <a href="#ximp3">3</a>, <a href="#ximp4">4</a>, <a href="#ximp5">5</a>, <a href="#ximp6">6</a>, <a href="#ximp7">7</a>, <a href="#ximp8">8</a>, <a href="#ximp9">9</a>, <a href="#ximp10">10</a>,
<a href="#ximp11">11</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr., and Sussman, Gerald Jay. <a href="https://dspace.mit.edu/handle/1721.1/5790" title="dspace.mit.edu/handle/1721.1/5790"><em>LAMBDA: The Ultimate
Imperative</em></a>. AI Memo 353. MIT AI Lab (Cambridge, March
1976).<br />
{{HTML transcription: <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</section>
<section id="johnsson-1-2" class="level4">
<h4>[Johnsson] <span class="fr"><a href="#xjohnsson1">1</a>, <a href="#xjohnsson2">2</a></span><br />
</h4>
<p>Johnsson, Richard Karl. <a href="https://dl.acm.org/doi/10.5555/908056" title="dl.acm.org/doi/10.5555/908056"><em>An Approach to Global Register
Allocation</em></a> Ph.D. Thesis. Carnegie-Mellon University
(Pittsburgh, December 1975).</p>
</section>
<section id="landin" class="level4">
<h4>[Landin] <span class="fr"><a href="#xlandin">^</a></span><br />
</h4>
<p>Landin, Peter J. <a href="https://dl.acm.org/doi/10.1145/363744.363749" title="dl.acm.org/doi/10.1145/363744.363749"><em>A Correspondence
between ALGOL 60 and Church’s Lambda-Notation</em></a>. CACM 8, 2-3 (<a href="https://dl.acm.org/doi/10.1145/363744.363749" title="dl.acm.org/doi/10.1145/363744.363749">February</a> and <a href="https://dl.acm.org/doi/10.1145/363791.363804" title="dl.acm.org/doi/10.1145/363791.363804">March</a> 1965).</p>
</section>
<section id="lisp1.5m" class="level4">
<h4>[LISP1.5M] <span class="fr"><a href="#xlisp1.5m">^</a></span><br />
</h4>
<p>McCarthy, John, et al. <a href="https://apps.dtic.mil/sti/tr/pdf/AD0406138.pdf" title="apps.dtic.mil/sti/tr/pdf/AD0406138.pdf"><em>LISP 1.5 Programmer’s
Manual</em></a>. The MIT Press (Cambridge, 1962).</p>
<div class="ti">
<p>{{See also McCarthy et al <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf" title="www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf"><em>LISP
1.5 Programmer’s Manual</em></a> [Second edition] The MIT Press
(Cambridge, 1965). }}</p>
</div>
</section>
<section id="mckeeman" class="level4">
<h4>[McKeeman] <span class="fr"><a href="#xmckeeman">^</a></span><br />
</h4>
<p>McKeeman, W.M. <a href="https://dl.acm.org/doi/10.1145/364995.365000" title="dl.acm.org/doi/10.1145/364995.365000"><em>Peephole
optimization</em></a>. Comm. ACM 8, 7 (July 1965), 443-444.</p>
</section>
<section id="moon-1-2-3-4-5" class="level4">
<h4>[Moon] <span class="fr"><a href="#xmoon1">1</a>, <a href="#xmoon2">2</a>, <a href="#xmoon3">3</a>, <a href="#xmoon4">4</a>,
<a href="#xmoon5">5</a></span><br />
</h4>
<p>Moon, David A. <a href="https://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf" title="www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf"><em>MACLISP
Reference Manual, Revision 0</em></a>. Project MAC, MIT (Cambridge,
April 1974).</p>
</section>
<section id="moses-1-2" class="level4">
<h4>[Moses] <span class="fr"><a href="#xmoses1">1</a>, <a href="#xmoses2">2</a></span><br />
</h4>
<p>Moses, Joel. <a href="https://dspace.mit.edu/handle/1721.1/5854" title="dspace.mit.edu/handle/1721.1/5854"><em>The Function of FUNCTION
in LISP</em></a>. AI Memo 199, MIT AI Lab (Cambridge, June 1970).</p>
</section>
<section id="pratt" class="level4">
<h4>[Pratt] <span class="fr"><a href="#xpratt">^</a></span><br />
</h4>
<p>Pratt, Vaughan R. <a href="https://dspace.mit.edu/handle/1721.1/41951" title="dspace.mit.edu/handle/1721.1/41951"><em>CGOL - An Alternative
External Representation for LISP Users</em></a>. AI Working Paper 121.
MIT AI Lab (Cambridge, March 1976).</p>
</section>
<section id="revised-report-1-2-3-4-5-6-7-8-9-10-11-12" class="level4 npb">
<h4>[Revised Report] <span class="fr"><a href="#xrr1">1</a>, <a href="#xrr2">2</a>, <a href="#xrr3">3</a>, <a href="#xrr4">4</a>, <a href="#xrr5">5</a>, <a href="#xrr6">6</a>, <a href="#xrr7">7</a>, <a href="#xrr8">8</a>, <a href="#xrr9">9</a>, <a href="#xrr10">10</a>, <a href="#xrr11">11</a>, <a href="#xrr12">12</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr., and Sussman, Gerald Jay. <a href="https://dspace.mit.edu/handle/1721.1/6283" title="dspace.mit.edu/handle/1721.1/6283"><em>The Revised Report on
SCHEME</em></a>. MIT AI Memo 452 (Cambridge, January 1978).<br />
{{HTML transcription: <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</section>
<section id="reynolds" class="level4">
<h4>[Reynolds] <span class="fr"><a href="#xreynolds">^</a></span><br />
</h4>
<p>Reynolds, John C. <a href="https://dl.acm.org/doi/10.1145/800194.805852" title="dl.acm.org/doi/10.1145/800194.805852"><em>Definitional
Interpreters for Higher Order Programming Languages</em></a>. ACM
Conference Proceedings 1972.</p>
</section>
<section id="sammet" class="level4">
<h4>[Sammet] <span class="fr"><a href="#xsammet">^</a></span><br />
</h4>
<p>Sammet, Jean E. <a href="https://archive.org/details/programminglangu00unse" title="archive.org/details/programminglangu00unse"><em>Programming
Languages: History and Fundamentals</em></a>, Prentice-Hall (Englewood
Cliffs, N.J., 1969).</p>
</section>
<section id="scheme-1-2-3-4-5-6-7-8-9" class="level4">
<h4>[<span class="sc">SCHEME</span>] <span class="fr"><a href="#xsch1">1</a>, <a href="#xsch2">2</a>, <a href="#xsch3">3</a>, <a href="#xsch4">4</a>, <a href="#xsch5">5</a>, <a href="#xsch6">6</a>, <a href="#xsch7">7</a>, <a href="#xsch8">8</a>, <a href="#xsch9">9</a></span><br />
</h4>
<p>Sussman, Gerald Jay, and Steele, Guy L. Jr. <a href="https://dspace.mit.edu/handle/1721.1/5794" title="dspace.mit.edu/handle/1721.1/5794"><em>SCHEME: An Interpreter for
Extended Lambda Calculus</em></a>. AI Memo 349. MIT AI Lab (Cambridge,
December 1975).</p>
<div class="ti">
<p>{{HTML transcription: <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a><br />
Republished with notes as<br />
Sussman, G.J., Steele, G.L. <a href="https://www.researchgate.net/publication/227098423_Scheme_A_Interpreter_for_Extended_Lambda_Calculus" title="www.researchgate.net/publication/227098423_Scheme_A_Interpreter_for_Extended_Lambda_Calculus"><em>Scheme:
A Interpreter for Extended Lambda Calculus</em></a>. Higher-Order and
Symbolic Computation 11, 405–439 (1998).
https://doi.org/10.1023/A:1010035624696<br />
See also: Sussman, G.J., Steele, G.L. <a href="https://doi.org/10.1023/A:1010079421970" title="doi.org/10.1023/A:1010079421970"><em>The First Report on Scheme
Revisited</em></a>. Higher-Order and Symbolic Computation 11, 399–404
(1998). https://doi.org/10.1023/A:1010079421970 }}</p>
</div>
</section>
<section id="smith-and-hewitt-1-2" class="level4">
<h4>[Smith and Hewitt] <span class="fr"><a href="#xsmith1">1</a>, <a href="#xsmith2">2</a></span><br />
</h4>
<p>Smith, Brian C. and Hewitt, Carl. <a href="https://www.scribd.com/document/185900689/A-Plasma-Primer" title="www.scribd.com/document/185900689/A-Plasma-Primer"><em>A PLASMA
Primer (draft)</em></a>. MIT AI Lab (Cambridge, October 1975).</p>
</section>
<section id="standish-1-2-3" class="level4">
<h4>[Standish] <span class="fr"><a href="#xstandish1">1</a>, <a href="#xstandish2">2</a>, <a href="#xstandish3">3</a></span><br />
</h4>
<p>Standish, T. A. etal. <a href="https://escholarship.org/uc/item/79p8s9qv" title="escholarship.org/uc/item/79p8s9qv"><em>The Irvine Program
Transformation Catalogue</em></a>, University of California (Irvine,
January 1976).</p>
</section>
<section id="steele-1-2-3-4-5" class="level4">
<h4>[Steele] <span class="fr"><a href="#xste1">1</a>, <a href="#xste2">2</a>, <a href="#xste3">3</a>, <a href="#xste4">4</a>, <a href="#xste5">5</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr. <a href="https://dl.acm.org/doi/abs/10.1145/800179.810196" title="dl.acm.org/doi/abs/10.1145/800179.810196"><em>Debunking the
‘Expensive Procedure Call’ Myth</em></a>. Proc. ACM National Conference
(Seattle, October 1977),153-162.</p>
<div class="ti">
<p>{{Revised as <a href="https://dspace.mit.edu/handle/1721.1/5753" title="dspace.mit.edu/handle/1721.1/5753"><em>Debunking the ‘Expensive
Procedure Call’ Myth, or, Procedure Call Implementations Considered
Harmful, or, Lambda: The Ultimate GOTO</em></a> MIT AI Memo 443,
(Cambridge, October 1977).<br />
HTML transcription: <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</div>
</section>
<section id="stoy" class="level4">
<h4>[Stoy] <span class="fr"><a href="#xstoy">^</a></span><br />
</h4>
<p>Stoy, Joseph E. <a href="https://archive.org/details/denotationalsema0000jose" title="archive.org/details/denotationalsema0000jose"><em>Denotational
Semantics: The Scott-Strachey Approach to Programming Language
Theory</em></a>. MIT Press (Cambridge, 1977).</p>
</section>
<section id="teitelman-1-2" class="level4">
<h4>[Teitelman] <span class="fr"><a href="#xteitelman1">1</a>, <a href="#xteitelman2">2</a></span><br />
</h4>
<p>Teitelman, Warren. <a href="https://.invalid/_no_online_copy_found_/" title="No online copy found"><em>InterLISP Reference Manual. Revised
edition</em></a>. Xerox Palo Alto Research Center (Palo Alto,
1975).<br />
{{see <a href="https://www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_Oct_1974.pdf" title="www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_Oct_1974.pdf"><em>InterLISP
Reference Manual</em></a> (October 1974) }}</p>
</section>
<section id="wand-and-friedman-1-2-3" class="level4 npb">
<h4>[Wand and Friedman] <span class="fr"><a href="#xwand1">1</a>, <a href="#xwand2">2</a>, <a href="#xwand3">3</a></span><br />
</h4>
<p>Wand, Mitchell and Friedman, Daniel P. <a href="https://legacy.cs.indiana.edu/ftp/techreports/TR55.pdf" title="legacy.cs.indiana.edu/ftp/techreports/TR55.pdf"><em>Compiling
Lambda Expressions Using Continuations</em></a>, Technical Report 55,
Indiana University (Bloomington, October 1976).</p>
</section>
<section id="wulf-1-2-3-4" class="level4">
<h4>[Wulf] <span class="fr"><a href="#xwulf1">1</a>, <a href="#xwulf2">2</a>, <a href="#xwulf3">3</a>, <a href="#xwulf4">4</a></span><br />
</h4>
<p>Wulf, William A., et al. <a href="https://apps.dtic.mil/sti/citations/AD0773838" title="apps.dtic.mil/sti/citations/AD0773838"><em>The Design of an
Optimizing Compiler</em></a>. American Elsevier (New York, 1975).</p>
<p><hr></p>
</section>
</section>
</section>
<section id="appendix" class="level2">
<h2><a href="#contents">Appendix</a></h2>
<p>We present here the complete working source code for <span class="sc">RABBIT</span>, written in <span class="sc">SCHEME</span>.
(The listing of the code was produced by the “@” listing generator,
written by Richard M. Stallman, Guy L. Steele Jr., and other
contributors.)</p>
<p>The code is presented on successive odd-numbered pages. Commentary on
the code is on the facing even-numbered page. An index appears at the
end of the. listing, indicating where each function is defined.</p>
<div class="small">
<p>{{Source code file: <a href="https://files.scheme.org/rabbit.lsp" title="files.scheme.org/rabbit.lsp"><strong>files.scheme.org/rabbit.lsp</strong></a>;
code pages and index not included in this document. }}</p>
</div>
<p>It should be emphasized that <span class="sc">RABBIT</span> was not
written with efficiency as a particular goal. Rather, the uppermost
goals were clarity, ease of debugging, and adaptability to changing
algorithms during the development process Much information is generated,
never used by the compilation process, and then thrown away, simply so
that if some malfunction should occur it would be easier to conduct a
post-mortem analysis. Information that is used for compilation is often
retained longer than necessary. The overall approach is to create a big
data structure and then, step by step, fill in slots, never throwing
anything away, even though it may no longer be needed.</p>
<p>The algorithms could be increased in speed, particularly the
optimizer, which often recomputes information needlessly. Determining
whether or not the recomputation was necessary would have cluttered up
the algorithms, however, making them harder to read and to modify, and
so this was omitted. Similarly, certain improvements could dramatically
decrease the space used. The larger functions in <span class="sc">RABBIT</span> can just barely be compiled with a memory size
of 256K words on a <span class="sc">PDP-10</span>. However, it was
deemed worthwhile to keep the extra information available for as long a
time as possible.</p>
<p>The implementation of <span class="sc">RABBIT</span> has taken
perhaps three man-months. This includes throwing away the original
optimizer and rewriting it completely, and accomodating certain changes
to the <span class="sc">SCHEME</span> language as they occurred. <span class="sc">RABBIT</span> was operational, without the optimizer, after
about one man-month’s work. The dissertation was written after the first
version of the optimizer was demonstrated to work. The remaining time
was spent analyzing the faults of the first optimizer, writing the
second version, accomodating language changes, making performance
measurements, and testing <span class="sc">RABBIT</span> on programs
other than <span class="sc">RABBIT</span> itself.</p>
<p><hr></p>
<p><span id="outline">The main modules of <span class="sc">RABBIT</span>
are organized something like this:</span></p>
<div class="line-block"><a href="#comfile1"><code>COMFILE</code></a>, <a href="#transduce1"><code>TRANSDUCE</code></a>, <a href="#process-form1"><code>PROCESS-FORM</code></a><code>   (Bookkeeping and file handling)</code><br />
    <a href="#compile1"><code>COMPILE</code></a><code>                           (Compile a function definition)</code><br />
       <a href="#alphatize1"><code>ALPHATIZE</code></a><code>                          (Convert input, rename variables)</code><br />
           <a href="#macro-expand1"><code>MACRO-EXPAND</code></a><code>                        (Expand macro forms)</code><br />
       <a href="#meta-evaluate1"><code>META-EVALUATE</code></a><code>                      (Source-to-source optimizations)</code><br />
           <a href="#pass1-analyze1"><code>PASS1-ANALYZE</code></a><code>                       (Preliminary code analysis)</code><br />
               <a href="#env-analyze1"><code>ENV-ANALYZE</code></a><code>                          (Environment analysis)</code><br />
               <a href="#triv-analyze1"><code>TRIV-ANALYZE</code></a><code>                         (Triviality analysis)</code><br />
               <a href="#effs-analyze1"><code>EFFS-ANALYZE</code></a><code>                         (Side effects analysis)</code><br />
           <a href="#meta-if-fudge1"><code>META-IF-FUDGE</code></a><code>                       (Transform nested IF expressions)</code><br />
           <a href="#meta-combination-trivfn1"><code>META-COMBINATION-TRIVFN</code></a><code>             (Constants folding)</code><br />
           <a href="#meta-combination-lambda1"><code>META-COMBINATION-LAMBDA</code></a><code>             (Beta-conversion)</code><br />
               <a href="#subst-candidate1"><code>SUBST-CANDIDATE</code></a><code>                     (Substitution feasibility)</code><br />
               <a href="#meta-substitute1"><code>META-SUBSTITUTE</code></a><code>                     (Substitution, subsumption)</code><br />
       <a href="#convert1"><code>CONVERT</code></a><code>                           (Convert to continuation-passing style)</code><br />
       <a href="#cenv-analyze1"><code>CENV-ANALYZE</code></a><code>                      (Environment analysis)</code><br />
       <a href="#bind-analyze1"><code>BIND-ANALYZE</code></a><code>                      (Bindings analysis)</code><br />
       <a href="#depth-analyze1"><code>DEPTH-ANALYZE</code></a><code>                     (Register allocation)</code><br />
       <a href="#close-analyze1"><code>CLOSE-ANALYZE</code></a><code>                     (Environment structure design)</code><br />
       <a href="#compilate-one-function1"><code>COMPILATE-ONE-FUNCTION</code></a><code>            (Generate code, producing one module)</code><br />
           <a href="#compilate1"><code>COMPILATE</code></a><code>                          (Generate code for one subroutine)</code><br />
               <a href="#comp-body1"><code>COMP-BODY</code></a><code>                           (Compile procedure body)</code><br />
               <a href="#analyze1"><code>ANALYZE</code></a><code>                             (Generate value-producing code)</code><br />
               <del><code>TRIV-ANALYZE</code></del> <a href="#trivialize1"><code>TRIVIALIZE</code></a><code>              (Generate &quot;trivial&quot; code)</code></div>
<p><br />
</p>
<div class="ti small">
<p>{{Function names above link to commentary on definition, then to
other uses in commentary.<br />
Note that this is not the order of functions in the source code. }}</p>
</div>
<p><hr></p>
<div class="ti small">
<p>{{Compiler source code (odd-numbered pages in original) not included,
see <a href="https://files.scheme.org/rabbit.lsp" title="files.scheme.org/rabbit.lsp"><strong>rabbit.lsp</strong></a>;<br />
page numbers in following headings refer to original code listing;
headings link to module outline above. }}</p>
</div>
<section id="rabbit-568-051578-page-1" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 1</a></h4>
<p>The <code>DECLARE</code> forms are for the benefit of the <span class="sc">MacLISP</span> compiler, which will process the result of
compiling this file (i.e. <span class="sc">RABBIT</span> compiling
itself). The first few forms are concerned with switch settings,
allocation of memory within the <span class="sc">MacLISP</span>
compiler, and loading of auxiliary functions which must be available at
compile time.</p>
<p>The large block of <code>SPECIAL</code> declarations contains the
name of every <span class="sc">SCHEME</span> function in the file. This
is necessary because the run-time representation of a global variable is
as a <span class="sc">MacLISP</span> <code>SPECIAL</code> variable. The
compiled function objects will reside in <span class="sc">MacLISP</span>
value cells, and <span class="sc">SCHEME</span> functions refer to each
other through these cells.</p>
<p>The second set of <code>SPECIAL</code> declarations (variables whose
names begin and end with a “<code>*</code>”) specify variables used
globally by <span class="sc">RABBIT</span>. These fall into three
categories: variables containing properties of the <span class="sc">SCHEME</span> interpreter which are parameters for the
compiler (e.g. <code>**ARGUMENT-REGISTERS**</code>); switches, primarily
for debugging purposes, used to control certain compiler operations
(e.g. <code>*FUDGE*</code>); and own variables for certain functions,
used to generate objects or gather statistics
(e.g. <code>*GENTEMPNUM*</code> and
<code>*DEPROGNIFY-COUNT*</code>).</p>
<p>The <code>PROCLAIM</code> forms are to <span class="sc">RABBIT</span>
as <code>DECLARE</code> forms are to the <span class="sc">MacLISP</span>
compiler. These provide declarations to the incarnation of <span class="sc">RABBIT</span> which is compiling the file. The subforms of a
<code>PROCLAIM</code> form are executed by <span class="sc">RABBIT</span> when it encounters the form in a file being
compiled. (We will see later how this is done.)</p>
</section>
<section id="rabbit-568-051578-page-2" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 2</a></h4>
<p>The variable <code>*EMPTY*</code> is initialized to a unique object
(a list cell whose car is <code>*EMPTY*</code> – this is so that no
other object can be <code>EQ</code> to it, but it can be easily
recognized when printed) which is used to initialize components of
structures. (We will see later how such structures are defined.) We do
not use, say, <code>NIL</code> to represent an empty component because
<code>NIL</code> might be a meaningful value for that component. The
predicate <code>EMPTY</code> is true of the unique object.</p>
<p><code>TRIVFN</code> is a predicate which is true of “trivial”
functions. A function is trivial if it is a <span class="sc">MacLISP</span> primitive (an <code>EXPR</code>,
<code>SUBR</code>, or <code>LSUBR</code>), or has been declared to be
primitive via a <code>*EXPR</code> or <code>*LEXPR</code>
proclamation.</p>
<pre><code>  (INCREMENT FOO) expands into the code (ASET&#39; FOO (+ FOO 1)).</code></pre>
<p><code>CATENATE</code> is a utility macro which may be thought of as a
function. Given any number of S-expressions it produces an atomic symbol
whose print name is the concatenation of the print names of the
S-expressions. Usually the S-expressions will be atomic symbols or
numbers.</p>
<pre><code>  (CATENATE &#39;FOO &#39;- 43) =&gt; F00-43</code></pre>
<p><code>GENTEMP</code> is used to generate a new unique symbol, given a
specified prefix. The global variable <code>*GENTEMPNUM*</code> starts
at zero and increases monotonicially. Each call to <code>GENTEMP</code>
catenates the prefix, a hyphen, and a new value of
<code>*GENTEMPNUM*</code>. Because the numeric suffixes of the generated
symbols increase with time, one can determine in which order symbols
were generated. We also will use different prefixes for different
purposes, so that one can tell which part of the compiler generated a
given symbol. This information can be invaluable for debugging purposes;
from the names of the symbols appearing in a data structure, one can
determine how that structure was created and in what order. (The
generated symbols are themselves used primarily as simple markers, or as
simple structures (property lists). The use of the print names amounts
to tagging each marker or structure with a type and a creation
timestamp. A <span class="sc">LISP</span>-like language encourages the
inclusion of such information.)</p>
<pre><code>  (GENTEMP &#39;NODE) =&gt; NODE-2534</code></pre>
<p>A list of all generated symbols is maintained in
<code>*GENTEMPLIST*</code>. <code>GENFLUSH</code> can be called to
excise all generated symbols from the <span class="sc">MacLISP</span>
obarray; this is periodically necessary when compiling a large file so
that unneeded symbols may be garbage-collected. The symbols are
initially interned on the obarray in the first place for ease of
debugging (one can refer to them by name from a debugging breakpoint).
<code>GEN-GLOBAL-NAME</code> is used to generate a symbol to be used as
a run-time name by the compiled code. The prefix for such names is
initially “<code>?</code>” for testing purposes, but is initialized by
the file transducer as a function of the name of the file being
compiled. This allows separately compiled files to be loaded together
without fear of naming conflicts.</p>
</section>
<section id="rabbit-568-051578-page-3" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 3</a></h4>
<p><code>WARN</code> is a macro used to print a notice concerning an
incorrect program being compiled. It generates a call to
<code>PRINT-WARNING</code>, which maintains a count and a list of the
error messages, and prints the message, along with any associated useful
quantities.</p>
<pre><code>  (WARN |FOO is greater than BAR| FOO BAR)</code></pre>
<p>would print (assuming the values of <code>FOO</code> and
<code>BAR</code> were <code>43</code> and <code>15</code>)</p>
<pre><code>  ;Warning: F00 is greater than BAR
  ; 43
  ; 15</code></pre>
<p><code>WARN</code> is used only to report errors in the program being
compiled. The <span class="sc">MacLISP</span> <code>ERROR</code>
function is used to signal internal inconsistencies in the compiler.</p>
<p><code>ASK</code> is a macro which prints a message and then waits for
a reply. Typically <code>NIL</code> means “no”, and anything else means
“yes”.</p>
<p><code>SX</code> and <code>CSX</code> are debugging aids which print
intermediate data structures internal to the compiler in a readable
form. They make use of <code>SPRINTER</code> (part of the <span class="sc">MacLISP</span> <code>GRIND</code> pretty-printing package)
and of <code>SEXPRFY</code> and <code>CSEXPRFY</code>, which are defined
below.</p>
<p>The <code>EQCASE</code> macro provides a simple dispatching control
structure. The first form evaluates to an item, and the clause whose
keyword matches the item is executed. If no clause matches, an error
occurs. For example:</p>
<pre><code>  (EQCASE TRAFFIC-LIGHT
          (RED (PRINT &#39;STOP))
          (GREEN (PRINT &#39;GO))
          (YELLOW (PRINT &#39;ACCELERATE) (CRASH)))</code></pre>
<p>expands into the code:</p>
<pre><code>  (COND ((EQ TRAFFIC-LIGHT &#39;RED) (PRINT &#39;STOP))
        ((EQ TRAFFIC-LIGHT &#39;GREEN) (PRINT &#39;GO))
        ((EQ TRAFFIC-LIGHT &#39;YELLOW) (PRINT &#39;ACCELERATE) (CRASH))
        (T (ERROR &#39;|Losing EQCASE| TRAFFIC-LIGHT &#39;FAIL-ACT) ))</code></pre>
</section>
<section id="rabbit-568-051578-page-4" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 4</a></h4>
<p>The next group of macros implement typed data structures with named
components. <code>ACCESSFN</code>, <code>CLOBBER</code>, and
<code>HUNKFN</code> allow definition of very general structure access
functions. Their precise operation is not directly relevant to this
exposition; suffice it to say that they are subsidiary to the
<code>DEFTYPE</code> macro on the next page.</p>
<p><code>DEFTYPE</code> defines structure “data types” with named
components. These structures are implemented as <span class="sc">MacLISP</span> hunks. (A hunk is essentially a kind of list
cell with more than two pointer components; it may be thought of as a
short, fixed-length vector. Hunks are accessed with the function
<code>(CXR n hunk)</code>, which returns the nth component of the hunk.
<code>(RPLACX n hunk newval)</code> analogously alters the nth
component. <code>CXR</code> and <code>RPLACX</code> are thus similar to
<code>CAR</code>/<code>CDR</code> and
<code>RPLACA</code>/<code>RPLACD</code>.)</p>
<p>Slot 0 of each hunk is reserved for a “property list”; this feature
is not used in <span class="sc">RABBIT</span>. Slot 1 always contains an
atomic symbol which is the name of the type. Thus every structure
explicitly bears its type. The form <code>(HUNKFN TYPE 1)</code> creates
a function (actually a macro) called <code>TYPE</code> which when
applied to a hunk will fetch slot 1. Slots 2 upward of a hunk are used
to contain named components. A structure does <em>not</em> contain the
component names. (However, the symbol which is the name of the type does
have a list of the component names on its property list. This is useful
for debugging purposes. There is, for example, a package which
pretty-prints structured data types, showing the components explicitly
as name-value pairs, which uses this information.)</p>
</section>
<section id="rabbit-568-051578-page-5" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 5</a></h4>
<p>Consider for example the form</p>
<pre><code>  (DEFTYPE LAMBDA (UVARS VARS BODY))</code></pre>
<p>This defines a structured data type called <code>LAMBDA</code> with
three named components <code>UVARS</code>, <code>VARS</code>, and
<code>BODY</code>. It also defines a series of macros for manipulating
this data type.</p>
<p>For access, the macros <code>LAMBDA\UVARS</code>,
<code>LAMBDA\VARS</code>, and <code>LAMBDA\BODY</code> are defined.
These each take a single argument, a data structure of type
<code>VARIABLE</code>, and return the appropriate component. (The
<code>TYPE</code> function can also be applied to the data object, and
will return <code>LAMBDA</code>.)</p>
<p>For construction, a macro <code>CONS-LAMBDA</code> is defined. For
example, the form:</p>
<pre><code>  (CONS-LAMBDA (UVARS = LIST1)
               (VARS = LIST2))</code></pre>
<p>would construct a <code>LAMBDA</code> structure with the
<code>TYPE</code>, <code>UVARS</code>, <code>VARS</code>, and
<code>BODY</code> slots initialized respectively to <code>LAMBDA</code>,
the value of <code>LIST1</code>, the value of <code>LIST2</code>, and
the “empty object” (recall the <code>EMPTY</code> predicate above). Any
component names (possibly none!) may be initialized in a
<code>CONS-xxx</code> form, and any components not mentioned will be
initialized to the empty object. (The “<code>=</code>” signs are purely
syntactic sugar for mnemonic value. They can be omitted.)</p>
<p>For alteration of components, a macro <code>ALTER-LAMBDA</code> is
defined. For example, the form</p>
<pre><code>  (ALTER-LAMBDA FOO
                (UVARS := LIST1)
                (BODY := (LIST A B)))</code></pre>
<p>would alter the <code>UVARS</code> and <code>BODY</code> components
of the value of <code>FOO</code> (which should be a <code>LAMBDA</code>
structure - this is not checked) to be respectively the values of
<code>LIST1</code> and <code>(LIST A B)</code>. Any non-zero number of
components may be modified by a single <code>ALTER-xxx</code> form. (The
“<code>:=</code>” signs are purely syntactic sugar also.)</p>
<p>A great advantage of using these structure definitions is that it is
very easy to add or delete components during the development of the
program. In particular, when a new component is added to a type, it is
not necessary to find all instances of creations of objects of that
type; they will simply automatically initialize the new slot to the
empty object. Only parts of the program which are relevant to the use of
the new component need be changed.</p>
</section>
<section id="rabbit-568-051578-page-6" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 6</a></h4>
<p>On this page are two groups of utility functions. One group
manipulates property lists, and the other manipulates sets of objects
represented as lists.</p>
<p>For <code>(ADDPROP SYM VAL PROP)</code>, the <code>PROP</code>
property of the symbol <code>SYM</code> should be a list of things. The
object <code>VAL</code> is added to this list if it is not already a
member of the list.</p>
<p><code>DELPROP</code> performs the inverse of <code>ADDPROP</code>; it
removes an object from a list found as the property of a symbol.</p>
<p><code>(SETPROP SYM VAL PROP)</code> puts the property-value pair
<code>PROP</code>, <code>VAL</code> on the property list of
<code>SYM</code>; but if <code>SYM</code> already has a
<code>PROP</code> property, it is an error unless the new value is the
same as (<code>EQ</code> to) the existing one. That is, a redundant
<code>SETPROP</code> is permitted, but not a conflicting one.</p>
<div class="line-block">    <code>(ADJOIN ITEM SET)</code> produces a
new set <code>SET U {ITEM}</code>.<br />
    <code>UNION</code> produces the union of two sets.<br />
    <code>INTERSECT</code> produces the intersection of two sets.<br />
    <code>(REMOVE ITEM SET)</code> produces a new set
<code>SET - {ITEM}</code>.<br />
    <code>(SETDIFF SET1 SET2)</code> produces the set
<code>SET1 - SET2</code>.</div>
<p>All of the set operations are accomplished non-destructively; that
is, the given arguments are not modified. Examples:</p>
<pre><code>  (ADJOIN &#39;A &#39;(A B C)) =&gt; (A B C)
  (ADJOIN &#39;A &#39;(B C D)) =&gt; (A B C D)
  (UNION &#39;(A B C) &#39;(B D F)) =&gt; (D F A B C)
  (INTERSECT &#39;(A B C) &#39;(B D F)) =&gt; (B)
  (REMOVE &#39;B &#39;(A B C)) =&gt; (A C)
  (SETDIFF &#39;(A B C) &#39;(B D F)) =&gt; (A C)</code></pre>
</section>
<section id="rabbit-568-051578-page-7" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 7</a></h4>
<p>The <code>PAIRLIS</code> function is similar to, but not identical
to, the function of the same name in the LISP 1.5 Manual. The difference
is that the pairs of the association list produced are 2-lists rather
than single conses. This was done purely so that structures produced by
<code>PAIRLIS</code> would be more readable when printed; the ease of
debugging was considered worth the additional <code>CONS</code> and
access time.</p>
<pre><code>  (PAIRLIS &#39;(A B C) &#39;(X Y Z) &#39;((F P) (G Q)))
      =&gt; ((C Z) (B Y) (A X) (F P) (G Q))</code></pre>
<p>The <a href="#compile2" id="compile1"><code>COMPILE</code></a>
function is the main top-level function of the compiler. It is
responsible for invoking each phase of the compiler in order.
<code>NAME</code> is the name of a function (an atomic symbol), and
<code>LAMBDA-EXP</code> the corresponding lambda-expression; these are
easily extracted, for example, from a <span class="sc">SCHEME</span>
<code>DEFINE</code>-form. <code>SEE-CRUD</code> is <code>NIL</code> for
normal processing, or <code>T</code> for debugging purposes.
<code>OPTIMIZE</code> is a switch controlling whether the optimization
phase should be invoked; it can be <code>T</code>, <code>NIL</code>, or
<code>MAYBE</code> (meaning to ask the (human) debugger).</p>
<div id="alphatize6">
<p>The overall flow within <a href="#compile2"><code>COMPILE</code></a>
is as follows: check number of arguments; apply <a href="#outline"><code>ALPHATIZE</code></a> to the lambda-expression to
produce the pass 1 data structure; optionally optimize this data
structure; perform pass 1 analysis; convert the pass 1 data structure to
a pass 2 (continuation-passing style) data structure; perform pass 2
analysis; generate code. The value of <a href="#compile2"><code>COMPILE</code></a> is the <span class="sc">MacLISP</span> code produced by the code generator.</p>
</div>
<p><a href="#pass1-analyze2" id="pass1-analyze1"><code>PASS1-ANALYZE</code></a> is a separate
function so that it can be used by the optimizer to re-analyze newly
created subexpressions.</p>
<p><code>CL</code> is a debugging utility. <code>(CL FOO)</code> causes
the function <code>FOO</code> (which should be defined in the running
<span class="sc">SCHEME</span> into which the compiler has been loaded)
to be compiled. Various debugging facilities, such as
<code>SEE-CRUD</code>, are enabled. This is done by using
<code>TEST-COMPILE</code>.</p>
</section>
<section id="rabbit-568-051578-page-8" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 8</a></h4>
<p>Here are the structured data types used for the pass 1 intermediate
representation. Each piece of the program is represented as a
<code>NODE</code>, which has various pieces of information associated
with it. The <code>FORM</code> component is a structure of one of the
types <code>CONSTANT</code>, <code>VARIABLE</code>, <code>LAMBDA</code>,
<code>IF</code>, <code>ASET</code>, <code>CATCH</code>,
<code>LAMBDA</code>, <code>LABELS</code>, or <code>COMBINATION</code>.
This structure holds information specific to a given type of program
node, whereas the <code>NODE</code> structure itself holds information
which is needed at every node of the program structure. (One may think
of the <code>FORM</code> component as a <span class="sc">PASCAL</span>
record variant.)</p>
<p>The <a href="#alphatize2" id="alphatize1"><code>ALPHATIZE</code></a>
routine and its friends take the S-expression definition of a function
(a lambda-expression) and make a copy of it using <code>NODE</code>
structures. This copy, like the S-expression, is a tree. Subsequent
analysis routines will all recur on this tree, passing information up
and down the tree, either child distributing information from parent
node to child nodes, or collating information from child nodes to pass
back to parent nodes. Some information must move laterally within the
tree, from branch to branch; this is accomplished exclusively by using
the property lists of symbols, usually those generated for renamings of
variables (since all lateral information is associated with variable
references - which is no accident!).</p>
<div id="meta-evaluate5">
<p>The function <code>NODIFY</code> is used for constructing a node,
with certain slots properly initialized. In particular, the
<code>METAP</code> slot is initialized to <code>NIL</code>, indicating a
node not yet processed by <a href="#meta-evaluate6"><code>META-EVALUATE</code></a>; this fact will be
used later in the optimizer. A name is generated for the node, and the
node is put on the property list of the name. This property is for
debugging purposes only; given the name of a node one can get the node
easily. The name itself may also be used for another purpose by
<code>CONVERT-COMBINATION</code>, to represent the intermediate quantity
which is the value of the form represented by the node.</p>
</div>
</section>
<section id="rabbit-568-051578-page-9" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 9</a></h4>
<p><a href="#alphatize3" id="alphatize2"><code>ALPHATIZE</code></a>
takes an S-expression to convert, and an environment. The latter is a
list of 2-lists; each 2-list is of the form (user-name new-name). This
is used for renaming each variable to a unique name. The unique names
are generated within <code>ALPHA-LAMBDA</code>,
<code>ALPHA-LABELS</code>, and <code>ALPHA-CATCH</code>, where the
variable bindings are encountered. The new name pairings are tacked onto
the front of the then-current environment, and the result used as the
environment for converting the body.</p>
<p><a href="#alphatize3"><code>ALPHATIZE</code></a> merely does a
dispatch on the type of form, to one of the sub-functions for the
various types. It also detects forms which are really macro calls, and
expands them by calling <a href="#outline" id="macro-expand2"><code>MACRO-EXPAND</code></a>, which returns the form
to be used in place of the macro call. (<code>BLOCK</code> is handled as
a separate special case. In the interpreter, <code>BLOCK</code> is
handled specially rather than going through the general
<code>MACRO</code> mechanism. This is done purely for speed. Defining
<code>BLOCK</code> as a macro in the compiler can confuse the
interpreter in which the compiler runs, and so it was decided simply to
handle <code>BLOCK</code> as a special case in the compiler also.) <a href="#alphatize3"><code>ALPHATIZE</code></a> allows the S-expression to
contain already converted code in the form of <code>NODE</code>s; this
fact is exploited by the optimizer (see <a href="#outline" id="meta-if-fudge3"><code>META-IF-FUDGE</code></a> below), but has no
use in the initial conversion.</p>
<p><code>ALPHA-ATOM</code> creates a <code>CONSTANT</code> structure for
numbers and the special symbols <code>NIL</code> and <code>T</code>.
Otherwise a <code>VARIABLE</code> structure is created. If the symbol
(it better be a symbol!) occurs in the environment, the new-name is
used, and otherwise the symbol itself. The slot <code>GLOBALP</code> is
set to <code>T</code> iff the symbol was not in the environment.</p>
<p><code>ALPHA-LAMBDA</code> generates new names for all the bound
variables. It then converts its body, after using <code>PAIRLIS</code>
to add the user-name/new-name pairs to the environment. The result is
used to make a <code>LAMBDA</code> structure. A copy is made of the list
of variables in the <code>UVARS</code> slot; it must be copied because
later <a href="#meta-combination-lambda6" id="meta-combination-lambda5"><code>META-COMBINATION-LAMBDA</code></a>
may splice out elements of that list. If so, it will also splice out
corresponding members of <code>VARS</code>, but that list was freshly
consed by <code>ALPHA-LAMBDA</code>.</p>
</section>
<section id="rabbit-568-051578-page-10" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 10</a></h4>
<p><code>ALPHA-IF</code> simply converts the predicate, consequent, and
alternative, and makes an <code>IF</code> structure.</p>
<p><code>ALPHA-ASET</code> checks for a non-quoted first argument.
(Presently <span class="sc">RABBIT</span> does not allow for computed
<code>ASET</code> variables. Since <span class="sc">RABBIT</span> was
written, such computed variables have in fact been banned from the <span class="sc">SCHEME</span> language [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr11" title="[11] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>].) For simplicity, it also does not allow altering a global
variable which is the name of a <span class="sc">MacLISP</span>
primitive. This restriction is related only to the kludginess of the
<span class="sc">PDP-10</span> <span class="sc">MacLISP</span> <span class="sc">SCHEME</span> implementation, and is not an essential problem
with the language. The <code>ERROR</code> function was used here rather
than <code>WARN</code> because the problems are hard to correct for and
occur infrequently. Aside from these difficulties,
<code>ALPHA-ASET</code> is much like <code>ALPHA-ATOM</code> on a
variable; it looks in the environment, converts the body, and then
constructs an <code>ASET</code> structure.</p>
<p><code>ALPHA-CATCH</code> generates a new name
“<code>CATCHVAR-nn</code>” for the bound variable, tacks it onto the
environment, and converts the body; it then constructs a
<code>CATCH</code> structure.</p>
<p><code>ALPHA-LABELS</code> generates new names “<code>FNVAR-n</code>”
for all the bound variables; it then constructs in <code>LENV</code> the
new environment, using <code>PAIRLIS</code>. It then converts all the
bound function definitions and the body, using this environment. In this
way all the function names are apparent to all the functions. A
<code>LABELS</code> structure is then created.</p>
</section>
<section id="rabbit-568-051578-page-11" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 11</a></h4>
<p><code>ALPHA-LABELS-DEFN</code> parses one <code>LABELS</code>
definition clause. An extension to the <span class="sc">SCHEME</span>
language (made just after the publication of [<a href="#revised-report-1-2-3-4-5-6-7-8-9-10-11-12" id="xrr12" title="[12] Steele and Sussman 1978, The Revised Report on SCHEME">Revised
Report</a>]!) allows a <code>LABELS</code> definition to take on any of
the same three forms permitted by <code>DEFINE</code>. Thus this
<code>LABELS</code> form actually defines <code>FOO</code>,
<code>BAR</code>, and <code>BAZ</code> to be equivalent functions:</p>
<pre><code>  (LABELS ((FOO (LAMBDA (X Y) (BLOCK (PRINT X) (+ X Y))))
           (BAR (X Y) (PRINT X) (+ X Y))
           ((BAZ X Y) (PRINT X) (+ X Y)))
          (LIST (FOO 1 2) (BAR 1 2) (BAZ 1 2)))</code></pre>
<p><code>ALPHA-BLOCK</code> implements the standard macro definition of
<code>BLOCK</code>. <code>(BLOCK x)</code> is simply <code>x</code>, and
<code>(BLOCK x . y)</code> expands into:</p>
<pre><code>  ((LAMBDA (A B) (B)) x (LAMBDA () (BLOCK . y)))</code></pre>
<p><a href="#macro-expand2" id="macro-expand1"><code>MACRO-EXPAND</code></a> takes a macro call and
expands it into a new form to be used in place of the macro call. In the
<span class="sc">PDP-10</span> <span class="sc">MacLISP</span> <span class="sc">SCHEME</span> implementation there are three different kinds
of macros. Types <code>MACRO</code> and <code>AMACRO</code> are defined
by <span class="sc">MacLISP</span> code, and so their defining functions
are invoked using the <span class="sc">MacLISP</span> primitive
<code>FUNCALL</code>. Type <code>SMACRO</code> is defined by <span class="sc">SCHEME</span> code which is in the value cell of an atomic
symbol; thus <code>SYMEVAL</code> is used to get the contents of the
value cell, and this <span class="sc">SCHEME</span> function is then
invoked.</p>
<p><code>ALPHA-COMBINATION</code> converts all the subforms of a
combination, making a list of them, and creates a
<code>COMBINATION</code> structure. If the function position contains a
variable, it performs a consistency check using
<code>CHECK-NUMBER-OF-ARGS</code> to make sure the right number of
arguments is present.</p>
</section>
<section id="rabbit-568-051578-page-12" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 12</a></h4>
<div id="compile2">
<div id="pass1-analyze2">
<div id="env-analyze9">
<div id="meta-evaluate6">
<div id="effs-analyze5">
<p>Once the S-expression function definition has been copied as a
<code>NODE</code> tree, <a href="#compile3"><code>COMPILE</code></a>
calls <a href="#pass1-analyze3"><code>PASS1-ANALYZE</code></a> to fill
in various pieces of information. (If optimization is to be performed,
<a href="#compile3"><code>COMPILE</code></a> instead calls <a href="#outline"><code>META-EVALUATE</code></a>. <a href="#outline"><code>META-EVALUATE</code></a> in turn calls <a href="#pass1-analyze3"><code>PASS1-ANALYZE</code></a> in a coroutining
manner we will examine later.) <a href="#pass1-analyze3"><code>PASS1-ANALYZE</code></a> in turn calls <a href="#outline"><code>ENV-ANALYZE</code></a>, <a href="#outline"><code>TRIV-ANALYZE</code></a>, and <a href="#outline"><code>EFFS-ANALYZE</code></a> in order. Each of these
has roughly the same structure. Each takes a node and a flag called
<code>REDOTHIS</code>. Normally <code>REDOTHIS</code> is
<code>NIL</code> and the information has not yet been installed in the
node, and so the routine proceeds to analyze the node and install the
appropriate information.</p>
</div>
</div>
</div>
</div>
</div>
<p>When invoked by the optimizer, however, there may be information in
the node already, but that information may be incorrect or obsolete as a
result of the optimizing transformations. If <code>REDOTHIS</code> is
non-<code>NIL</code>, then the given node must be reanalyzed, even if
the information is already present. If <code>REDOTHIS</code> is in fact
the symbol <code>ALL</code>, then all descendants of the given node must
be reanalyzed. Otherwise, only the given node requires re-analysis, plus
any descendants which have not had the information installed at all. We
will see later how these mechanisms are used in the optimizer.</p>
<p>The purpose of <a href="#env-analyze2" id="env-analyze1"><code>ENV-ANALYZE</code></a> is to fill in for each
node the slots <code>REFS</code> and <code>ASETS</code>. The first is a
set (represented as a list) of the new-names of all variables bound
above the node and referenced at or below the node, and the second (a
subset of the first) is a set of such names which appear in an
<code>ASET</code> at or below the node. These lists are computed
recursively. A <code>CONSTANT</code> node has no such references; a
<code>VARIABLE</code> node (with <code>GLOBALP</code> =
<code>NIL</code>) refers to its own variable. An <code>ASET</code> node
adds its variable to the <code>ASET</code> list for its body. Most lists
for other kinds of nodes merely merge together the lists for their
immediate descendants. In order to satisfy the “bound above the node”
requirement, those structures which bind variables (<code>LAMBDA</code>,
<code>CATCH</code>, <code>LABELS</code>) filter out their own bound
variables from the two sets.</p>
<p>As an example, consider this function:</p>
<pre><code>  (LAMBDA (X)
          ((LAMBDA (Y)
                   ((LAMBDA (W)
                            (ASET&#39; Z (* X Y)))
                    (ASET&#39; Y (- Y 1))))
           (- X 3)))</code></pre>
<p>The node for <code>(- X 3)</code> would have a <code>REFS</code> list
<code>(X)</code> and an <code>ASET</code> list <code>()</code>. The node
for the <code>ASET</code> on <code>Z</code> would have
<code>REFS=(X Y)</code> (or perhaps <code>(Y X)</code>) and
<code>ASETS=()</code>; <code>Z</code> does not appear in the
<code>ASETS</code> list because it is not bound above. The node for the
combination <code>((LAMBDA (W) ...) ...)</code> would have
<code>REFS=(X Y)</code> and <code>ASETS=(Y)</code>. The node for the
lambda-expression <code>(LAMBDA (Y) ...)</code> would have
<code>REFS=(X)</code> and <code>ASETS=()</code>, because <code>Y</code>
is filtered out.</p>
</section>
<section id="rabbit-568-051578-page-12.1" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 12.1</a></h4>
<div id="compile3">
<p>It should be easy to see the the topmost node of the node-tree must
have <code>REFS=()</code> and <code>ASETS=()</code>, because no
variables are bound above it. This fact is used in <a href="#compile4"><code>COMPILE</code></a> for a consistency check.
(After writing this last sentence, I noticed that in fact this
consistency check was not being performed, and that it was a good idea.
On being installed, this check immediately caught a subtle bug in the
optimizer. Consistency checks pay off!)</p>
</div>
<p>Another purpose accomplished by <a href="#env-analyze3" id="env-analyze2"><code>ENV-ANALYZE</code></a> is the installation of
several useful properties on the new-names of bound variables. Two
properties, <code>READ-REFS</code> and <code>WRITE-REFS</code>,
accumulate for each variable the set of <code>VARIABLE</code> nodes
which refer to it and the set of <code>ASET</code> nodes that refer to
it. These lists are very important to the optimizer. A non-empty
<code>WRITE-REFS</code> set also calls for <code>WRITE-REFS</code>
special action by the code generator.</p>
<p>When a <code>LAMBDA</code> node is encountered, that node is put onto
each new-name under the <code>BINDING</code> property, and the user-name
is put under the <code>USER-NAME</code> property; these are used only
for debugging.</p>
</section>
<section id="rabbit-568-051578-page-13" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 13</a></h4>
<p><a href="#triv-analyze2" id="triv-analyze1"><code>TRIV-ANALYZE</code></a> fills in the
<code>TRIVP</code> slot for each node. This is a flag which, if
non-<code>NIL</code>, indicates that the code represented by that node
and its descendants is “trivial”, i.e. it can be executed as simple host
machine (<span class="sc">MacLISP</span>) code because no <span class="sc">SCHEME</span> closures are involved. Constants and variables
are trivial, as are combinations with trivial arguments and a provably
trivial function. While lambda-expressions are in general non-trivial
(because a closure must be constructed), a special case is made for
<code>((LAMBDA ...) ...)</code>, i.e. a combination whose function is a
lambda-expression. This is possible because the code generator will not
really generate a closure for the lambda-expression. This is the first
example of a trichotomy we will encounter repeatedly. Combinations are
divided into three kinds: those with a lambda-expression in the function
position, those with a trivial <span class="sc">MacLISP</span> primitive
(satisfying the predicate <code>TRIVFN</code>) in the function position,
and all others.</p>
<p>All other expressions are, in general, trivial iff all their subparts
are trivial. Note that a <code>LABELS</code> is trivial iff its body is
trivial; the non-triviality of the bound functions does not affect
this.</p>
<p>The triviality flag is used by phase 2 to control conversion to
continuation-passing style. This in turn affects the code generator,
which compiles trivial forms straightforwardly into <span class="sc">MacLISP</span> code, rather than using the more complex
techniques required by non-trivial <span class="sc">SCHEME</span> code.
It would be possible to avoid triviality analysis entirely; the net
result would only be less optimal final code.</p>
</section>
<section id="rabbit-568-051578-page-14" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 14</a></h4>
<p><a href="#effs-analyze2" id="effs-analyze1"><code>EFFS-ANALYZE</code></a> analyzes the code for
side-effects. In each node the four slots <code>EFFS</code>,
<code>AFFD</code>, <code>PEFFS</code>, and <code>PAFFD</code> are filled
in. Each is a set of side effects, which may be the symbol
<code>NONE</code>, meaning no side effects; <code>ANY</code>, meaning
all possible side effects; or a list of specific side effect names. Each
such name specifies a category of possible side effects. Typical names
are <code>ASET</code>, <code>RPLACD</code>, and <code>FILE</code> (which
means input/output transactions).</p>
<p>The four slots <code>EFFS</code>, <code>AFFD</code>,
<code>PEFFS</code>, and <code>PAFFD</code> refer to the node they are in
and all nodes beneath it. Thus each is computed by taking the union of
the corresponding sets of all immediate descendants, then adjoining any
effects due to the current node.</p>
<p><code>EFFS</code> is the set of side effects which may possibly be
caused at or below the current node; <code>PEFFS</code> is the set of
side effects which can be proved to occur at or below the node. These
may differ because of ignorance on <span class="sc">RABBIT</span>’s
part. For example, the node for a combination <code>(RPLACA A B)</code>
will have the side-effect name <code>RPLACA</code> adjoined to both
<code>EFFS</code> and <code>PEFFS</code>, because the <span class="sc">RABBIT</span> knows that <code>RPLACA</code> causes an
<code>RPLACA</code> side effect (how this is known will be discussed
later). On the other hand, for a combination <code>(FOO A B)</code>,
where <code>FOO</code> is some user function, <span class="sc">RABBIT</span> can only conjecture that <code>FOO</code> can
cause any conceivable side effect, but cannot prove it. Thus
<code>EFFS</code> will be forced to be <code>ANY</code>, while
<code>PEFFS</code> will not.</p>
<p><code>AFFD</code> is the set of side effects which can possibly
affect the evaluation of the current node or its descendants. For
example, an <code>RPLACA</code> side effect can affect the evaluation of
<code>(CAR X)</code>, but on the other hand an <code>RPLACD</code> side
effect cannot. <code>PAFFD</code> is the corresponding set of side
effects for which it can be proved. (This set is “proved” in a less
rigorous sense than for <code>PEFFS</code>. The name <code>RPLACA</code>
would be put in the <code>PAFFD</code> set for <code>(CAR X)</code>,
even though the user might know that while there are calls to
<code>RPLACA</code> in his program, none of them ever modify
<code>X</code>. <code>PEFFS</code> and <code>PAFFD</code> are only used
by <code>CHECK-COMBINATION-PEFFS</code> to warn the user of potential
conflicts anyway, and serve no other purpose. <code>EFFS</code> and
<code>AFFD</code>, on the other hand, are used by the optimizer to
prevent improper code motion. Thus <code>EFFS</code> and
<code>AFFD</code> must be pessimistic, and err only on the safe side;
while <code>PEFFS</code> and <code>PAFFD</code> are optimistic, so that
the user will not be pestered with too many warning messages.)</p>
<p>The <code>CONS</code> side effect is treated specially. A node which
causes the <code>CONS</code> side effect must not be duplicated, because
each instance will create a new object; but whereas two
<code>RPLACA</code> side effects may not be executed out of order, two
<code>CONS</code> side effects may be.</p>
<div id="env-analyze3">
<p>The computation of <code>AFFD</code> and <code>PAFFD</code> for
variables depends on whether the variable is global or not. If it is,
<code>SETQ</code> and <code>RPLACD</code> can affect it
(<code>RPLACD</code> can occur because of the peculiarities of the <span class="sc">PDP-10</span> <span class="sc">MacLISP</span>
implementation); otherwise, <code>ASET</code> can affect it if indeed
any <code>ASET</code> refers to it (in which case <a href="#env-analyze4"><code>ENV-ANALYZE</code></a> will have left a
<code>WRITE-REFS</code> property); otherwise, nothing can affect it.
Similar remarks hold for the computation of <code>EFFS</code> and
<code>PEFFS</code> for an <code>ASET</code> node. The name
<code>SETQ</code> applies to modifications of global variables, while
<code>ASET</code> applies to local variables.</p>
</div>
</section>
<section id="rabbit-568-051578-page-15" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 15</a></h4>
<p>(While it may be held that allowing <code>ASET&#39;</code> on variables
is unclean, and neater, that the use of cells as in <span class="sc">PLASMA</span> is semantically neater, it is true that because
of the lexical scoping rules it can always be determined whether a given
variable is ever used in an <code>ASET&#39;</code>. In this way one can say
that variables are divided by the compiler into two classes: those which
are implicitly cells, and those which are not.)</p>
<p>A closure (<code>LAMBDA</code>-expression) causes a <code>CONS</code>
side-effect. This is not so much because <span class="sc">SCHEME</span>
programs depend on being able to do <code>EQ</code> on closures (it is
unclear whether this is a reasonable thing to specify in the semantics
of <span class="sc">SCHEME</span>), as because there is no point in
creating two closures when one will suffice. Adjoining <code>CONS</code>
to <code>EFFS</code> will prevent the creation of such duplicate code by
the optimizer. The same idea holds for <code>LABELS</code> (which has
<code>LAMBDA</code>-expressions within it).</p>
<p>Notice that a <code>LAMBDA</code> node does <em>not</em> add to its
four sets the information from its body’s sets. This is because
evaluation of a <code>LAMBDA</code>-expression does not immediately
evaluate the body. Only later, when the resulting closure is invoked, is
the body executed.</p>
<p><code>EFFS-UNION</code> gives the union of two sets of side effects.
It knows about the special symbols <code>NONE</code> and
<code>ANY</code>.</p>
<p><code>EFFS-ANALYZE-IF</code> computes the side-effect sets for
<code>IF</code> nodes. It has been made a separate function only because
its code is so bulky; it must perform a three-way union for each of four
sets.</p>
<p><code>EFFS-ANALYZE-COMBINATION</code> computes the side-effect sets
for <code>COMBINATION</code> nodes. First the function is analyzed, then
the arguments. The unions of the four sets over all the arguments are
accumulated in <code>EF</code>, <code>AF</code>, <code>PEF</code>, and
<code>PAF</code>. <code>CHECK-COMBINATION-PEFFS</code> is called to warn
the user of any possible violations of the rule that <span class="sc">SCHEME</span> is privileged to choose the order in which to
evaluate the subforms of a combination. Finally, there are three cases
depending on the form of the function position.</p>
<div id="bind-analyze4">
<p>If it is a variable, then the property list of the variable name is
searched for information about that function. (The generated names for
local variables will never have any such information; thus information
will be found only for global variables. This information is used to
augment the sets. (A clever technique not used in <span class="sc">RABBIT</span> would be to arrange for situations like
<code>((LAMBDA (F) &lt;body1&gt;) (LAMBDA (...) &lt;body2&gt;)</code>,
where <code>F</code> denotes a “known function” (see the description of
<a href="#bind-analyze5"><code>BIND-ANALYZE</code></a> below), to put on
the property list of <code>F</code> the side-effect information for
<code>&lt;body2</code>&gt;, to aid optimization in
<code>&lt;body1&gt;</code>.)</p>
</div>
<p>If the function position is a <code>LAMBDA</code>-expression, then
the four sets of the body of the <code>LAMBDA</code>-expression are
unioned into the four sets for the <code>COMBINATION</code> node. This
is because in this case we know that the body
<code>LAMBDA</code>-expression will be executed in the course of
executing the <code>COMBINATION</code> node.</p>
<p>In any other case, an unknown function is computed, and so it must be
computed, assumed that any side-effect is possible for <code>EFFS</code>
and <code>AFFD</code>.</p>
</section>
<section id="rabbit-568-051578-page-16" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 16</a></h4>
<p><code>CHECK-COMBINATION-PEFFS</code> checks all the argument forms of
a combination (including the function position) to see if they are all
independent of each other with respect to side effects. If not, a
warning is issued. This is because the semantics of <span class="sc">SCHEME</span> specify that the arguments may be evaluated in
any order, and the user may not depend on a particular ordering.</p>
<p>The test is made by comparing all pairs of arguments within the
combination. If the side-effects of one can “provably” affect the
evaluation of the other, or if they both cause a side effect of the same
category (other than <code>CONS</code>, which is special), then the
results may depend on which order they are evaluated in. The test is not
completely rigorous, and may err in either direction, but “probably” a
reasonably written <span class="sc">SCHEME</span> program will satisfy
the test.</p>
<p>This check is controlled by the switch <code>*CHECK-PEFFS*</code> in
<code>EFFS-ANALYZE-COMBINATION</code>. This switch is provided because
empirical tests show that performing the test slows down compilation by
twenty to thirty percent. The test has proved valuable in trapping
programming errors, and so is normally on, but it can be turned off for
speed in compiling programs in which one has confidence.</p>
<p><code>EFFDEF</code> is a macro which expands into a number of
<code>DEFPROP</code> forms. This is used to define side-effect
information about primitive functions. For example:</p>
<pre><code>  (EFFDEF CADR NONE (RPLACA RPLACD))</code></pre>
<p>states that <code>CADR</code> causes no side-effects, and is
“provably” affected by the <code>RPLACA</code> and <code>RPLACD</code>
categories of side-effects. Similarly:</p>
<pre><code>  (EFFDEF MEMQ NONE (RPLACA RPLACD) T)</code></pre>
<p>specifies the same information for <code>MEMQ</code>, but the
“<code>T</code>” means that a call to <code>MEMQ</code> with constant
arguments may be “folded” (evaluated, and the result compiled instead),
despite the fact that some side effects can affect it. This represents a
judgement that it is extremely unlikely that someone will write a
program which modifies a constant argument to be given to
<code>MEMQ</code>.</p>
</section>
<section id="rabbit-568-051578-page-17" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 17</a></h4>
<p>This page contains declarations of side-effect information for many
standard primitive functions. The <code>EFFDEF</code> macro used to make
the declarations is described on the previous page.</p>
</section>
<section id="rabbit-568-051578-page-18" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 18</a></h4>
<p><code>ERASE-NODE</code> and <code>ERASE-ALL-NODES</code> are
convenient mnemonic macros used to invoke <code>ERASE-NODES</code>.</p>
<p><code>ERASE-NODES</code> is used by the optimizer to destroy nodes
which have been removed from the program tree because of some
optimization. If <code>ALLP</code> is <code>NIL</code>
<code>(ERASE-NODE)</code>, then only the given node is erased; if it is
<code>T</code> <code>(ERASE-ALL-NODES)</code>, then the given node and
all descendants, direct and indirect, are erased.</p>
<p>Erasing a node may involve removing certain properties from property
lists. This is necessary to maintain the consistency of the properties.
For example, if a <code>VARIABLE</code> node is erased, then that node
must be removed from the <code>READ-REFS</code> property of the variable
name. The optimizer depends on this so that, for example, it can
determine whether all references to a variable have been erased.</p>
<div id="effs-analyze2">
<p>It should be noted in passing that in principle all occurrences of
<code>ASET</code> on a given variable could be erased, thereby reducing
its <code>WRITE-REFS</code> property to <code>NIL</code>. Because the <a href="#effs-analyze3"><code>EFFS-ANALYZE</code></a> computation on
<code>VARIABLE</code> nodes used the <code>WRITE-REFS</code> property, a
<code>VARIABLE</code> node might have <code>ASET</code> in its
<code>AFFD</code> set after the optimizer had removed all the
<code>ASET</code> nodes. Because of the tree-walking discipline of the
optimizer, the <code>VARIABLE</code> nodes will not be reanalyzed
immediately. This cannot hurt, however; it may just cause the optimizer
later to be more cautious than necessary when examining a
<code>VARIABLE</code> node. (If this doesn’t make sense, come back after
reading the description of the optimizer.)</p>
</div>
<p>The flag <code>*TESTING*</code> is used to determine whether or not
to remove the node from the <code>NODE</code> property on the node’s
name. When debugging, it is very useful to keep this information around
to trace the optimizer’s actions; but when compiling a large function
for “production” purposes, the discarded nodes may bloat memory, and so
they must be removed from the NODE property in order that they may be
garbage-collected by <span class="sc">LISP</span>.</p>
</section>
<section id="rabbit-568-051578-page-19" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 19</a></h4>
<p><a href="#meta-evaluate2" id="meta-evaluate1"><code>META-EVALUATE</code></a> is the top-level
function of the optimizer. It accepts a node, and returns a node (not
necessarily the same one) for an equivalent program.</p>
<p>The <code>METAP</code> flags in the nodes are used to control
re-analysis. <a href="#meta-evaluate2"><code>META-EVALUATE</code></a>
checks this flag first thing, and returns the given node immediately if
its <code>METAP</code> flag is non-<code>NIL</code>, meaning the node
has already been properly optimized. Otherwise it examines the node more
carefully.</p>
<div id="env-analyze4">
<div id="triv-analyze2">
<div id="effs-analyze3">
<p>Some rules about the organization of the optimizer:<br />
[1] A node returned by a call to <a href="#meta-evaluate2"><code>META-EVALUATE</code></a> will always have
its <code>METAP</code> flag set.<br />
[2] The descendants of a node must be meta-evaluated before any
information in them is used.<br />
[3] If a node has its <code>METAP</code> flag set, so do all of its
descendants. Moreover, <code>REANALYZE1</code> has been applied to the
node, so all of the information filled in by pass-1 analysis (<a href="#env-analyze5"><code>ENV-ANALYZE</code></a>, <a href="#triv-analyze3"><code>TRIV-ANALYZE</code></a>, and <a href="#effs-analyze4"><code>EFFS-ANALYZE</code></a>) is up-to-date.</p>
</div>
</div>
</div>
<p>When <a href="#compile5" id="compile4"><code>COMPILE</code></a> calls
<a href="#meta-evaluate3" id="meta-evaluate2"><code>META-EVALUATE</code></a>, all the
<code>METAP</code> flags are <code>NIL</code>, and no pass-1 analysis
has been performed. <a href="#meta-evaluate3"><code>META-EVALUATE</code></a>, roughly speaking,
calls itself recursively, and meta-evaluates the node tree from the
bottom up. After meta-evaluating all the descendants of a node, it
applies <code>REANALYZE1</code> to perform pass-1 analysis on that node,
sets the <code>METAP</code> flag, and returns the node. Exceptions can
be made to this discipline if a non-trivial optimization occurs.</p>
<div id="meta-if-fudge1">
<p>If the (meta-evaluated) predicate part of an <code>IF</code> node is
itself an <code>IF</code> node (and the debugging switch
<code>*FUDGE*</code> is set), then <a href="#meta-if-fudge2"><code>META-IF-FUDGE</code></a> is called. If it
is a constant, then the value of the constant is used to select either
the consequent <code>CON</code> or the alternative <code>ALT</code>. The
other one is then erased, and the <code>IF</code> node is itself erased.
The selected component node is then returned (it has already been
meta-evaluated). The statistics counter <code>*DEAD-COUNT*</code> counts
occurrences of this “dead code elimination” optimization.</p>
</div>
<p>The other two interesting cases are <code>COMBINATION</code> nodes
whose function position contains either a trivial function or a
<code>LAMBDA</code> node. <a href="#outline" id="meta-combination-trivfn2"><code>META-COMBINATION-TRIVFN</code></a>
and <a href="#outline" id="meta-combination-lambda6"><code>META-COMBINATION-LAMBDA</code></a>
handle these respective cases.</p>
</section>
<section id="rabbit-568-051578-page-20" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 20</a></h4>
<div id="alphatize3">
<div id="meta-if-fudge2">
<p>For an <code>IF</code> nested within another <code>IF</code>, the
transformation shown <del>in the comment</del> below is performed.</p>
<p>{{Transform <code>(IF (IF A B C) D E)</code> into:</p>
<pre><code>     ((LAMBDA (D1 E1 )
              (IF A (IF B (D1) (E1)) (IF C (D1) (E1))))
      (LAMBDA () D)
      (LAMBDA () E))                                   }}</code></pre>
<p>This involves constructing an S-expression of the appropriate form
and then calling <a href="#alphatize4"><code>ALPHATIZE</code></a> to
convert it into a node-tree. (The node-tree could be constructed
directly, but it is easier to call <a href="#alphatize4"><code>ALPHATIZE</code></a>. This is the reason why <a href="#alphatize4"><code>ALPHATIZE</code></a> merely returns a
<code>NODE</code> if it encounters one in the S-expression; <a href="#meta-if-fudge3"><code>META-IF-FUDGE</code></a> inserts various
nodes in the S-expression it constructs.) The original two
<code>IF</code> nodes are erased, a statistics counter
<code>*FUDGE-COUNT*</code> is incremented, and the new expression is
meta-evaluated and returned in place of the nested <code>IF</code>
nodes.</p>
</div>
</div>
<p>(The statistics counter shows that this optimization is performed
with modest frequency, arising from cases such as
<code>(IF (AND ...)...)</code>.)</p>
<p><a href="#meta-combination-trivfn2" id="meta-combination-trivfn1"><code>META-COMBINATION-TRIVFN</code></a>
performs the standard recursive meta-evaluation of all the arguments,
and then checks to see whether the combination can be “folded”. This is
possible {{if}} all the arguments are constants, and if the function has
no side effects and cannot be affected by side-effects, or has an
<code>OKAY-TO-FOLD</code> property. If this is the case, the function is
applied to the arguments, the combination node and its descendants are
erased, the statistics counter <code>*FOLD-COUNT*</code> is bumped, and
a new <code>CONSTANT</code> node containing the result is created and
meta-evaluated. This might typically occur for <code>(NOT NIL)</code>
=&gt; <code>T</code>, or <code>(+ 3 4)</code> =&gt; <code>7</code>, or
<code>(MEMQ &#39;BAR &#39;(FOO BAR BAZ))</code> =&gt; <code>&#39;(BAR BAZ)</code>.
If this optimization is not permissible, then the usual reanalysis and
setting of the <code>METAP</code> flag is performed.</p>
<p>The statistics counter shows that even in a very large program such
as <span class="sc">RABBIT</span> this optimization is performed fewer
than a dozen times. This may be due to my programming style, or because
there are very few macros in the code for <span class="sc">RABBIT</span>
which might expand into foldable code.)</p>
</section>
<section id="rabbit-568-051578-page-21" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 21</a></h4>
<p><a href="#meta-combination-lambda2" id="meta-combination-lambda1"><code>META-COMBINATION-LAMBDA</code></a>
performs several interesting optimizations on combinations of the form
<code>((LAMBDA ...) ...)</code>. It is controlled by several debugging
switches, and keeps several statistics counters, which we will not
describe further.</p>
<div id="subst-candidate4">
<div id="meta-substitute3">
<p>First all the arguments, but not the <code>LAMBDA</code>-expression,
are meta-evaluated by the first <code>DO</code> loop. Next, the body of
the <code>LAMBDA</code> node is meta-evaluated and kept in the variable
<code>B</code> in the second <code>DO</code> loop. This loop iterates
over the <code>LAMBDA</code> variables and the corresponding arguments.
For each variable-argument pair, <a href="#outline"><code>SUBST-CANDIDATE</code></a> determines whether the
argument can “probably” be legally substituted for occurrences of the
variable in the body. If so, <a href="#meta-substitute4"><code>META-SUBSTITUTE</code></a> is called to
attempt such substitution. When the loop finishes, <code>B</code> has
the body with all possible substitutions performed. This body is then
re-meta-evaluated. (The reason for this is explained later in the
discussion of <a href="#meta-substitute4"><code>META-SUBSTITUTE</code></a>.)</p>
</div>
</div>
<p>Next an attempt is made to eliminate <code>LAMBDA</code> variables. A
variable and its corresponding argument may be eliminated if the
variable has no remaining references, and the argument either has no
side effects or has been successfully substituted. (If an argument has
side effects, then <a href="#outline"><code>SUBST-CANDIDATE</code></a>
will give permission to attempt substitution only if no more than one
reference to the corresponding variable exists. If the substitution
fails, then the argument may not be eliminated, because its side effects
must not be lost. If the substitution succeeds, then the argument must
be eliminated, because the side effects must not be duplicated.) A
consistency check ensures that in fact the variable is unreferenced
within the body as determined by its <code>REFS</code> and
<code>ASETS</code> slots; then the argument and variable are deleted,
and the nodes of the argument are erased.</p>
<p>When all possible variable-argument pairs have been eliminated, then
there are two cases. If the <code>LAMBDA</code> has no variables left,
then the combination containing it can be replaced by the body of the
<code>LAMBDA</code> node. In this case the <code>LAMBDA</code> and
<code>COMBINATION</code> nodes are erased. Otherwise the
<code>LAMBDA</code> and <code>COMBINATION</code> nodes are reanalyzed
and their <code>METAP</code> flags are set.</p>
<p>The statistics counters show that when <span class="sc">RABBIT</span>
compiles itself these three optimizations are performed hundreds of
times. This occurs because many standard macros make use of closures to
ensure that variables local to the code for the macro do not conflict
with user variables. These closures often can be substituted into the
code by the compiler and eliminated.)</p>
</section>
<section id="rabbit-568-051578-page-22" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 22</a></h4>
<p><code>(</code><a href="#subst-candidate2" id="subst-candidate1"><code>SUBST-CANDIDATE</code></a>
<code>ARG VAR BOD)</code> is a predicate which is true iff it is
apparently legal to attempt to substitute the argument <code>ARG</code>
for the variable <code>VAR</code> in the body <code>BOD</code>. This
predicate is very conservative, because there is no provision for
backing out of a bad choice. The decision is made on this basis:</p>
<p>[1] There must be no <code>ASET</code> references to the variable.
(This is overly restrictive, but is complicated to check for correctly,
and makes little difference in practice.)</p>
<p>[2] One of three conditions must hold:</p>
<div class="in">
<p>[2a] There is at most one reference to the variable. (Code with
possible side effects must not be duplicated. Exceptions occur, for
example, if there are two references, one in each branch of an If, so
that only one can be executed. This is hard to detect, and relaxing this
restriction is probably not worthwhile.)</p>
<p>[2b] The argument is a constant or variable. (This is always safe
because the cost of a constant or variable is no worse than the cost of
referencing the variable it replaces.)</p>
<p>[2c] The argument is a <code>LAMBDA</code>-expression, and
either:</p>
<div class="in">
<div id="subst-candidate2">
<p>[2c1] There is no more than one reference. (This is tested again
because of the presence of debugging switches in <a href="#subst-candidate3"><code>SUBST-CANDIDATE</code></a> which can
control various tests independently to help localize bugs.)</p>
</div>
<div id="env-analyze5">
<div id="subst-candidate3">
<div id="meta-substitute4">
<p>[2c2] The body of the <code>LAMBDA</code>-expression is a
combination, all of whose descendants are constants or variables, and
the number of arguments of the combination (not counting the function)
does not exceed the number of arguments taken by the
<code>LAMBDA</code>-expression. (The idea here is that substitution of
the <code>LAMBDA</code>-expression into function position of some
combination will later allow reduction to a combination which is no
worse than the original one. This test is a poor heuristic if references
to the variable <code>VAR</code> occur in other than function position
within <code>BOD</code>, because then several closures will be made
instead of one, but is very good for code typically produced by the
expansion of macros. In retrospect, perhaps <a href="#env-analyze6"><code>ENV-ANALYZE</code></a> should maintain a
third property besides <code>READ-REFS</code> and
<code>WRITE-REFS</code> called, say, <code>NON-FN-REFS</code>. This
would be the subset of <code>READ-REFS</code> which occur in other than
function position of a combination. <a href="#subst-candidate4"><code>SUBST-CANDIDATE</code></a> could then use
this information. Alternatively, <a href="#meta-substitute5"><code>META-SUBSTITUTE</code></a> could, as it
walked the node-tree of the body, keep track of whether a variable was
encountered in function position, and refuse to substitute a
<code>LAMBDA</code>-expression for a variable not in such a position
which had more than one reference. This might in turn prevent other
optimizations, however.)</p>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="rabbit-568-051578-page-23" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 23</a></h4>
<div id="env-analyze6">
<div id="triv-analyze3">
<div id="effs-analyze4">
<p><code>REANALYZE1</code> calls <a href="#outline" id="pass1-analyze3"><code>PASS1-ANALYZE</code></a> on the given node.
The argument <code>T</code> means that optimization is in effect, and so
<a href="#effs-analyze5"><code>EFFS-ANALYZE</code></a> must be invoked
after <a href="#env-analyze7"><code>ENV-ANALYZE</code></a> and <a href="#triv-analyze4"><code>TRIV-ANALYZE</code></a> (<a href="#effs-analyze5"><code>EFFS-ANALYZE</code></a> information is used
only by the optimizer). The argument <code>*REANALYZE*</code> specifies
whether reanalysis should be forced to all descendant nodes, or whether
reanalysis of the current node will suffice. This variable normally
contains the symbol <code>ONCE</code>, meaning reanalyze only the
current node. <a href="#meta-evaluate4" id="meta-evaluate3"><code>META-EVALUATE</code></a> normally ensures,
before analyzing a node, that all descendant nodes are analyzed. Thus
the initial pass-1 analysis occurs incrementally, interleaved with the
meta-evaluation process.</p>
</div>
</div>
</div>
<p>The switch <code>*REANALYZE*</code> may be set to the symbol
<code>ALL</code> to force all descendants of a node to be reanalyzed
before analyzing the node itself. This ability is provided to test for
certain bugs in the optimizer. If the incremental analysis should fail
for some reason, then the descendant nodes may not contain correct
information (for example, their information slots may be empty!). The
<code>ALL</code> setting ensures that a consistent analysis is obtained.
If the optimizer’s behavior differs depending on whether
<code>*REANALYZE*</code> contains <code>ONCE</code> or <code>ALL</code>,
then a problem with the incremental analysis is implicated. This switch
has been very useful for isolating such bugs.</p>
<div id="meta-substitute5">
<p>The next group of functions are utilities for <a href="#outline"><code>META-SUBSTITUTE</code></a> which deal with sets of
side-effects.</p>
</div>
<p><code>EFFS-INTERSECT</code> takes the intersection of two sets of
side-effects. It is just like <code>INTERSECT</code>, except that it
also knows about the two special sets <code>ANY</code> and
<code>NONE</code>.</p>
<p><code>EFFECTLESS</code> is a predicate which is true of an empty set
of side-effects.</p>
<p><code>EFFECTLESS-EXCEPT-CONS</code> is a predicate true of a set of
side-effects which is empty except possibly for the <code>CONS</code>
side-effect.</p>
<p><code>PASSABLE</code> takes a node and two sets of side-effects,
which should be the <code>EFFS</code> and <code>AFFD</code> sets from
some other node. <code>PASSABLE</code> is a predicate which is true if
the given node, which originally preceded the second in the standard
evaluation order, can legitimately be postponed until after the second
is evaluated. That is, it is true iff the first node can “pass” the
second during the substitution process.</p>
</section>
<section id="rabbit-568-051578-page-24" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 24</a></h4>
<p><a href="#meta-substitute2" id="meta-substitute1"><code>META-SUBSTITUTE</code></a> takes a node-tree
<code>ARG</code>, a variable name <code>VAR</code>, and another
node-tree <code>BOD</code>, and wherever possible substitutes copies of
<code>ARG</code> for occurrences of <code>VAR</code> within
<code>BOD</code>. The complexity of this process is due almost entirely
to the necessity of determining the extent of “wherever possible”.</p>
<p><a href="#meta-substitute2"><code>META-SUBSTITUTE</code></a> merely
spreads out the <code>EFFS</code> and <code>AFFD</code> slots of
<code>ARG</code> to make them easy to refer to, makes an error check,
and then passes the buck to the internal <code>LABELS</code> routine
<code>SUBSTITUTE</code>, which does the real work.</p>
<p><code>SUBSTITUTE</code> recurs over the structure of the node-tree.
At each node it first checks to see whether <code>VAR</code> is in the
<code>REFS</code> set of that node. This is purely an efficiency hack:
if <code>VAR</code> is not in the set, then it cannot occur anywhere
below that node in the tree, and so <code>SUBSTITUTE</code> can save
itself the work of a complete recursive search of that portion of the
node-tree.</p>
<div id="meta-combination-lambda2">
<div id="meta-evaluate4">
<p><code>SUBSTITUTE</code> plays another efficiency trick in cahoots
with <a href="#meta-evaluate5"><code>META-EVALUATE</code></a> to save
work. Whenever <code>SUBSTITUTE</code> actually replaces an occurrence
of <code>VAR</code> with a copy of <code>ARG</code>, the copy of
<code>ARG</code> will have its <code>METAP</code> flag turned off (set
to <code>NIL</code>). Now <code>SUBSTITUTE</code> propagates the
<code>METAP</code> flag back up the node-tree; when all nodes of a node
have had <code>SUBSTITUTE</code> applied to them, then if the
<code>METAP</code> flag of the current node is still set, it is set to
the <code>AND</code> of the flags of the subnodes. Thus any node below
which a substitution has occurred will have its <code>METAP</code> flag
reset. More to the point, any node which after the substitution still
has its <code>METAP</code> flag set has had no substitutions occur below
it. <a href="#meta-evaluate5"><code>META-EVALUATE</code></a> can then be
applied to <code>BOD</code> after all substitutions have been tried
(this occurs in <a href="#meta-combination-lambda3"><code>META-COMBINATION-LAMBDA</code></a>),
and <a href="#meta-evaluate5"><code>META-EVALUATE</code></a> will only
have to re-examine those parts of <code>BOD</code> which have changed.
In particular, if no substitutions were successful, <a href="#meta-evaluate5"><code>META-EVALUATE</code></a> will not have to
re-examine <code>BOD</code> at all.</p>
</div>
</div>
<p>If the variable is referenced at or below the node, it breaks down
into cases according to the type of the node.</p>
<p>For a <code>CONSTANT</code>, no action is necessary. For a
<code>VARIABLE</code>, no action is taken unless the variable matches
<code>VAR</code>, in which case the node is erased and a copy of
<code>ARG</code> is made and returned in its place. The
<code>SUBSTP</code> slot of the original <code>ARG</code> is set as a
flag to <a href="#meta-combination-lambda3"><code>META-COMBINATION-LAMBDA</code></a>
(q.v.), to let it know that at least one substitution succeeded.</p>
<p>For a <code>LAMBDA</code>, substitution can occur in the body only if
<code>ARG</code> has no side-effects except possibly <code>CONS</code>.
This is because evaluation of the <code>LAMBDA</code>-expression (to
produce a closure) will not necessarily cause evaluation of the
side-effect in <code>ARG</code> at the correct time. The special case of
a <code>LAMBDA</code> occurring as the function in a
<code>COMBINATION</code> is handled separately below.</p>
<p>For an <code>IF</code>, substitution is attempted in the predicate.
It is attempted in the other two sub-trees only if <code>ARG</code> can
pass the predicate.</p>
<p>For an <code>ASET&#39;</code> or a <code>CATCH</code>, substitution is
attempted in the body. The same is true of <code>LABELS</code>, but
substitution is also attempted in the labelled function definitions.</p>
</section>
<section id="rabbit-568-051578-page-24.1" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 24.1</a></h4>
<p>The most complicated case is the <code>COMBINATION</code>. First it
is determined (in the variable <code>X</code>) whether <code>ARG</code>
can correctly pass <strong><em>all</em></strong> of the arguments of the
combination. (It is not possible to substitute into
<strong><em>any</em></strong> argument unless
<strong><em>all</em></strong> can be passed, because at this time it has
not been decided in what order to evaluate them. This decision is the
free choice of <code>CONVERT-COMBINATION</code> below.) If it can, then
substitution is attempted in all of the arguments except the function
itself. Then two kinds of function are distinguished. If it is not a
<code>LAMBDA</code>, a straightforward recursive call to
<code>SUBSTITUTE</code> is used. If it is, then substitution is
attempted in the <strong><em>body</em></strong> of the
<code>LAMBDA</code> (<strong><em>not</em></strong> in the
<code>LAMBDA</code> itself; substitution in a <code>LAMBDA</code>
requires that <code>ARG</code> be <code>EFFECTLESS-EXCEPT-CONS</code>,
but in this special case we know that the <code>LAMBDA</code>-expression
will be invoked immediately, and so it is all right if <code>ARG</code>
has side-effects).</p>
</section>
<section id="rabbit-568-051578-page-25" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 25</a></h4>
<p><code>COPY-CODE</code> is used by <a href="#meta-substitute3" id="meta-substitute2"><code>META-SUBSTITUTE</code></a> to make copies of
node-trees representing code. It invokes <code>COPY-NODES</code> with
appropriate additional arguments.</p>
<div id="alphatize4">
<p><code>COPY-NODES</code> does the real work. The argument
<code>ENV</code> is analogous to the argument <code>ENV</code> taken by
<a href="#alphatize5"><code>ALPHATIZE</code></a>. However, variables are
not looked-up in <code>ENV</code> by <code>COPY-NODES</code>;
<code>ENV</code> is maintained only to install in the new nodes for
debugging purposes. The argument <code>RNL</code> is a “rename list” for
variables. When a node is copied which binds variables, new variables
are created for the copy. <code>RNL</code> provides a mapping from
<strong><em>generated</em></strong> names in the original code to
generated names in the copy (as opposed to <code>ENV</code> which maps
<strong><em>user</em></strong> names to generated names in copy). Thus,
when a <code>LAMBDA</code> node is copied, new names are generated, and
<code>PAIRLIS</code> is used to pair new names with the
<code>LAMBDA</code>\<code>VARS</code> of the old node, adding the new
pairs to <code>RNL</code>.</p>
</div>
<p>A neat trick to aid debugging is that the new names are generated by
using the old names as the arguments to <code>GENTEMP</code>. In this
way the name of a generated variable contains a history of how it was
created. For example, <code>VAR-34-73-156</code> was created by copying
the <code>LAMBDA</code> node which bound <code>VAR-34-73</code>, which
in turn was copied from the node which bound <code>VAR-34</code>. Copies
of <code>CATCH</code> and <code>LABELS</code> variables are generated in
the same way.</p>
<div id="alphatize5">
<p>The large <code>EQCASE</code> handles the different types of nodes.
The result is then given to <code>NODIFY</code>, the same routine which
creates nodes for <a href="#alphatize6"><code>ALPHATIZE</code></a>.
Recall that <code>NODIFY</code> initializes the <code>METAP</code> slot
to NIL; the next meta-evaluation which comes along will cause pass-1
analysis to be performed on the new copies.</p>
</div>
<div id="meta-combination-lambda3">
<p>Note particularly that the <code>UVARS</code> list of a
<code>LAMBDA</code> node is <strong><em>copied</em></strong>, for the
same reason that <code>ALPHA-LAMBDA</code> makes a copy: <a href="#meta-combination-lambda4"><code>META-COMBINATION-LAMBDA</code></a>
may alter it destructively.</p>
</div>
</section>
<section id="rabbit-568-051578-page-26" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 26</a></h4>
<p>The next several functions process the node-tree produced, analyzed,
and optimized by pass 1, converting it to another representation. This
new representation is a tree structure very similar to the node-tree,
but has different components for the pass-2 analysis. We will call this
the “cnode-tree”. The “c” stands for “Continuation-passing style”: for
the conversion process transforms the node-tree into a form which uses
continuation-passing to represent the control and data flow within the
program.</p>
<p>We define a new collection of data types used to construct
code-trees. The <code>CNODE</code> data type is analogous to the
<code>NODE</code> data type; one component <code>CFORM</code> contains a
variant structure which is specific to the programming construct
represented by the <code>CNODE</code>.</p>
<p>The types <code>CVARIABLE</code>, <code>CLAMBDA</code>,
<code>CIF</code>, <code>CASET</code>, <code>CLABELS</code>, and
<code>CCOMBINATION</code> correspond roughly to their non-C counterparts
in pass 1.</p>
<div id="triv-analyze4">
<p>Type <code>TRIVIAL</code> is used to represent pieces of code which
were designated trivial in pass 1 (<code>TRIVP</code> slot =
<code>T</code>) by <a href="#outline"><code>TRIV-ANALYZE</code></a>; the
<code>NODE</code> component is simply the pass-1 node-tree for the
trivial code. This is the only case in which part of the pass-1
node-tree survives the conversion process to be used in pass 2.</p>
</div>
<p>A <code>CONTINUATION</code> is just like a <code>CLAMBDA</code>
except that it has only one bound variable <code>VAR</code>. This
variable can never appear in a <code>CASET</code>, and so the
<code>CONTINUATION</code> type has no <code>ASETVARS</code> slot; all
other slots are similar to those in a <code>CLAMBDA</code>
structure.</p>
<p>A <code>RETURN</code> structure is just like a
<code>CCOMBINATION</code>, except that whereas a
<code>CCOMBINATION</code> may invoke a <code>CLAMBDA</code> which may
take any number of arguments, a <code>RETURN</code> may invoke only a
<code>CONTINUATION</code> on a single value. Thus, in place of the
<code>ARGS</code> slot of a <code>CCOMBINATION</code>, which is a list
of cnodes, a <code>RETURN</code> has two slots <code>CONT</code> and
<code>VAL</code>, each of which is a cnode.</p>
<p>(In retrospect, this was somewhat of a design error. The motivation
was that the world of closures could be dichotomized into
<code>LAMBDA</code>-closures and continuation-closures, as a result of
the fundamental semantics of the language: one world is used to pass
values “down” into functions, and the other to pass values “up” from
functions. Combinations can similarly be dichotimized, and I thought it
would be useful to reflect this distinction in the data types to enforce
and error-check this dichotomy. However, as it turned out, there is a
great deal of code in pass 2 which had to be written twice, once for
each “world”, because the data types involved were different. It would
be better to have a single structure for both <code>CLAMBDA</code> and
<code>CONTINUATION</code>, with an additional slot flagging which kind
it was. Then most code in pass 2 could operate on this structure without
regard for which “world” it belonged to, and code which cared could
check the flag.)</p>
</section>
<section id="rabbit-568-051578-page-27" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 27</a></h4>
<p><code>CNODIFY</code> is for cnode-trees what <code>NODIFY</code> was
for node-trees. It takes a <code>CFORM</code> and wraps a
<code>CNODE</code> structure around it.</p>
<div id="compile5">
<p><a href="#convert2" id="convert1"><code>CONVERT</code></a> is the
main function of the conversion process; it is invoked by <a href="#compile6" id="compile5"><code>COMPILE</code></a> on the result
(<code>META-VERSION</code>) of pass 1. <a href="#convert2"><code>CONVERT</code></a> dispatches on the type of node
to be converted, often calling some specialist which may call it back
recursively to convert subnodes. <code>CONT</code> may be a cnode, or
<code>NIL</code>. If it is a cnode, then that cnode is the code for a
continuation which is to receive as value that produced by the code to
be converted. That is, when <a href="#convert2"><code>CONVERT</code></a>
finishes producing code for the given node (the first argument to <a href="#convert2"><code>CONVERT</code></a>), then in effect a
<code>RETURN</code> is created which causes the value of the generated
code to be returned to the code represented by <code>CONT</code> (the
second argument to <a href="#convert2"><code>CONVERT</code></a>).
Sometimes this <code>RETURN</code> cnode is created explicitly (as for
<code>CONSTANT</code> and <code>VARIABLE</code> nodes), and sometimes
only implicitly, by passing <code>CONT</code> down to a specialist
converter.</p>
</div>
<p><code>MP</code> is <code>T</code> if optimization was performed by
pass 1, and <code>NIL</code> otherwise. This orgument is for debugging
purposes only: <a href="#convert2"><code>CONVERT</code></a> compares
this to the <code>METAP</code> slot of the pass-1 nodes in order to
detect any failures of the incremental optimization and analysis
process. <a href="#convert2"><code>CONVERT</code></a> also makes some
other consistency checks.</p>
</section>
<section id="rabbit-568-051578-page-28" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 28</a></h4>
<p><code>MAKE-RETURN</code> takes a <code>CFORM</code> (one of the types
<code>TRIVIAL</code>, <code>CVARIABLE</code>, …) and a continuation, and
constructs an appropriate returning of the value of the
<code>CFORM</code> to the continuation. First the <code>CFORM</code> is
given to <code>CODIFY</code>. If the continuation is in fact
<code>NIL</code> (meaning none), this new cnode is returned; otherwise a
<code>RETURN</code> cnode is constructed.</p>
<div id="convert2">
<p><code>CONVERT-LAMBDA-FM</code> takes a <code>LAMBDA</code> node and
converts it into a <code>CLAMBDA</code> cnode. The two are isomorphic,
except that an extra variable is introduced as an extra first parameter
to the <code>CLAMBDA</code>. Conceptually, this variable will be bound
to a continuation when the <code>CLAMBDA</code> is invoked at run time;
this continuation is the one intended to receive the value of the body
of the <code>CLAMBDA</code>. This is accomplished by creating a new
variable name <code>CONT-nnn</code>, which is added into the lambda
variables. A new <code>CVARIABLE</code> node is made from it, and given
to <a href="#convert3"><code>CONVERT</code></a> as the continuation when
the body of the <code>LAMBDA</code> node is to be recursively
converted.</p>
</div>
<p>The <code>CNAME</code> argument is used for a special optimization
trick by <code>CONVERT-COMBINATION</code>, described below.</p>
<div id="convert3">
<p><code>CONVERT-IF</code> distinguishes several cases, to simplify the
converted code. First, if the entire <code>IF</code> node is trivial,
then a simple <code>CTRIVIAL</code> node may be created for it.
Otherwise, the general strategy is to generate code which will bind the
given continuation to a variable and evaluate the predicate. This
predicate receives a continuation which will examine the resulting value
(with a <code>CIF</code>), and then perform either the consequent or
alternative, which are converted using the bound variable as the
continuation. The reason that the original continuation is bound to a
variable is because it would be duplicated by using it for two separate
calls to <a href="#outline"><code>CONVERT</code></a>, thereby causing
duplicate code to be generated for it. A schematic picture of the
general strategy is:</p>
</div>
<pre><code>  NODE = (IF a b c)   and   CONT = k   becomes

  ((CLAMBDA (q)
            (RETURN (CONTINUATION (p)
                                  (CIF p
                                       (RETURN q b)
                                       (RETURN q c)))
                    a))
   k)</code></pre>
<p>Now there are two special cases which allow simplification. First, if
the given continuation is already a variable, there is no point in
creating a new one to bind it to. This eliminates the outer
<code>CCOMBINATION</code> and <code>CLAMBDA</code>. Second, if the
predicate a is trivial (but the whole <code>IF</code> is not, because
the consequent <code>b</code> or the alternative <code>c</code> is
non-trivial), then the <code>CONTINUATION</code> which binds
<code>p</code> is unnecessary.</p>
</section>
<section id="rabbit-568-051578-page-29" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 29</a></h4>
<p>This is all done as follows. First <code>CVAR</code> and
<code>PVAR</code> are bound to generated names if necessary,
<code>CVAR</code> for binding the continuation and <code>PVAR</code> for
binding the predicate value. Then <code>ICONT</code> and
<code>IPRED</code> (the “<code>I</code>” is a mnemonic for “internal”)
are bound to the codes to be used for the two conversions of consequent
and alternative, and for the predicate of the <code>CIF</code>,
respectively. <code>CIF</code> is then bound to the cnode for the
<code>CIF</code> code, including the conversions of consequent and
alternative. Finally, using <code>FOO</code> as an intermediary,
<code>CONVERT-IF</code> first conditionally arranges for conversion of a
non-trivial predicate, and then conditionally arranges for the binding
of a non-variable continuation. The result of all this is returned as
the final conversion of the original <code>IF</code> node.</p>
<p><code>CONVERT-ASET</code> is fairly straightforward, except that, as
for <code>IF</code> nodes, a special case is made of trivial nodes, as
determined by the <code>TRIVP</code> slot.</p>
<p>The <code>CATCH</code> construct may be viewed as the user’s one
interface between the “<code>LAMBDA</code> world” and the “continuation
world”. <code>CONVERT-CATCH</code> arranges its conversion in such a way
as to eliminate <code>CATCH</code> entirely. Because
<code>CONTINUATION</code> cnodes provide an explicit representation for
the continuations involved, there is no need at this level to have an
explicit <code>CATCH</code> sort of cnode. The general idea is:</p>
<pre><code>  NODE = (CATCH a b)   and   CONT = k   becomes

  ((CLAMBDA (q)
            ((CLAMBDA (a) (RETURN q b))
             (CLAMBDA (*IGNORE* V) (RETURN q V))))
   k)</code></pre>
<p>In the case where the given continuation <code>k</code> is already a
variable, then it need not be bound to a new one <code>q</code>. Note
that the (renamed) user catch variable <code>a</code> is bound to a
<code>CLAMBDA</code> which ignores its own continuation, and returns the
argument <code>V</code> to the continuation of the <code>CATCH</code>.
Thus the user variable <code>a</code> is bound not to an actual
<code>CONTINUATION</code>, but to a little <code>CLAMBDA</code> which
interfaces properly between the <code>CLAMBDA</code> world and the
<code>CONTINUATION</code> world. The uses of <code>CVAR</code> and
<code>ICONT</code> are analogous to their uses in
<code>CONVERT-IF</code>.</p>
</section>
<section id="rabbit-568-051578-page-30" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 30</a></h4>
<p><code>CONVERT-LABELS</code> simply converts all the labelled function
definitions using <code>NIL</code> as the continuation for each. This
reflects the fact that no code directly receives the results of closing
the definitions; rather, they simply become part of the environment. The
body of the <code>LABELS</code> is converted using the given
continuation.</p>
<p>To make things much simpler for the pass-2 analysis and the code
generator, it is forbidden to use <code>ASET&#39;</code> on a
<code>LABELS</code>-bound variable. This is an arbitrary restriction
imposed by <span class="sc">RABBIT</span> (out of laziness on my part
and a desire to concentrate on more important issues), and not one
inherent in the <span class="sc">SCHEME</span> language. This
restriction is unnoticeable in practice, since one seldom uses
<code>ASET&#39;</code> at all, let alone on a <code>LABELS</code>
variable.</p>
<p><br />
</p>
<p>The conversion of <code>COMBINATION</code> nodes is the most complex
of all cases. First, a trivial combination becomes simply a
<code>TRIVIAL</code> cnode. Otherwise, the overall idea is that each
argument is converted, and the continuation given to the conversion is
the conversion of all the following arguments. The conversion of the
last argument uses a continuation which performs the invocation of
function on arguments, using all the bound variables of the generated
continuations. The end result is a piece of code which evaluates one
argument, binds a variable to the result, evaluates the next, etc., and
finally uses the results to perform a function call.</p>
<p>To simplify the generated code, the arguments are divided into two
classes. One class consists of trivial arguments and
<code>LAMBDA</code>-expressions (this class is precisely the class of
“trivially evaluable” expressions defined in [<a href="#imperative-1-2-3-4-5-6-7-8-9-10-11" id="ximp11" title="[11] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Imperative</a>]),
and the other class consists of the remaining arguments. The successive
conversion using successive continuations as in the general theory is
only performed on the latter class of arguments. The trivially evaluable
expressions are included along with the bound variables for non-trivial
argument values in the final function call. For example, one might have
something like:</p>
<pre><code>  NODE = (FOO (CONS A B) (BAR A) B (BAZ B))   and   CONT = k   becomes

  (RETURN (CONTINUATION (x)
                        (RETURN (CONTINUATION (y)
                                              (FOO k (CONS A B) x B y))
                                (BAZ B)))
          (BAR A))</code></pre>
<p>where <code>FOO</code>, <code>(CONS A B)</code>, and <code>B</code>
are trivial, but <code>(BAR A)</code> and <code>(BAZ B)</code> are
not.</p>
</section>
<section id="rabbit-568-051578-page-31" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 31</a></h4>
<p>The separation into two classes is accomplished by the outer
<code>DO</code> loop. <code>DELAY-FLAGS</code> is a list of flags
describing whether the code can be “delayed” (not converted using
strung-out continuations) because it is trivially evaluable. The inner
<code>DO</code> loop of the three (which loops on variables
<code>A</code>, <code>D</code>, and <code>Z</code>,
<strong><em>not</em></strong> <code>A</code>, <code>D</code>, and
<code>F</code>!) then constructs the final function call, using the
“delayed” arguments and generated continuation variables. The names used
for the variables are the names of the corresponding nodes, which were
generated by <code>NODIFY</code>. Finally, the middle <code>DO</code>
loop (which executes last because the “inner” <code>DO</code> loop
occurs in the initialization, not the body, of the “middle” one)
generates the strung-out continuations, converting the non-delayable
arguments in reverse order, so as to generate the converted result from
the inside out.</p>
<p>The net effect is that non-trivial arguments are evaluated from
left-to- right, and trivial ones are also (as it happens, because of
<span class="sc">MacLISP</span> semantics), but the two classes are
intermixed. This is where <span class="sc">RABBIT</span> takes advantage
of the <span class="sc">SCHEME</span> semantics which decree that
arguments to a combination may be evaluated in any order. It is also why
<code>CHECK-COMBINATION-PEFFS</code> tries to detect infractions of this
rule.</p>
<div id="meta-combination-lambda4">
<p>A special trick is that if the given continuation is a variable, and
the combination is of the form <code>((LAMBDA ...) ...)</code>, then it
is arranged to use the given continuation as the continuation for
converting the body of the <code>LAMBDA</code>, rather than the extra
variable which is introduced for a continuation in the
<code>LAMBDA</code> variables list (see <code>CONVERT-LAMBDA-FM</code>).
This effectively constitutes the optimization of substituting one
continuation variable for another, much as <a href="#meta-combination-lambda5"><code>META-COMBINATION-LAMBDA</code></a>
may substitute one variable for another. (This turns out to be the only
optimization of importance to be done on pass-2 code code; rather than
building a full-blown optimizer for pass-2 cnode-trees, or arranging to
make the optimizer usable on both kinds of data structures, it was
easier to tweak the conversion of combinations.) The substitution is
effected by passing a non-<code>NIL</code> <code>CNAME</code> argument
to <code>CONVERT-LAMBDA-FORM</code>, as computed by the form
<code>(AND (NULL (CDR A)) ...)</code>.</p>
</div>
</section>
<section id="rabbit-568-051578-page-32" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 32</a></h4>
<p>Once the pass-2 cnode-tree is constructed, a pass-2 analysis is
performed in a manner very similar to the pass-1 analysis. As before,
successive routines are called which recursively process the code tree
and pass information up and down, filling in various slots and putting
properties on the property lists of variable names.</p>
<p>The first routine, <a href="#cenv-analyze2" id="cenv-analyze1"><code>CENV-ANALYZE</code></a>, is similar to <a href="#env-analyze8" id="env-analyze7"><code>ENV-ANALYZE</code></a>, but
differs in some important respects. Two slots are filled in for each
cnode. The slot <code>ENV</code> is computed from the top down, while
<code>REFS</code> is computed from the bottom up.</p>
<p><code>ENV</code> is the environment, a list of bound variables
visible to the cnode. The <code>ENV</code> slot in the node-tree was a
mapping (an alist), but this <code>ENV</code> is only a list. The
<strong><em>argument</em></strong> <code>ENV</code> is used in the
analysis of <code>CVARIABLE</code> and <code>CASET</code> nodes. The
cnode <strong><em>slot</em></strong> <code>ENV</code> is included only
for debugging purposes, and is never used by <span class="sc">RABBIT</span> itself.</p>
<p><code>REFS</code> is analogous to the <code>REFS</code> slot of a
node-tree: it is the set of variables bound above and referenced below
the cnode. It differs from the pass-1 analysis in that variables
introduced to name continuations and variables bound by continuations
are also accounted for. In the case of a <code>TRIVIAL</code> cnode,
however, the <code>REFS</code> are precisely those of the contained
node.</p>
<div id="cenv-analyze2">
<div id="bind-analyze5">
<p>The argument <code>FNP</code> to <a href="#cenv-analyze3"><code>CENV-ANALYZE</code></a> <del>in</del> is
non-<code>NIL</code> iff the given code occurs in “functional position”
of a <code>CCOMBINATION</code> or <code>RETURN</code> cnode. This is
used when a variable is encountered; on the property list a
<code>VARIABLE-REFP</code> property is placed iff <code>FNP</code> is
<code>NIL</code>, indicating that the variable was referenced in
“variable (non-function) position”. This information will be used by the
next phase, <a href="#outline"><code>BIND-ANALYZE</code></a>.</p>
</div>
</div>
</section>
<section id="rabbit-568-051578-page-32.1" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 32.1</a></h4>
</section>
<section id="rabbit-568-051578-page-33" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 33</a></h4>
<p>The only purpose of <code>CENV-TRIV-ANALYZE</code> is to go through
the code for a <code>TRIVIAL</code> cnode, looking for variables
occurring in other than function position, in order to put appropriate
<code>VARIABLE-REFP</code> properties. Notice that the types
<code>LAMBDA</code> and <code>LABELS</code> do not occur in the
<code>EQCASE</code> expression, as nodes of those types can never occur
in trivial expressions.</p>
<div id="cenv-analyze3">
<p><code>CENV-COMBINATION-ANALYZE</code> is a simple routine which
analyzes <code>CCOMBINATION</code> cnodes; it is a separate routine only
because it is used in more than one place in <a href="#cenv-analyze4"><code>CENV-ANALYZE</code></a>. It could have been
made a local subroutine by using a <code>LABELS</code> in <a href="#cenv-analyze4"><code>CENV-ANALYZE</code></a>, but I elected not
to do so for purely typographical reasons.</p>
</div>
</section>
<section id="rabbit-568-051578-page-34" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 34</a></h4>
<p>The binding analysis is the most complicated phase of pass 2. It
determines for each function whether or not a closure structure will be
needed for it at run time (and if so, whether the closure structure must
contain a pointer to the code); it determines for each variable whether
or not it can be referred to by a run-time closure structure; and it
determines for each function how arguments will be passed to it (because
for internal functions not apparent to the “outside world” , any
arbitrary argument-passing convention may be adopted by the compiler to
optimize register usage; in particular, arguments which are never
referred to need never even be actually passed). If flow analysis
determines that a given variable always denotes (a closure of) a given
functional (<code>CLAMBDA</code>) expression, then a
<code>KNOWN-FUNCTION</code> property is created to connect the variable
directly to the function for the benefit of the code generator.</p>
<p><a href="#bind-analyze2" id="bind-analyze1"><code>BIND-ANALYZE</code></a> is just a simple
dispatch to one of many specialists, one for each type of
<code>NODE</code>. <code>TRIVIAL</code> and <code>CVARIABLE</code>
cnodes are handled directly because they are simple.</p>
<p>The argument <code>FNP</code> is <code>NIL</code>,
<code>EZCLOSE</code>, or <code>NOCLOSE</code>, depending respectively on
whether a full closure structure, a closure structure without a code
pointer, or no closure structure will be needed if in fact
<code>CNODE</code> turns out to be of type <code>CLAMBDA</code> (or
<code>CONTINUATION</code>). Normally it is <code>NIL</code>, unless
determined otherwise by a parent <code>CLABELS</code> or
<code>CCOMBINATION</code> cnode.</p>
<p>The argument <code>NAME</code> is meaningful only if the
<code>CODE</code> argument is of type <code>CLAMBDA</code> or
<code>CONTINUATION</code>. If non-<code>NIL</code>, it is a suggested
name to use for the cnode. This name will later be used by the code
generator as a tag. The only reason for using the suggestion rather than
a generated name (and in fact one will be generated if the suggested
name is <code>NIL</code>) is to make it easier to trace things while
debugging.</p>
<div id="env-analyze8">
<div id="cenv-analyze4">
<p><code>REFD-VARS</code> is a utility routine. Given a set of
variables, it returns the subset of them that are actually referenced
(as determined by the <code>READ-REFS</code> and <code>WRITE-REFS</code>
properties which were set up by <a href="#env-analyze9"><code>ENV-ANALYZE</code></a> and <a href="#outline"><code>CENV-ANALYZE</code></a>).</p>
</div>
</div>
</section>
<section id="rabbit-568-051578-page-35" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 35</a></h4>
<p>For a <code>CLAMBDA</code> cnode, <code>BIND-ANALYZE-CLAMBDA</code>
first analyzes the body. The <code>CLOVARS</code> component of the code
is then calculated. If the <code>CLAMBDA</code> will have a run-time
closure structure created for it, then any variable it references is
obviously referred to by a closure. Otherwise, only the
<code>CLOVARS</code> of its body are included in the set.</p>
<p>The <code>TVARS</code> component is the set of parameters for which
arguments will be passed in a non-standard manner. Non-standard
argument-passing is used only for <code>NOCLOSE</code>-type functions
(though in principle it could also be used for <code>EZCLOSE</code>-type
functions also). In this case, only referenced variables (as determined
by <code>REFD-VARS</code>) are actually passed. The code generator uses
<code>TVARS</code> for two purposes: when compiling the
<code>CLAMBDA</code> itself, <code>TVARS</code> is used to determine
which arguments are in which registers; and when compiling calls to the
function, <code>TVARS</code> determines which registers to load (see
<code>LAMBDACATE</code>)</p>
<p>The <code>FNP</code> slot is just filled in using the
<code>FNP</code> parameter. If a name was not suggested for the
<code>NAME</code> slot, an arbitrary name is generated.</p>
<p><code>BIND-ANALYZE-CONTINUATION</code> is entirely analogous to
<code>BIND-ANALYZE-CLAMBDA</code>.</p>
<p><code>BIND-ANALYZE-CIF</code> straightforwardly analyzes recursively
its sub-cnodes, and then passes the union of their <code>CLOVARS</code>
up as its own <code>CLOVARS</code>.</p>
<p><code>BIND-ANALYZE-CASET</code> tries to be a little bit clever about
the obscure case produced by code such as:</p>
<pre><code>  (ASET&#39; FOO (LAMBDA ...))</code></pre>
<p>where the continuation is a <code>CONTINUATION</code> cnode (rather
than a <code>CVARIABLE</code>). It is then known that the variable bound
by the <code>CONTINUATION</code> (<strong><em>not</em></strong> the
variable set by the <code>CASET</code>!!) will have as its value the
(closure of the) <code>CLAMBDA</code>-expression. This allows for the
creation of a <code>KNOWN-FUNCTION</code> property, etc. This analysis
is very similar to that performed by <code>BIND-ANALYZE-RETURN</code>
(see below). Aside from this, the analysis of a <code>CASET</code> is
simple; the <code>CLOVARS</code> component is merely the union of the
<code>CLOVAR</code> slots of the sub-cnodes.</p>
</section>
<section id="rabbit-568-051578-page-36" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 36</a></h4>
<p>The binding analysis of a <code>CLABELS</code> is very tricky because
of the possibility of mutually referent functions. For example, suppose
a single <code>CLABELS</code> binds two <code>CLAMBDA</code> expressions
with names <code>FOO</code> and <code>BAR</code>. Suppose that the body
of <code>FOO</code> refers to <code>BAR</code>, and that of
<code>BAR</code> to <code>FOO</code>. Should <code>FOO</code> and
<code>BAR</code> be of <code>FNP</code>-type <code>NIL</code>,
<code>EZCLOSE</code>, or <code>NOCLOSE</code>? If either is of type
<code>EZCLOSE</code>, then the other must be also; but the decision
cannot be made sequentially. It is even more complicated if one must be
of type <code>NIL</code>.</p>
<p>An approximate solution is used here, to prevent having to solve
complicated simultaneous constraints. It is arbitrarily decreed that all
functions of a single <code>CLABELS</code> shall all have the same
<code>FNP</code> type. If any one must be of type <code>NIL</code>, then
they all are. Otherwise, it is tentatively assumed that they all may be
of type <code>NOCLOSE</code>. If this assumption is disproved, then the
analysis is retroactively patched up.</p>
<p>The outer <code>DO</code> loop of <code>BIND-ANALYZE-CLABELS</code>
creates <code>KNOWN-FUNCTION</code> properties, and determines (in the
variable <code>EZ</code>) whether any of the labelled functions needs a
full closure structure. (This can be done before analyzing the
functions, because it is determined entirely by the
<code>VARIABLE-REFP</code> properties created in the previous phase.)
The inner <code>DO</code> loop then analyzes the functions. When this is
done, if <code>EZ</code> is <code>NOCLOSE</code>, and it turns out that
it should have been <code>EZCLOSE</code> after all, then the third
<code>DO</code> loop forcibly patches the <code>CLAMBDA</code> codes for
the labelled functions, and the <code>AMAPC</code> form creates
<code>LABELS-FUNCTION</code> properties as a flag for the code
generator.</p>
<p><code>BIND-ANALYZE-RETURN</code> simply analyzes the continuation and
return value recursively, and then merges to two <code>CLOVARS</code>
sets to produce its own <code>CLOVARS</code> set. A special case is when
the two sub-codes are respectively a <code>CONTINUATION</code> and a
<code>CLAMBDA</code>; then special work is done because it is known that
the variable bound by the <code>CONTINUATION</code> will always denote
the (closure of the) <code>CLAMBDA</code>-expression. A nasty trick is
that if it turns out that the <code>CLAMBDA</code> can be of type
<code>NOCLOSE</code>, then the <code>TVARS</code> slot of the
<code>CONTINUATION</code> is forcibly set to <code>NIL</code> (i.e. the
empty set). This is because no argument will really be passed. (This
fact is also known by the <code>LAMBDACATE</code> routine in the code
generator.)</p>
</section>
<section id="rabbit-568-051578-page-37" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 37</a></h4>
<p><code>BIND-ANALYZE-COMBINATION</code> first analyzes the function
position of the combination. It then distinguishes three cases: a
trivial function, a <code>CLAMBDA</code>-expression function, and all
others.</p>
<p>In the case of a trivial function, the continuation (which is the
second item in <code>ARGS</code>) can be analyzed with
<code>FNP = NOCLOSE</code>, because the compilation will essentially
turn into “calculate all other arguments, apply the trivial function,
and then give the result to the continuation”. A
<code>CCOMBINATION</code> which looks like:</p>
<pre><code>  (a-trivial-function (CONTINUATION (var) ...) arg1 ... argn)</code></pre>
<p>is compiled almost as if it were:</p>
<pre><code>  ((CONTINUATION (var) ... ) (a-trivial-function arg1 ... argn))</code></pre>
<p>and of course the continuation can be treated as of type
<code>NOCLOSE</code>. In the case of a <code>CLAMBDA</code>-expression,
the arguments are all analyzed, and then the <code>AMAPC</code>
expression goes back over the <code>TVARS</code> list of the
<code>CLAMBDA</code>, and removes from the <code>TVARS</code> set each
variable corresponding to an argument which the analysis has proved to
be a <code>NOCLOSE</code>-type <code>KNOWN-FUNCTION</code>. This is
because no actual argument will be passed at run time for such a
function, and so there is no need to allocate a register through which
to pass that argument.</p>
<p>In the third case, the arguments are analyzed straightforwardly by
<code>BIND-COMBINATION-ANALYZE</code>.</p>
<div id="bind-analyze2">
<p><code>BIND-COMBINATION-ANALYZE</code> does the dirty work of
analyzing arguments of a <code>CCOMBINATION</code> and updating the
<code>CLOVARS</code> slot of the <code>CCOMBINATION</code> cnode. If
<code>VARS</code> is non-<code>NIL</code>, then it is the variables of
the <code>CLAMBDA</code>-expression which was in the function position
of the <code>COMBINATION</code>. As the arguments are analyzed,
<code>KNOWN-FUNCTION</code> properties are put on the variables as
appropriate, and the correct value of <code>FNP</code> is determined for
the recursive call to <a href="#bind-analyze3"><code>BIND-ANALYZE</code></a>. If
<code>VARS</code> is <code>NIL</code>, then this code depends on the
fact that <code>(CDR NIL)=NIL</code> in <span class="sc">MacLISP</span>.</p>
</div>
</section>
<section id="rabbit-568-051578-page-38" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 38</a></h4>
<p><a href="#depth-analyze2" id="depth-analyze1"><code>DEPTH-ANALYZE</code></a> allocates registers
through which to pass arguments to <code>NOCLOSE</code> functions,
i.e. for arguments corresponding to elements of <code>TVARS</code> sets.
An unclever stack discipline is used for allocating registers. Each
function is assigned a “depth”, which is zero for a function whose
<code>FNP</code> is <code>NIL</code> or <code>EZCLOSE</code> (such
functions take their arguments in the standard registers
<code>**ONE**</code> through <code>**EIGHT**</code>, assuming that
<code>**NUMBER-OF-ARG-REGS**</code> is 8, as it is in the current <span class="sc">SCHEME</span> implementation). For a <code>NOCLOSE</code>
function the depth is essentially the depth of the function in whose
body the <code>NOCLOSE</code> function appears, plus the number of
<code>TVARS</code> belonging to that other function (if it is of type
<code>NOCLOSE</code>) or the number of standard argument registers used
by it (if it is NIL or <code>EZCLOSE</code>). For example, consider this
code:</p>
<pre><code>  (CLAMBDA (C X Y)
           ((CLAMBDA (K F Z)
                     ((CLAMBDA (Q W V)
                               ...)
                      CONT-57 &#39;3 &#39;4))
            (CONTINUATION (V) ...)
            (CLAMBDA (H) ...)
            &#39;FOO))</code></pre>
<p>Suppose that the outer <code>CLAMBDA</code> is of type
<code>EZCLOSE</code> for some reason. Its depth is 0. The two
<code>CLAMBDA</code>-expressions and <code>CONTINUATION</code>
immediately within it have depth 3 (assuming the
<code>CONTINUATION</code> and second <code>CLAMBDA</code> are of type
<code>NOCLOSE</code> – the first <code>CLAMBDA</code> definitely is).
The innermost <code>CLAMBDA</code> is then of depth 4 (for
<code>Z</code>, which will be in <code>TVARS</code> – <code>K</code> and
<code>F</code> will not be because they are names for
<code>NOCLOSE</code> functions, assuming <code>K</code> and
<code>F</code> have no <code>WRITE-REFS</code> properties).</p>
<div id="depth-analyze2">
<p>To each function is also attached a <code>MAXDEP</code> value, which
is in effect the number of registers used by that function, including
all <code>NOCLOSE</code> functions within it. This is used in only one
place in the code generator, to generate a <code>SPECIAL</code>
declaration for the benefit of the <span class="sc">MacLISP</span>
compiler, which compiles the output of <span class="sc">RABBIT</span>.
For most constructs this is simply the numerical maximum over the depths
of all sub-cnodes. Toward this end the maximum depth of the cnode is
returned as the value of <a href="#depth-analyze3"><code>DEPTH-ANALYZE</code></a>.</p>
</div>
</section>
<section id="rabbit-568-051578-page-39" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 39</a></h4>
<p>Just as <a href="#depth-analyze3"><code>DEPTH-ANALYZE</code></a>
assigns locations in registers (“stack locations”) for variables, so <a href="#close-analyze2" id="close-analyze1"><code>CLOSE-ANALYZE</code></a> assigns locations in
consed (“heap-allocated”) environment structures for variables. The
general idea is that if the value of <del>a</del> an accessible variable
is not in a register, then it is in the structure which is in the
register <code>**ENV**</code>. This structure can in principle be any
structure whatsoever, according to the whim of the compiler. <span class="sc">RABBIT</span>’s whim is to be very unclever; the structure of
<code>**ENV**</code> is always a simple list of variable values. Thus a
variable in the <code>**ENV**</code> structure is always accessed by a
series of <code>CDR</code> operations and then one <code>CAR</code>
operation.</p>
<p>(More clever would be to maintain the environment as a chained list
of vectors, each vector representing a non-null contour. Then a variable
could be accessed by a series of “<code>CDR</code>” operations equal to
the number of contours (rather than the number of variables) between the
binding and the reference, followed by a single indexing operation into
the contour-vector. The number of “<code>CDR</code>™ operations could be
reduced by having a kind of”cache” for the results of such contour
operations; such a cache would in fact be equivalent to the “display”
used in many Algol implementations. If such a display were maintained, a
variable could be accessed simply by a two-level indexing
operation.)</p>
<p>Within the compiler an environment structure is also represented as a
simple list, with the name of a variable occupying the position which
its value will occupy in the run-time environment.</p>
<p>For every <code>CLAMBDA</code>, <code>CONTINUATION</code>, and
<code>CLABELS</code>, a slot called <code>CONSENV</code> is filled in,
which is a list representing what the environment structure will look
like when the closure(s) for that construct are to be constructed, if
any. This is done by walking over the cnode-tree and doing to the
environment representation precisely what will be done to the real
environment at run time.</p>
<p>There is a problem with the possibility that a variable may initially
be in a register (because it was passed as an argument, for example),
but must be transferred to a consed environment structure because the
variable is referred to by the code of a closure to be constructed.
There are two cases: either the variable has no <code>WRITE-REFS</code>
property, or it does.</p>
<p>If it does not, then there is no problem with the value of the
variable being in two or more places, so it is simply copied and consed
into the environment as necessary. The <code>CLOSEREFS</code> slot of a
function is a list of such variables which must be added to the consed
environment before constructing the closure.</p>
<p>If the variable does have <code>WRITE-REFS</code>, then the value of
the variable must have a single “home”, to prevent inconsistencies when
it is altered. (This is far easier than arranging for every
<code>ASET&#39;</code> operation to update all extant copies of a variable’s
value.) It is arranged that such variables, if they are referred to by
closures (are in the <code>CLOVARS</code> set of the
<code>CLAMBDA</code> which binds them) will exist
<strong><em>only</em></strong> in the consed environment. Thus for each
<code>CLAMBDA</code> the <code>ASETVARS</code> set is that subset of the
lambda variables which have <code>WRITE-REFS</code> and are in the
<code>CLOVARS</code> set. Before the body of the <code>CLAMBDA</code> is
executed, a piece of code inserted by the code generator will transfer
the variables from their registers immediately into the consed
environment, and the values in the registers are thereafter never
referred to.</p>
</section>
<section id="rabbit-568-051578-page-40" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 40</a></h4>
<p>For each <code>CLABELS</code> a set called <code>FNENV</code> is
computed. This is strictly an efficiency hack, which attempts to arrange
it such that the several closures constructed for a <code>CLABELS</code>
share environment structure. The union over all the variables needed is
computed, and these variables are, at run time, all consed onto the
environment before any of the closures is constructed. The hope is that
the intersection of these sets is large, so that the total environment
consing is less than if a separate environment were consed for each
labelled closure.</p>
<p><code>FILTER-CLOSEREFS</code> is a utility routine which, given a set
of variables and an environment representation, returns that subset of
the variables which are not already in the environment and so do not
denote known <code>NOCLOSE</code> functions. (Those variables which are
already in the consed environment or which do denote
<code>NOCLOSE</code> functions of course need not be added to that
consed environment.)</p>
<div id="close-analyze2">
<p>The argument <code>CENV</code> to <a href="#close-analyze3"><code>CLOSE-ANALYZE</code></a> is the
representation of the consed environment (in <code>**ENV**</code>) which
will be present when the code for <code>CNODE</code> is executed. The
only processing of interest occurs for <code>CLAMBDA</code>,
<code>CONTINUATION</code>, and <code>CLABELS</code> cnodes.</p>
</div>
<p>The <code>CLOSEREFS</code> of a <code>CLAMBDA</code> are those which
are referred to by the <code>CLAMBDA</code> and which are not already in
<code>CENV</code>, provided the <code>CLAMBDA</code> is not of type
<code>NOCLOSE</code>. The <code>ASETVARS</code> are precisely those
<code>VARS</code> which have <code>WRITE-REFS</code> and are in
<code>CLOVARS</code>.</p>
<p>The processing for a <code>CONTINUATION</code> is similar. As a
consistency check, we make sure the bound variable has no
<code>WRITE-REFS</code> (it should be impossible for an
<code>ASET&#39;</code> to refer to the bound variable of a
<code>CONTINUATION</code>).</p>
<p>For a <code>CLABELS</code>, the <code>FNENV</code> set is first
calculated and added to <code>CENV</code>. This new <code>CENV</code> is
then used to process the definitions and body of the
<code>CLABELS</code>.</p>
</section>
<section id="rabbit-568-051578-page-41" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 41</a></h4>
<p>We now come to the code generator, which is altogether about
one-fourth of all the code making up <span class="sc">RABBIT</span>.
Part of this is because much code which is conceptually singular is
duplicated in several places (partly as a result of design error in
which <code>CCOMBINATION</code> and <code>RETURN</code> nodes, or
<code>CLAMBDA</code> and <code>CONTINUATION</code> nodes, are treated
distinctly; and also because a powerful text editor made it very easy to
make copies of the code for various purposes!). The rest is just because
code generation is fairly tricky and requires checking for special
cases. A certain amount of peephole optimization is performed; this is
not so much to improve the efficiency of the output code, as to make the
output code easier to read for a human debugging <span class="sc">RABBIT</span>. A large fraction of the output code (perhaps
ten to twenty percent) is merely comments of various kinds intended to
help the debugger of <span class="sc">RABBIT</span> figure out what
happened.</p>
<p>One problem in the code generator is that most functions need to be
able to return <strong><em>two</em></strong> things: the code generated
for a given cnode-tree, and a list of functions encountered in the
cnode-tree, for which code is to generated separately later. We solve
this problem by a stylistic trick, namely the explicit use of
continuation-passing style. Many functions in the code generator take an
argument named “<code>C</code>”. This argument is itself a function of
two arguments: the generated code and the deferred-function list. The
function which is given <code>C</code> is expected to compute its two
results and then invoke <code>C</code>, giving it the two results as
arguments. (In practice a function which gets an argument <code>C</code>
also gets an argument <code>FNS</code>, which is a deferred-functions
list; the function is expected to add its deferred functions onto this
list <code>FNS</code>, and give the augmented <code>FNS</code> list to
<code>C</code> along with the generated code.)</p>
<p>Other arguments which are frequently passed within the code generator
are <code>CENV</code> (a representation of the consed environment);
<code>BLOCKFNS</code>, a list describing external functions compiled
together in this “block” or “module” (this is used to compile a direct
<code>GOTO</code> rather than a more expensive call to an external
function, the theory being that several functions might be compiled
together in a single module as with the <span class="sc">InterLISP</span> “block compiler”; this theory is not
presently implemented, however, and so <code>BLOCKFNS</code> always has
just one entry); <code>PROGNAME</code>, a symbol which at run time will
have as its value the <span class="sc">MacLISP</span> <code>SUBR</code>
pointer for the current module (this <code>SUBR</code> pointer is consed
into closures of compiled functions, and so any piece of code which
constructs a closure will need to refer to the value of this symbol);
and <code>RNL</code>, the “rename list”, an alist pairing internal
variable names to pieces of code for accessing them (when code to
reference a variable is to be generated, the piece of code in
<code>RNL</code> is used if the variable is found in RNL, and otherwise
a reference to the variable name itself (which is therefore global) is
output).</p>
<p><a href="#compilate2" id="compilate1"><code>COMPILATE</code></a> is
the topmost routine of the code generator. <code>FN</code> is the
cnode-tree for a function to be compiled. The topmost code should of
course be of type <code>CLAMBDA</code> or <code>CONTINUATION</code>. For
a <code>CLAMBDA</code>, the call to <code>REGSLIST</code> sets up the
initial <code>RNL</code> (rename list) for references to the arguments.
Also, when <code>COMP-BODY</code> has returned the code (the innermost
<code>LAMBDA</code>-expression in <a href="#compilate2"><code>COMPILATE</code></a> is the argument
<code>C</code> given to <code>COMP-BODY)</code>,
<code>SET-UP-ASETVARS</code> is called to take care of copying the
variables in the <code>ASETVARS</code> set into the consed environment.
The code for a <code>CONTINUATION</code> is similar, except that a
<code>CONTINUATION</code> has no <code>ASETVARS</code> and only one
bound variable.</p>
</section>
<section id="rabbit-568-051578-page-42" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 42</a></h4>
<p><code>**ARGUMENT-REGISTERS**</code> is a list of the standard
“registers” through which arguments are passed. In the standard <span class="sc">SCHEME</span> implementation this list is:</p>
<pre><code>  (**ONE** **TWO** **THREE** **FOUR** **FIVE** **SIX** **SEVEN** **EIGHT**)</code></pre>
<p><code>DEPROGNIFY1</code> is a peephole optimizer. It takes a <span class="sc">MacLISP</span> form and returns a <strong>list</strong> of
<span class="sc">MacLISP</span> forms. The idea is that if the given
form is <code>(PROGN ...)</code>, the keyword <code>PROGN</code> is
stripped off; also, any irrelevant computations (references to variables
or constants other than in the final position) are removed.
(<code>ATOMFLUSHP</code>, when <code>NIL</code>, suppresses the removal
of symbols, which in some cases may be <span class="sc">MacLISP</span>
<code>PROG</code> tags). The purpose of this is to avoid multiple
nesting of <code>PROGN</code> forms:</p>
<pre><code>  (PROGN (PROGN a b) (PROGN (PROGN c (PROGN d e) f) g))</code></pre>
<p>Any code generation routine which constructs a <code>PROGN</code>
with a component <code>Q</code> generated by another routine generally
says:</p>
<pre><code>  &quot;(PROGN (SETQ FOO 3) @(DEPROGNIFY Q) (GO ,THE-TAG))</code></pre>
<p>The “@” means that the <strong>list</strong> of forms returned by the
call to <code>DEPROGNIFY</code> (which is actually a macro which expands
into a call to <code>DEPROGNIFY1</code>) is to be substituted into the
list <code>(PROGN ...)</code> being constructed by the ‘<code>&quot;</code>’
operator. Thus rather than the nested <code>PROGN</code> code shown
above, the code generator would instead produce:</p>
<pre><code>  (PROGN a b c d e f g)</code></pre>
<p>which is much easier to read when debugging the output of <span class="sc">RABBIT</span>.</p>
<div id="depth-analyze3">
<p><code>TEMPLOC</code> is a little utility which given the number (in
the <code>DEP</code> ordering used by <a href="#outline"><code>DEPTH-ANALYZE</code></a>) of a register returns
the name of that register. <code>**CONT+ARG-REGS**</code> is the same as
<code>**ARGUMENT-REGISTERS**</code> except that the name
<code>**CONT**</code> is tacked onto the front. <code>**CONT**</code> is
considered to be register 0. If <code>N</code> is greater than the
number of the highest standard argument register, then a new register
name of the form “<code>-N-</code>” is invented. Thus the additional
temporary registers are called <code>-11-</code>, <code>-12-</code>,
<code>-13-</code>, etc.</p>
</div>
</section>
<section id="rabbit-568-051578-page-43" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 43</a></h4>
<p><code>ENVCARCDR</code> takes a set of variables <code>VARS</code>
representing the consed environment, and an old rename list
<code>RNL</code>, and adds to <code>RNL</code> new entries for the
variables, supplying pieces of code to access the environment structure.
For example, suppose <code>RNL</code> were <code>NIL</code>, and
<code>VARS</code> were <code>(A B C)</code>. Then <code>ENVCARCDR</code>
would produce the list:</p>
<pre><code>  ((C . (CAR (CDR (CDR **ENV**))))
   (B . (CAR (CDR **ENV**)))
   (A . (CAR **ENV**)))</code></pre>
<p>where each variable has been paired with a little piece of code which
can be used to access it at run time. This example is not quite correct,
however, because the peephole optimizer <code>DECARCDRATE</code> is
called on the little pieces of code; <code>DECARCDRATE</code> collapses
<code>CAR-CDR</code> chains to make them easier to read, and so the true
result of <code>ENVCARCDR</code> would be:</p>
<pre><code>  ((C . (CADDR **ENV**))
   (B . (CADR **ENV**))
   (A . (CAR **ENV**)))</code></pre>
</section>
<section id="rabbit-568-051578-page-44" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 44</a></h4>
<p><code>REGSLIST</code> takes a <code>CLAMBDA</code> <del>cnode</del>
{{cform}}, a switch <code>AVP</code>, and a rename list
<code>RNL</code>. It tacks onto <code>RNL</code> new entries which
describe how to access the arguments of the <code>CLAMBDA</code>. This
is complicated because there are three cases. (1) A <code>NOCLOSE</code>
function takes its arguments in non-standard registers. (2) Other
functions of not more than <code>**NUMBER-OF-ARGUMENT-REGISTERS**</code>
(the length of the <code>**ARGUMENT-REGISTERS**</code> list) arguments
takes their arguments in the standard registers. (3) All other functions
take a <strong>list</strong> of arguments in the first argument register
(<code>**ONE**</code>), except for the continuation in
<code>**CONT**</code>. The switch <code>AVP</code> tells whether or not
the elements of <code>ASETVARS</code> should be included (non-nil means
do <strong><em>not</em></strong> include).</p>
<p>As an example, suppose the <code>CLAMBDA</code> is a
<code>NOCLOSE</code> with <code>DEP = 12</code> and
<code>TVARS = (A B C D)</code>, and suppose that <code>AVP = T</code>
and <code>RNL = NIL</code>. Then the result would be:</p>
<pre><code>  ((D . -15-) (C . -14-) (B . -13-) (A . -12-))</code></pre>
<p>As another example, suppose the <code>CLAMBDA</code> is of type
<code>EZCLOSE</code> with <code>VARS = (K X Y Z)</code> and
<code>ASETVARS = (Y)</code>, and suppose that <code>AVP =</code>
<del>NIL</del> {{<code>T</code>}} and <code>RNL = ((A . -12-))</code>.
Then the result would be:</p>
<pre><code>  ((Z . **THREE**) (X . **ONE**) (K . **CONT**) (A . -12-))</code></pre>
<p><code>SET-UP-ASETVARS</code> takes a piece of code (the code for a
<code>CLAMBDA</code> body), an <code>ASETVARS</code> set
<code>AV</code>, and a rename list. If there are no
<code>ASETVARS</code>, then just the code is returned, but otherwise a
<code>PROGN</code>-form is returned, which ahead of the code has a
<code>SETQ</code> which adds the <code>ASETVARS</code> to the
environment. (<code>LOOKUPICATE</code> takes a variable and a
<code>RNL</code> and returns a piece of code for referring to that
variable.) For example, suppose we had:</p>
<pre><code>  CODE = (GO FOO)
  AV = (A C)
  RNL = ((C . -14-) (B . -13-) (A . -12-))</code></pre>
<p>Then <code>SET-UP-ASETVARS</code> would return the code:</p>
<pre><code>  (PROGN (SETQ **ENV** (CONS -12- (CONS -14- **ENV**))) (GO FOO))</code></pre>
</section>
<section id="rabbit-568-051578-page-45" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 45</a></h4>
<p>In the continuation-passing style, functions do not return values;
instead, they apply a continuation to the value. Thus, the body of a
<code>CLAMBDA</code>-expression is a form which is not expected to
produce a value. On the other hand, such a form will have subforms which
do produce values, for example references to variables.</p>
<div id="analyze5">
<p>Thus the forms to be dealt with in the code generator can be divided
into those which produce values and those which do not. Initially the
latter will always be attacked, as the body of a “function”; later the
former will be seen. <code>COMP-BODY</code> takes a valueless form and
compiles it. The routine <a href="#analyze6"><code>ANALYZE</code></a>,
which we will see later, handles valued forms.</p>
</div>
<p><a href="#comp-body2" id="comp-body1"><code>COMP-BODY</code></a>
instantiates a by now familiar theme: it simply dispatches on the type
of <code>BODY</code> to some specialist routine. In the case of a
<code>CLABELS</code> it first compiles the body of the
<code>CLABELS</code> (which itself is valueless if the
<code>CLABELS</code> is valueless, and so a recursive call to <a href="#comp-body2"><code>COMP-BODY</code></a> is used), and then goes to
<code>PRODUCE-LABELS</code>. For a <code>CCOMBINATION</code> or
<code>RETURN</code>, it does a three-way (for <code>RETURN</code>,
two-way) sub-dispatch on whether the function is a <code>TRIVFN</code>,
a <code>CLAMBDA</code> (or <code>CONTINUATION</code>), or something
else.</p>
<div id="analyze6">
<p>The <code>PRODUCE</code> series of routines produce code for
valueless forms. <code>PRODUCE-IF</code> calls <a href="#analyze7"><code>ANALYZE</code></a> on the predicate (which will
produce a value), and <a href="#comp-body2"><code>COMP-BODY</code></a>
on the consequent and alternative (which produce no value because the
entire <code>CIF</code> does not). The three pieces of resulting code
are respectively called <code>PRED</code>, <code>CON</code>, and
<code>ALT</code>. These are then given to <code>CONDICATE</code>, which
generates a <span class="sc">MacLISP</span> <code>COND</code> form to be
output.</p>
</div>
</section>
<section id="rabbit-568-051578-page-46" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 46</a></h4>
<p><code>PRODUCE-ASET</code> first calls <a href="#analyze7"><code>ANALYZE</code></a> on the body, which must
produce a value (to be assigned to the <code>CASET</code> variable).
There are then two cases, depending on whether the
<code>CASET\CONT</code> is a <code>CONTINUATION</code> or not.</p>
<div id="comp-body2">
<p>If it is, then the body of the continuation is compiled (using <a href="#comp-body3"><code>COMP-BODY</code></a>), and then
<code>LAMBDACATE</code> is called to generate the invocation of the
continuation. The routine <code>OUTPUT-ASET</code> generates the actual
<span class="sc">MacLISP</span> <code>SETQ</code> (or other construct)
for the <code>CASET</code> variable, using the environment location
provided by <code>LOOKUPICATE</code>. All in all this case is very much
like a <code>RETURN</code> with an explicit <code>CONTINUATION</code>,
except that just before the continuation is invoked a <code>SETQ</code>
is stuck in.</p>
</div>
<div id="analyze7">
<p>If the <code>CASET\CONT</code> is not a <code>CONTINUATION</code>,
then <a href="#analyze8"><code>ANALYZE</code></a> is called on the
<code>CASET\CONT</code>, and then a piece of code is output which sets
<code>**FUN**</code> to the continuation, <code>**ONE**</code> (which is
in the car of <code>**ARGUMENT-REGISTERS**</code>) to the value of the
body (after also setting the <code>CASET</code> variable, using
<code>OUTPUT-ASET</code>), and does <code>(RETURN NIL)</code>, which is
the <span class="sc">SCHEME</span> run-time protocol for invoking a
continuation.</p>
</div>
</section>
<section id="rabbit-568-051578-page-47" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 47</a></h4>
<div id="close-analyze3">
<p><code>PRODUCE-LABELS</code> takes an already-compiled body
<code>LBOD</code>. <code>FNENV-FIX</code> is a (possibly empty) list of
pieces of code which will fix up the consed environment by adding the
variables common to all the closures to be made up (this set was
computed by <a href="#close-analyze4"><code>CLOSE-ANALYZE</code></a> and
put in the <code>FNENV</code> slot of the <code>CLABELS</code>). The
code for this addition is built from the list of variables by
<code>CONS-CLOSEREFS</code>.</p>
</div>
<p>There are then three cases, depending on the type of closures to be
constructed (<code>NOCLOSE</code>, <code>EZCLOSE</code>, or
<code>NIL</code>). Suppose that the <code>CLABELS</code> is:</p>
<pre><code>  (CLABELS ((FOO (LAMBDA ...))
            (BAR (LAMBDA ...)))
           &lt;body&gt;)</code></pre>
<p>Let us see roughly what code is produced for each case.</p>
<p>For a <code>NIL</code> type (full closures), the idea is merely to
create all the closures in standard form (but with a null environment),
add them all to the consed environment, and then go back and clobber the
environment portion of the closures with the new resulting environment,
plus any other variables needed. Now a standard closure looks like
<code>(CBETA &lt;value of progname&gt; &lt;tag&gt; &lt;environment&gt;)</code>.
(At run time the value of the progname will be a <span class="sc">MacLISP</span> <code>SUBR</code> pointer for the module; the
tag identifies the particular routine in the module.) In the
<code>DO</code> loop, <code>FNS</code> accumulates the function
definitions (to be compiled separately later), <code>RP</code>
accumulates <code>RPLACD</code> forms for clobbering the closures, and
<code>CB</code> accumulates constructors of <code>CBETA</code> lists.
For our example, the generated code looks like:</p>
<pre><code>  ((LAMBDA (FOO BAR)
           (SETQ **ENV** (CONS ... (CONS X43 **ENV**) ...))
           (RPLACD (CDDR BAR) (CONS ... (CONS X72 **ENV**) ...))
           (RPLACD (CDDR FOO) (CONS ... (CONS X69 **ENV**) ...))
           &lt;body&gt;)
   (LIST &#39;CBETA ?-453 &#39;FOO-TAG)
   (LIST &#39;CBETA ?-453 &#39;BAR-TAG))</code></pre>
<div id="close-analyze4">
<p>where <code>?-453</code> is the <code>PROGNAME</code> for the module
containing the <code>CLABELS</code>, and <code>FOO-TAG</code> and
<code>BAR-TAG</code> are the tags (whose names will actually look like
<code>FNVAR-91</code>) for <code>FOO</code> and <code>BAR</code>. (Now
in fact <a href="#close-analyze5"><code>CLOSE-ANALYZE</code></a> creates
a null <code>FNENV</code> for type <code>NIL</code>
<code>CLABELS</code>, and so the first <code>SETQ</code> would in fact
not appear. However, the decision as to the form of the
<code>FNENV</code> is only a heuristic, and so
<code>PRODUCE-LABELS</code> is written so as to be prepared for any
possible choice of <code>FNENV</code> and <code>CLOSEREFS</code> of
individual labelled functions. In this way the heuristic in <a href="#close-analyze5"><code>CLOSE-ANALYZE</code></a> can be freely
adjusted without having to change <code>PRODUCE-LABELS</code>.)</p>
</div>
<p>For the <code>EZCLOSE</code> case the “closures” need only contain
environments, not also code pointers. A trick is needed here, however,
to build the circular environment. When adding the labelled functions to
the environment, we must somehow cons in an object; but we want this
object to possibly be the environment itself! What we do instead is to
make up a list of the tag, and later <code>RPLACD</code> this list cell
with the environment. The tag is never used, but is useful for
debugging. This method also makes the code very similar to the
<code>NIL</code> case, the only difference being that the atom
<code>CBETA</code> and the value of the <code>PROGNAME</code> are not
consed onto each closure.</p>
</section>
<section id="rabbit-568-051578-page-48" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 48</a></h4>
<div id="bind-analyze3">
<p>One problem is that these “closures” are not of the same form as
ordinary <code>EZCLOSE</code> closures, which do not have the tag. This
is the purpose of the <code>LABELS-FUNCTION</code> properties which <a href="#bind-analyze4"><code>BIND-ANALYZE</code></a> created; when a call
to an <code>EZCLOSE</code> function is generated, the presence of a
<code>LABELS-FUNCTION</code> property indicates that the “closure”
itself is not the environment, but rather its cdr is. (It would be
possible to do without the cell containing the tag, by instead making up
the environment with values of <code>NIL</code>, then constructing the
“closures” as simple environments, and then going back and clobbering
the <strong>environment</strong> structure with the closure objects,
rather than clobbering the closure objects themselves. The decision not
to do this was rather arbitrary.) The generated code for the
<code>EZCLOSE</code> case thus looks like:</p>
</div>
<pre><code>  ((LAMBDA (FOO BAR)
           (SETQ **ENV** (CONS ... (CONS X43 **ENV**) ...))
           (RPLACD (CDDR BAR) (CONS ... (CONS X72 **ENV**) ...))
           (RPLACD (CDDR FOO) (CONS ... (CONS X69 **ENV**) ...))
           &lt;body&gt;)
   (LIST &#39;FOO-TAG)
   (LIST &#39;BAR-TAG))</code></pre>
<div id="close-analyze5">
<p>In the <code>NOCLOSE</code> case, no closures are made at run time
for the labelled functions, and so the code consists merely of the
<code>FNENV-FIX</code> (which, again, using the current heuristic in <a href="#outline"><code>CLOSE-ANALYZE</code></a> will always be null in
the <code>NOCLOSE</code> case) and the code for the body:</p>
</div>
<pre><code>  (PROGN (SETQ **ENV** (CONS ... (CONS X43 **ENV**) ...)) &lt;body&gt;)</code></pre>
<p>In any case, of course, the labelled functions are added to the
<code>FNS</code> list which is handed back to <code>C</code> for later
compilation.</p>
<div id="comp-body3">
<div id="analyze8">
<p><code>PRODUCE-LAMBDA-COMBINATION</code> generates code for the case
of <code>((CLAMBDA ...) arg1 ... argn)</code>. First a number of
consistency checks are performed, to make sure the pass-2 analysis is
not completely awry. Then code is generated for the body of the
<code>CLAMBDA</code>, Using <a href="#comp-body4"><code>COMP-BODY</code></a>. Then all the arguments,
which are of course expected to produce values, are given to
<code>MAPANALYZE</code>, which will call <a href="#analyze9"><code>ANALYZE</code></a> on each in turn and return a
list of the pieces of generated code (here called <code>ARGS</code> in
the continuation handed to <code>MAPANALYZE</code>). Finally,
<code>LAMBDACATE</code> is called to generate the code for entering the
body after setting up the arguments in an appropriate manner. Notice the
use of <code>SET-UP-ASETVARS</code> to generate any necessary additional
code for adding <code>ASETVARS</code> to the consed environment on
entering the body. (A more complicated compiler would in this situation
add the argument values to the consed environment directly, rather than
first putting them in registers (which is done by
<code>LAMBDACATE</code>) and then moving the registers into the consed
environment (which is done by <code>SET-UP-ASETVARS</code>). To do this,
however, would involve destroying the modular distinction between
<code>LAMBDACATE</code> and <code>SET-UP-ASETVARS</code>. The extra
complications were deemed not worthwhile because in practice the
<code>ASETVARS</code> set is almost always empty anyway.)</p>
</div>
</div>
</section>
<section id="rabbit-568-051578-page-49" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 49</a></h4>
<p><code>PRODUCE-TRIVFN-COMBINATION</code> handles a case like
<code>(CONS continuation arg1 arg2)</code>, i.e. a
<code>CCOMBINATION</code> whose function position contains a
<code>TRIVFN</code>. First all the arguments
(<strong><em>excluding</em></strong> the continuation!) are given to
<code>MAPANALYZE</code>; then a dispatch is made on whether the
continuation is a <code>CONTINUATION</code> or a <code>CVARIABLE</code>,
and one of two specialists is called.</p>
<p><code>PRODUCE-TRIVFN-COMBINATION-CONTINUATION</code> handles a case
like <code>(CONS (CONTINUATION (Z) &lt;body&gt;) arg1 arg2)</code>. The
idea here is to compile it approximately as if it were</p>
<pre><code>((CONTINUATION (Z) &lt;body&gt;) (CONS argl arg2))</code></pre>
<div id="comp-body4">
<p>That is, the arguments are evaluated, the trivial function is given
them to produce a value, and that value is then given to the
continuation. Accordingly, the body of the <code>CONTINUATION</code> is
compiled using <a href="#comp-body5"><code>COMP-BODY</code></a>, and
then <code>LAMBDACATE</code> takes care of setting up the argument (the
fourth argument to <code>LAMBDACATE</code> is a list of the <span class="sc">MacLISP</span> code for invoking the trivial function) and
invoking the body of the (necessarily <code>NOCLOSE</code>)
<code>CONTINUATION</code>.</p>
</div>
</section>
<section id="rabbit-568-051578-page-50" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 50</a></h4>
<div id="analyze9">
<p><code>PRODUCE-TRIVFN-COMBINATION-CVARIABLE</code> handles a case like
<code>(CONS CONT-43 arg1 arg2)</code>, where the continuation for a
trivial function call is a <code>CVARIABLE</code>. In this situation the
continuation is given to <a href="#analyze10"><code>ANALYZE</code></a>
to generate <span class="sc">MacLISP</span> code for referring to it;
there are then two cases, depending on whether the
<code>CVARIABLE</code> has a <code>KNOWN-FUNCTION</code> property. (Note
that before the decision is made, <code>VAL</code> names the piece of
<span class="sc">MacLISP</span> code for calling the trivial function on
the arguments.)</p>
</div>
<p>If the <code>CVARIABLE</code> denotes a <code>KNOWN-FUNCTION</code>,
then it should be possible to invoke it by adjusting the environment,
setting up the arguments in registers, and jumping to the code. First
the environment adjustment is computed; <code>ADJUST-KNOWNFN-CENV</code>
generates a piece of <span class="sc">MacLISP</span> code which will at
run time compute the correct new environment in which the continuation
will expect to run. There are then two subcases, depending on whether
the <code>KNOWN-FUNCTION</code> is of type <code>NOCLOSE</code> or not.
If it is, then <code>LAMBDACATE</code> is used to set up the arguments
in the appropriate registers (the last argument of <code>NIL</code>
indicates that there is no “body”, but rather that the caller of
<code>LAMBDACATE</code> takes the responsibility of jumping to the
code). If it is not, then <code>PSETQIFY</code> is used, because the
value will always go in <code>**ONE**</code> (which is the car of
<code>**ARGUMENT-REGISTERS**</code>). In either case, a <code>GO</code>
is generated to jump to the code (within the current module, of course)
for the continuation.</p>
<p>If the continuation is not a <code>KNOWN-FUNCTION</code>, then the
standard function linkage mechanism is used: the continuation is put
into <code>**FUN**</code>, the value into <code>**ONE**</code>, and then
<code>(RETURN NIL)</code> exits the module to request the <span class="sc">SCHEME</span> run-time interface to invoke the continuation
in whatever manner is appropriate.</p>
</section>
<section id="rabbit-568-051578-page-51" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 51</a></h4>
<p><code>PRODUCE-COMBINATION</code> handles combinations whose function
positions contain neither <code>TRIVFNS</code> nor
<code>CLAMBDA</code>s. All of the arguments, including the function
position itself and the continuation, are given to
<code>MAPANALYZE</code>, resulting in a list <code>FORM</code> of pieces
of <span class="sc">MacLISP</span> code. There are then two cases. If
the function position is a <code>VARIABLE</code> (within a
<code>TRIVIAL</code> - not a <code>CVARIABLE</code>!), then
<code>PRODUCE-COMBINATION-VARIABLE</code> is used. Otherwise code is
generated to use the standard <span class="sc">SCHEME</span> run-time
interface: first set <code>**FUN**</code> to the function, then set up
the arguments in the standard argument registers
(<code>PSETQ-ARGS</code> generates the code for this), then set
<code>**NARGS**</code> to the number of arguments (this does not include
the continuation), and exit the module with
<code>(RETURN NIL)</code>.</p>
<p><code>PRODUCE-COMBINATION-VARIABLE</code> first determines whether
the variable has a <code>KNOWN-FUNCTION</code> property. If so, then the
approach is very much as in <code>TRIVFN-COMBINATION-CVARIABLE</code>:
first the environment adjustment is computed, then either
<code>LAMBDACATE</code> or <code>PSETQ-ARGS-ENV</code> is used to adjust
the environment and set up the arguments, and finally a <code>GO</code>
to the piece of code for the <code>KNOWN-FUNCTION</code> is
generated.</p>
<p>If the variable is not a <code>KNOWN-FUNCTION</code>, then it may
still be in the list <code>BLOCKFNS</code> (which, recall, is a list of
user functions included in this module). If so, the effect on the code
generation strategy is roughly as if it were a
<code>KNOWN-FUNCTION</code>. The environment adjustment is done
differently, but a <code>GO</code> is generated to the piece of code for
the called function.</p>
<p>In any other case, the standard interface is used.
<code>**FUN**</code> is set to the function, the arguments are set up,
<code>**NARGS**</code> is set to the number of arguments, and
<code>(RETURN NIL)</code> exits the module.</p>
</section>
<section id="rabbit-568-051578-page-52" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 52</a></h4>
<p><code>ADJUST-KNOWNFN-CENV</code> computes a piece of code for
adjusting the environment. <code>CENV</code> is the internal
representation (as a list of variable names) of the environment in which
the generated code will be used. <code>VAR</code> is the name of the
variable which names the function to be invoked, and for whose sake the
environment is to be adjusted. <code>VARREF</code> is a piece of <span class="sc">MacLISP</span> code by which the run-time value of
<code>VAR</code> may be accessed. <code>FNP</code> is the
<code>FNP</code> type of the <code>KNOWN-FUNCTION</code> denoted by
<code>VAR</code>. <code>LCENV</code> is the representation of the
environment for the function. Thus, the generated code should compute
<code>LCENV</code> given <code>CENV</code>.</p>
<p>The two easy cases are when <code>LCENV=CENV</code>, in which case
the environment does not change, and when <code>LCENV=NIL</code>, in
which case the run-time environment will also be <code>NIL</code>.
Otherwise it breaks down into three cases on <code>FNP</code>.</p>
<p>For <code>FNP=NOCLOSE</code>, it must be true that <code>LCENV</code>
is some tail of <code>CENV</code>; that is, there is a stack-like
discipline for <code>NOCLOSE</code> functions, and so <code>CENV</code>
was constructed by adding things to <code>LCENV</code>. The piece of
code must therefore consist of some number of <code>CDR</code>
operations on <code>**ENV**</code>. If this operation does not in fact
produce <code>LCENV</code>, then there is an inconsistency in the
compiler.</p>
<p>For <code>FNP=EZCLOSE</code>, then <code>VARREF</code> can be used to
reference the run-time “closure”; this may require a <code>CDR</code>
operation if the function is an <code>EZCLOSE</code>
<code>LABELS-FUNCTION</code> (see <code>PRODUCE-LABELS</code>) .</p>
<p>For <code>FNP=NIL</code>, then <code>VARREF</code> will refer to a
full closure; the <code>CDDDR</code> of this closure is the
environment.</p>
<p><code>PRODUCE-CONTINUATION-RETURN</code> is, <strong><em>mutatis
mutandis</em></strong>, identical to
<code>PRODUCE-LAMBDA-COMBINATION</code>. This is a good example of the
fact that much code was duplicated because of the early design decision
to treat <code>COMBINATION</code> and <code>RETURN</code> as distinct
data types.</p>
</section>
<section id="rabbit-568-051578-page-53" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 53</a></h4>
<p><code>PRODUCE-RETURN</code> and <code>PRODUCE-RETURN-1</code>
together are almost identical to <code>PRODUCE-COMBINATION</code> and
<code>PRODUCE-COMBINATION-VARIABLE</code>, except that the division
between the two parts is different, and the <code>BLOCKFNS</code> trick
is not applicable to <code>RETURN</code>.</p>
<div id="analyze10">
<p><code>PRODUCE-RETURN</code> merely calls <a href="#analyze11"><code>ANALYZE</code></a> on each of the continuation
and the value, and calls <code>PRODUCE-RETURN-1</code>.</p>
</div>
<p><code>PRODUCE-RETURN-1</code> checks to see whether the continuation
is a <code>KNOWN-FUNCTION</code>. If so, the environment adjustment is
computed, and code is generated in a way similar to previous routines.
If not, the standard interface (involving <code>(RETURN NIL)</code>) is
used. Notice the check to see if <code>VAL</code> is in fact
<code>**ONE**</code> (the car of <code>**ARGUMENT-REGISTERS**</code>);
if so, the redundant code <code>(SETQ **ONE** **ONE**)</code> is
suppressed.</p>
</section>
<section id="rabbit-568-051578-page-54" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 54</a></h4>
<p><code>LAMBDACATE</code> generates code for invoking a
<code>NOCLOSE</code> <code>KNOWN-FUNCTION</code>. It arranges for the
arguments to be evaluated and put in the proper registers, and also
performs some optimizations.</p>
<p><code>VARS</code> is a list of the variables which are to be bound.
<code>TVARS</code> is a list of those variables (a subset of
<code>VARS</code>) which will actually be passed through registers, as
specified by the <code>TVARS</code> slot of the <code>CLAMBDA</code> or
<code>CONTINUATION</code>; this is used for a consistency check on the
optimizations of <code>LAMBDACATE</code>. <code>DEP</code> is the
register depth of the function (the <code>DEP</code> slot).
<code>ARGS</code> is a list of pieces of <span class="sc">MacLISP</span>
code which have been generated for the arguments to the function.
<code>REM</code> is a comment (usually one generated by
<code>REMARK-ON</code>) to be included in the generated code for
debugging purposes; this comment typically details the state of the
environment and what variables are being passed through registers at
this point. <code>ENVADJ</code> is a piece of <span class="sc">MacLISP
code</span> (usually generated by <code>ADJUST-KNOWNFN-CENV</code>) to
whose value <code>**ENV**</code> is to be set, to adjust the
environment. <code>BODY</code> may be a <strong>list</strong> of pieces
of <span class="sc">MacLISP</span> code which constitute the body of the
known function, to be executed after the arguments are set up (typically
because of a combination like <code>((LAMBDA ...) ...))</code>, or it
may be <code>NIL</code>, implying that the caller of
<code>LAMBDACATE</code> intends to generate a <code>GO</code> to the
code.</p>
<p><code>LAMBDACATE</code> divides <code>ARGS</code> into three classes:
(1) arguments which are themselves <code>NOCLOSE</code>
<code>KNOWN-FUNCTION</code>s – such arguments actually have no actual
run-time representation as a <span class="sc">MacLISP</span> data
object, and so are not passed at all; (2) arguments whose corresponding
variables are never referenced – these are accumulated in
<code>EFFARGS</code>, a list of arguments to be evaluated for effect
only (presumably the optimizer eliminated those unreferenced arguments
which had no side effects); and (3) arguments whose values are needed
and are to be passed through the registers – these are accumulated in
<code>REALARGS</code>, and the corresponding variables in
<code>REALVARS</code>.</p>
<p>When this loop is done, (the reverse of) <code>REALVARS</code> should
equal <code>TVARS</code>, for it is the set of actually passed
arguments.</p>
<p>The generated code first evaluates all the <code>EFFARGS</code> (if
any), then sets all the proper registers to the <code>REALARGS</code>
(this code is generated by <code>PSETQ-TEMPS</code>), then (after the
remark <code>REM</code>) executes the <code>BODY</code> (which, if
<code>NIL</code>, is empty).</p>
<p>For example, consider generating code for:</p>
<pre><code>  ((LAMBDA (F A B)... (F A)...)
   (LAMBDA (X) ...)
   (CONS X Y)
   (PRINT Z))</code></pre>
<p>where <code>F</code> denotes a <code>NOCLOSE</code>
<code>KNOWN-FUNCTION</code>, and <code>B</code> is never referred to.
Then the call to <code>LAMBDACATE</code> might look like this:</p>
</section>
<section id="rabbit-568-051578-page-55" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 55</a></h4>
<pre><code>  (LAMBDACATE &#39;(F A B)
              &#39;(A)
              12
              &#39;(&lt;illegal&gt; (CONS X43 Y69) (PRINT Z91))
              &lt;remark&gt;
              **ENV**
              &lt;body&gt;)</code></pre>
<p>where <code>&lt;illegal&gt;</code> is an object that should never be
looked at (see <code>ANALYZE-CLAMBDA</code>); <code>X43</code>,
<code>Y69</code>, and <code>Z91</code> are pieces of code which refer to
the variables <code>X</code>, <code>Y</code>, and <code>Z</code>;
<code>&lt;remark&gt;</code> is some remark; the environment adjustment
is assumed to be trivial; and <code>&lt;body&gt;</code> is the code for
the body of the <code>LAMBDA</code>. The generated code would look
something like this:</p>
<pre><code>  (PROGN (PRINT Z91)
         (SETQ -12- (CONS X43 Y69))
         &lt;remark&gt;
         &lt;body&gt;)</code></pre>
<p>Notice that <code>LAMBDACATE</code> explicitly takes advantage of the
fact that the execution of arguments for a combination may be
arbitrarily reordered.</p>
<p>The various <code>PSETQ</code>… routines generate code to perform
parallel <code>SETQ</code>s, i.e. the simultaneous assignment of several
values to several values. The parallel nature is important, because some
of the values may refer to other registers being assigned to, and a
sequential series of assignments might not work.</p>
<p>The main routine here is <code>PSETQIFY</code>, which takes a list of
arguments (pieces of <span class="sc">MacLISP</span> code which will
generate values when executed at run-time) and a list of corresponding
registers. One of two different methods is used depending on the number
of values involved. Method 2 produces better code (this is obvious only
when one understands the properties of the <span class="sc">MacLISP</span> compiler which will compile the <span class="sc">MacLISP</span> code into <span class="sc">PDP-10</span>
machine language). Unfortunately, it happened that when <span class="sc">RABBIT</span> was written there was a bug in the <span class="sc">MacLISP</span> compiler such that it often found itself
unable to compile the code generated by Method 2. Moreover, the primary
maintainer of the <span class="sc">MacLISP</span> compiler was on leave
for a year. For this reason Method 3 was invented, which always works,
but is considerably more expensive in terms of the <span class="sc">PDP-10</span> code produced. (I concerned myself with this
low level of detail only for this routine, because the code it produces
is central to the whole code generator, and so its efficiency is of the
greatest importance.) In order to achieve the best code, I determined
empirically that Method 2 never failed as long as fewer than five values
were involved. I might also add that a Method 1 was once used, which
happened to provoke a different bug in the <span class="sc">MacLISP</span> compiler; Method 2 was invented in an attempt
to circumvent that first bug! Now that the maintainer of the <span class="sc">MacLISP</span> compiler (Jon L White) has returned, it may
soon be possible to remove Method 3 from <span class="sc">RABBIT</span>;
but I think this story serves as an excellent example of pragmatic
engineering to get around immediate obstacles (also known as a
“kludge”).</p>
</section>
<section id="rabbit-568-051578-page-56" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 56</a></h4>
<p>Method 2 essentially uses local <span class="sc">MacLISP</span>
<code>LAMBDA</code> variables to temporarily name the values before
assignment to the registers, while Method 3 uses global variables.
(Method 2 produces better code because the <span class="sc">MacLISP</span> compiler can allocate the local variables on a
stack, one by one, and then pop them off in reverse order into the
“registers”.) Both methods perform two peephole optimizations: (1) If a
value-register pair calls for setting the register to its own contents,
that <code>SETQ</code> is eliminated. (2) If this elimination reduces
the number of <code>SETQ</code>s to zero or one, then <code>NIL</code>
or a single <code>SETQ</code> is produced, rather than the more
complicated and general piece of code.</p>
<p>As examples,
<code>(PSETQIFY &#39;(-12- -12- (CDR -13-)) &#39;(-11- -12- -13-))</code> would
produce:</p>
<pre><code>  ((LAMBDA (Q-43 Q-44)
           (SETQ -13- Q-44)
           (SETQ -11- Q-43))
   -12-
   (CDR -13-))</code></pre>
<p>(note that <code>(SETQ -12- -12-)</code> was eliminated), and</p>
<pre><code>  (PSETQIFY &#39;(-23- -21- -24- -25- -22-) &#39;(-21- -22- -23- -24- -25-))</code></pre>
<p>would produce:</p>
<pre><code>(PROG () (DECLARE (SPECIAL -21--TEMP -22--TEMP -23--TEMP -24--TEMP -25--TEMP)
      (SETQ -25--TEMP -22-)
      (SETQ -24--TEMP -25-)
      (SETQ -23--TEMP -24-)
      (SETQ -22--TEMP -21-)
      (SETQ -21--TEMP -23-)
      (SETQ -25- -25--TEMP)
      (SETQ -24- -24--TEMP)
      (SETQ -23- -23--TEMP)
      (SETQ -22- -22--TEMP)
      (SETQ -21- -21--TEMP))</code></pre>
<p>The only reason for using <code>PROG</code> is so that the
<code>DECLARE</code> form could be included for the benefit of the <span class="sc">MacLISP</span> compiler.</p>
<p>The examples here are slightly incorrect; <code>PSETQIFY</code>
actually produces a <strong>list</strong> of <span class="sc">MacLISP</span> forms, so that when no <code>SETQ</code>s are
produced the resulting <code>NIL</code> is interpreted as no code at
all.</p>
<p>In principle the elimination of redundant <code>SETQ</code>s should
be performed before choosing which method to use, so that there will be
a maximal chance of using the more efficient Method 2. I chose not to
only so that the two methods would remain distinct pieces of code and
thus easily replaceable.</p>
</section>
<section id="rabbit-568-051578-page-57" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 57</a></h4>
<p><code>PSETQ-ARGS</code> is a handy routine which calls
<code>PSETQ-ARGS-ENV</code> with an <code>ENVADJ</code> of
<code>**ENV**</code>, knowing that later the redundant
“<code>(SETQ **ENV** **ENV**)</code>” will be eliminated.</p>
<p><code>PSETQ-ARGS-ENV</code> takes a set of arguments and an
environment adjustment, and arranges to call <code>PSETQIFY</code> so as
to set up the standard argument registers. Recall that how this is done
depends on whether the number of arguments exceeds
<code>**NUMBER-OF-ARG-REGS**</code>; if it does, then a
<strong>list</strong> of the arguments (except the continuation) is
passed in <code>**ONE**</code>. <code>**ENV+CONT+ARG-REGS**</code> is
the same as <code>**ARGUMENT-REGISTERS**</code>, except that both the
names <code>**ENV**</code> and <code>**CONT**</code> are adjoined to the
front. It can be quite critical that <code>**ENV**</code> and the
argument registers be assigned to in parallel, because the computation
of the argument values may well refer to variables in the environment,
whereas the environment adjustment may be taken from a closure residing
in one of the argument registers.</p>
<p><code>PSETQ-TEMPS</code> is similar to <code>PSETQ-ARGS-ENV</code>,
but is used on registers other than the standard argument-passing
registers. It takes <code>ARGS</code> and <code>ENVADJ</code> as before,
but also a depth <code>DEP</code> which is the number of the first
register to be assigned to. <code>TEMPLOC</code> is used to generate the
register names, then <code>**ENV**</code> is tacked on and
<code>PSETQIFY</code> does the real work.</p>
<div id="analyze11">
<p><code>MAPANALYZE</code> is a simple loop which maps over a list of
cnode-trees and calls <a href="#outline"><code>ANALYZE</code></a> on
each. A list of the results returned by <a href="#outline"><code>ANALYZE</code></a> is given to <code>C</code>.
Also, <code>FNS</code> is chained through the calls to <a href="#outline"><code>ANALYZE</code></a>, so that all functions to be
compiled later will have been accumulated properly.</p>
</div>
</section>
<section id="rabbit-568-051578-page-58" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 58</a></h4>
<div id="trivialize2">
<p><a href="#analyze2" id="analyze1"><code>ANALYZE</code></a> is the
routine called to compile a piece of code which is expected to produce a
value. <a href="#analyze2"><code>ANALYZE</code></a> itself is primarily
a dispatch to specialists. For the “simple” case of a “trivial” form, <a href="#outline"><code>TRIVIALIZE</code></a> is used to generate the
code. For the simple case of a <code>VARIABLE</code>, <a href="#analyze2"><code>ANALYZE</code></a> simply uses
<code>LOOKUPICATE</code> to get the code for the variable reference.</p>
</div>
<p><code>ANALYZE-CLAMBDA</code> has three cases based on
<code>FNP</code>. For type <code>NIL</code>, code is generated to create
a full closure of the form
<code>(CBETA &lt;value of progname&gt; &lt;tag&gt; . &lt;environment&gt;)</code>.
<code>CONS-CLOSEREFS</code> generates the code to add the
<code>CLOSEREFS</code> to the existing consed environment for making
this closure. For type <code>EZCLOSE</code>, just the environment part
is created, again using <code>CONS-CLOSEREFS</code>. For type
<code>NOCLOSE</code>, the generated “code” should never be referenced at
all – it is not even passed as an argument as such – and so a little
message to the debugger is returned as the “code”, which of course must
not appear in the final code for the module. For all three cases, the
code for the function is added to the <code>FNS</code> list for later
compilation.</p>
<p><code>ANALYZE-CONTINUATION</code> is essentially identical to
<code>ANALYZE-CLAMBDA</code>.</p>
</section>
<section id="rabbit-568-051578-page-59" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 59</a></h4>
<div id="analyze2">
<p><code>ANALYZE-CIF</code> merely calls <a href="#analyze3"><code>ANALYZE</code></a> recursively on the predicate,
consequent, and alternative, and then uses <code>CONDICATE</code> to
construct a <span class="sc">MacLISP</span> <code>COND</code> form.</p>
</div>
<div id="comp-body5">
<p><code>ANALYZE-CLABELS</code> calls <a href="#analyze3"><code>ANALYZE</code></a> recursively on the body of the
<code>CLABELS</code>, and then calls <code>PRODUCE-LABELS</code> to do
the rest. (Unlike the other <code>PRODUCE-</code> functions,
<code>PRODUCE-LABELS</code> does not depend on generating code which
does not produce a value. It accepts an already-compiled body, and
builds around that the framework for constructing the mutually referent
functions. If the body was compiled using <a href="#outline"><code>COMP-BODY</code></a>, then the code generated by
<code>PRODUCE-LABELS</code> will produce no value; but if the body was
compiled using <a href="#analyze3"><code>ANALYZE</code></a>, then it
will produce a value.)</p>
</div>
</section>
<section id="rabbit-568-051578-page-60" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 60</a></h4>
<div id="analyze3">
<p><code>ANALYZE-CCOMBINATION</code> requires the function to be a
<code>CLAMBDA</code> (for if it were not, then something too complicated
for continuation-passing style is going on). <a href="#analyze4"><code>ANALYZE</code></a> is called on the body of the
<code>CLAMBDA</code>, and then on all the arguments (using
<code>MAPANALYZE</code>); finally <code>LAMBDACATE</code> is used to
generate the code. (<code>LAMBDACATE</code> is much like
<code>PRODUCE-LABELS</code>, in that it is handed a body, and whether
the generated code produces a value depends only on whether the body
does.)</p>
</div>
<p><code>ANALYZE-RETURN</code> is essentially just like
<code>ANALYZE-CCOMBINATION</code>.</p>
</section>
<section id="rabbit-568-051578-page-61" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 61</a></h4>
<p><code>LOOKUPICATE</code> (I make no apology for the choice of the
name of this or any other function; suffice it to say that a function
named <code>LOOKUP</code> already existed in the <span class="sc">SCHEME</span> interpreter) takes a variable name
<code>VAR</code> and a rename list <code>RNL</code>, and returns a piece
of <span class="sc">MacLISP</span> code for referring to that variable.
If an entry is in <code>RNL</code> for the variable, that entry contains
the desired code. Otherwise a global variable reference must be
constructed. This will simply be a reference to the <span class="sc">MacLISP</span> variable, unless it is the name of a
<code>TRIVFN</code>. In this case a <code>GETL</code> form is
constructed. This is a <strong>big kludge</strong> which does not always
work, and is done this way as a result of a rather unclean hack in the
<span class="sc">SCHEME</span> interpreter which interfaces <span class="sc">MacLISP</span> functions with <span class="sc">SCHEME</span>
functions.)</p>
<p><code>CONS-CLOSEREFS</code> constructs a piece of <span class="sc">MacLISP</span> code which will cons onto the value of
<code>**ENV**</code> all the variables in the set
<code>CLOSEREFS</code>. This is a simple 1oop which uses
<code>LOOKUPICATE</code> to generate code, and constructs a chain of
calls to <code>CONS</code>. For example,
<code>(CONS-CLOSEREFS &#39;(A B C) NIL)</code> would produce:</p>
<pre><code>  (CONS A (CONS B (CONS C **ENV**)))</code></pre>
<p>Notice the use of <code>REVERSE</code> to preserve an order assumed
by other routines.</p>
<p><code>OUTPUT-ASET</code> takes two pieces of code:
<code>VARREF</code>, which refers to a variable, and <code>BODY</code>,
which produces a value to be assigned to the variable. From the form of
<code>VARREF</code> a means of assigning to the variable is deduced.
(This implies that <code>OUTPUT-ASET</code> knows about all forms of
code which might possibly be returned by <code>LOOKUPICATE</code> and,
<em>a fortiori</em>, which might appear in a <code>RNL</code>.) For
example, if the reference is <code>(CADR (CDDDDR **ENV**))</code>,
<code>OUTPUT-ASET</code> would generate
<code>(RPLACA (CDR (CDDDDR **ENV**)) &lt;body&gt;)</code>.</p>
</section>
<section id="rabbit-568-051578-page-62" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 62</a></h4>
<p><code>CONDICATE</code> takes the three conponents of an
<code>IF</code> conditional, and constructs a <span class="sc">MacLISP</span> <code>COND</code> form. It also performs a
simple peephole optimization:</p>
<pre><code>  (COND (a b)
        (T (COND (c d) ...)))</code></pre>
<p>becomes:</p>
<pre><code>  (COND (a b) (c d) ...)</code></pre>
<p>Also, <code>DEPROGNIFY</code> is used to take advantage of the fact
that <span class="sc">MacLISP</span> <code>COND</code> clauses are
implicitly <code>PROGN</code> forms. Thus:</p>
<pre><code>  (CONDICATE &#39;(NULL X) &#39;(PROGN (PRINT X) Y) &#39;(COND ((NULL Y) X) (T FOO)))</code></pre>
<p>would produce:</p>
<pre><code>  (COND ((NULL X) (PRINT X) Y) ((NULL Y) X) (T FOO))</code></pre>
<p><code>DECARCDRATE</code> is a peephole optimizer which attempts to
collapse <code>CAR</code>/<code>CDR</code> chains in a piece of <span class="sc">MacLISP</span> code to make it more readable. For
example:</p>
<pre><code>  (CAR (CDR (CDR (CAR (CDR (CAR (CDR (CDR (CDR (CDR X)))))))))</code></pre>
<p>would become:</p>
<pre><code>  (CADDR (CADR (CADDDR (CDR X))))</code></pre>
<p>The arbitrary heuristic is that “<code>A</code>” should appear only
initially in a “<code>C...R</code>” composition.
<code>DECARCDRATE</code> also knows that <span class="sc">MacLISP</span>
ordinarily has defined <code>CAR</code>/<code>CDR</code> compositions up
to four long.</p>
</section>
<section id="rabbit-568-051578-page-63" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 63</a></h4>
<div id="analyze4">
<p><a href="#trivialize2" id="trivialize1"><code>TRIVIALIZE</code></a>
is the version of <a href="#analyze5"><code>ANALYZE</code></a> which
handles trivial forms. Recall that these are represented as pass-1
node-trees rather than as pass-2 cnode-trees. The task of <a href="#trivialize2"><code>TRIVIALIZE</code></a> is to take such a
node-tree and generate value-producing code. Recall that the subforms of
a trivial form must themselves be trivial.</p>
</div>
<p>For a <code>CONSTANT</code>, a quoted copy of the value of the
constant is generated.</p>
<p>For a <code>VARIABLE</code>, a reference to the variable is generated
using <code>LOOKUPICATE</code>.</p>
<p>For an <code>IF</code>, the components are recursively given to <a href="#trivialize2"><code>TRIVIALIZE</code></a> and then
<code>CONDICATE</code> is used to generate a <span class="sc">MacLISP</span> <code>COND</code> form.</p>
<p>For an <code>ASET</code>, a reference to the <code>ASET</code>
variable is generated using <code>LOOKUPICATE</code>, and code for the
body is generated by calling <a href="#trivialize2"><code>TRIVIALIZE</code></a> recursively; then
<code>OUTPUT-ASET</code> generates the code for the
<code>ASET</code>.</p>
<p>For a <code>COMBINATION</code>, the function must be either a
<code>TRIVFN</code> or a <code>LAMBDA</code>-expression. For the former,
a simple <span class="sc">MacLISP</span> function call is generated,
after generating code for all the arguments. For the latter,
<code>TRIV-LAMBDACATE</code> is invoked after generating code for the
arguments and the <code>LAMBDA</code> body.</p>
<p><code>TRIV-LAMBDACATE</code> is, so to speak, a trivial version of
<code>LAMBDACATE</code>. The arguments are divided into two classes,
those which are referenced and those which are not (the possibility of a
referenced argument which is a <code>KNOWN-FUNCTION</code> cannot
arise). When this is done, a <span class="sc">MacLISP</span>
<code>((LAMBDA ... ...)</code> form is generated, preceded by any
unreferenced arguments (which presumably have side-effects). For
example:</p>
<pre><code>  (TRIV-LAMBDACATE &#39;(V1 V2 V3)
                   &#39;((CAR X) (PRINT Y) (CDR Z))
                   &#39;(PROGN (PRINT V1) (LIST V1 V3)))</code></pre>
<p>ought to produce:</p>
<pre><code>  (PROGN (PRINT Y)
         ((LAMBDA (V1 V3)
                  (COMMENT (VARS = (A C)))
                  (PRINT V1)
                  (LIST V1 V3))
          (CAR X)
          (CDR Z)))</code></pre>
<p>Note that a <span class="sc">MacLISP</span> <code>LAMBDA</code> body
is an implicit <code>PROGN</code>. <code>TRIV-LAMBDACATE</code> also
takes advantage of the ability to arbitrarily reorder the execution of
arguments to a combination.</p>
</section>
<section id="rabbit-568-051578-page-64" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 64</a></h4>
<div id="compile6">
<p>We have examined the entire code generator, and now turn to
high-level control routines. <a href="#outline" id="compilate-one-function1"><code>COMPILATE-ONE-FUNCTION</code></a> is
the highest-level entry to the code generator, called by <a href="#compile7" id="compile6"><code>COMPILE</code></a>. It takes a
code-tree and the user-name for the function, and returns a complete
piece of <span class="sc">MacLISP</span> code constituting a module for
the user function. It generates a global name for use as the module name
(<code>PROGNAME</code>), and invokes <code>COMPILATE-LOOP</code> (which
really ought to have been a <code>LABELS</code> function, but was too
big to fit on the paper that way). The last argument is a list of two
<span class="sc">MacLISP</span> forms; one causes a <span class="sc">SCHEME</span> compiled closure form (a <code>CBETA</code>
list) to be put in the value cell of the user-name, so that it will be a
globally defined <span class="sc">SCHEME</span> function, and the other
creates a property linking the <code>PROGNAME</code> with the
<code>USERNAME</code> for debugging purposes.</p>
</div>
<div id="compilate2">
<p><code>COMPILATE-LOOP</code> repeatedly calls <a href="#outline"><code>COMPILATE</code></a>, giving it the next function
on the <code>FNS</code> list. Of course, the invocation of <a href="#outline"><code>COMPILATE</code></a> may cause new entries to
appear on the <code>FNS</code> list. <code>COMPILATE-LOOP</code>
iterates until the <code>FNS</code> list converges to emptiness. As it
does so it takes each piece of generated code and strings it together as
<code>PROGBODY</code>. It also calculates in <code>TMAX</code> the
maximum over all <code>MAXDEP</code> slots; this is the only place where
the <code>MAXDEP</code> slot is ever used.</p>
</div>
<p>When <code>FNS</code> is exhausted, a module is constructed. This
contains a comment, a <span class="sc">MacLISP</span> <code>DEFUN</code>
form for defining a <span class="sc">MacLISP</span> function, a
<code>SETQ</code> form to put the <code>SUBR</code> pointer in the value
cell of the <code>PROGNAME</code> (for the benefit of code which creates
<code>CBETA</code> forms), and extra “stuff”. <code>TMAX</code> is used
to generate a list of all temporary variables used in the module; a
<span class="sc">MacLISP</span> <code>SPECIAL</code> declaration is
created to advise the <span class="sc">MacLISP</span> compiler.</p>
<p><code>USED-TEMPLOCS</code> takes a <code>TMAX</code> value and
generates the names of all temporary registers (whose names are of the
form <code>-nn-</code>; standard argument registers are not included) up
to that number.</p>
</section>
<section id="rabbit-568-051578-page-65" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 65</a></h4>
<p><code>REMARK-ON</code> takes a code for a <code>CLAMBDA</code> or
<code>CONTINUATION</code> and generates a comment containing pertinent
information about invoking that function. This comment will presumably
be inserted in the output code to guide the debugging process.</p>
<p><code>MAP-USER-NAMES</code> takes a list of internal variable names
and returns a list of the corresponding user names for the variables, as
determined by the <code>USER-NAME</code> property. (If a variable is an
internally generated one, e.g. for a continuation, then it will have no
<code>USER-NAME</code> property, and the internal name itself is
used.)</p>
</section>
<section id="rabbit-568-051578-page-66" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 66</a></h4>
<p>The next few pages contain routines which deal with files. <a href="#outline" id="comfile1"><code>COMFILE</code></a> takes a file
name, and compiles all the code in that file, producing an output file
of <span class="sc">MacLISP</span> code suitable for giving to the <span class="sc">MacLISP</span> compiler. It also computes the CPU time
required to compile the file.</p>
<p><code>FN</code> gets the given file name, processed and defaulted
according to <span class="sc">ITS/MacLISP</span> standard conventions.
<code>RT</code> and <code>GCT</code> save runtime and gc-runtime
information.</p>
<p><code>IFILE</code> and <code>OFILE</code> get <span class="sc">MacLISP</span> “file objects” created by the
<code>OPEN</code> function, which opens the file specified by its first
argument. (The output file names are initially
“ <code>RABB  OUTPUT</code>”, conforming to an <span class="sc">ITS</span> standard. These will later be renamed.)</p>
<p><code>*GLOBAL-GEN-PREFIX*</code> is initialized as a function of the
file name, to “<code>directory=firstname</code>”. This is to guarantee
that the global symbols generated for two different compiled files of
<span class="sc">SCHEME</span> code will not conflict should the two
files be loaded into the same <span class="sc">SCHEME</span> together.
(Notice the use of <code>SYMEVAL</code>. This is necessary because <span class="sc">MacLISP</span> allows names to be used in two different kinds
contexts, one meaning the “functional” value, and the other meaning the
“variable” value. <span class="sc">SCHEME</span> does not make this
distinction, and tries to make the functional value available, but does
not do this consistently. This is a problem which results from a
fundamental difference in semantics between <span class="sc">SCHEME</span> and <span class="sc">MacLISP</span>. For such
variables as <code>DEFAULT</code> and <code>TYO</code>, which in <span class="sc">MacLISP</span> are used for both purposes, it is necessary to
use <code>SYMEVAL</code> to specify that the variable, rather than the
function, is desired.)</p>
<p><code>(SYMEVAL &#39;TYO)</code> refers to the file object for the
terminal; this is used to print out messages to the user while the file
is being compiled. Various information is also printed to the file,
including identification and timestamp. The <code>DECLARE</code> form
printed to the output file contains the names of the standard argument
registers, and also <code>**ENV**</code>, <code>**FUN**</code>, and
<code>**NARGS**</code>. (This is why <code>USED-TEMPLOCS</code> need not
generate names of standard argument registers – this single global
declaration covers them.) The second <code>DECLARE</code> form defines
to the <span class="sc">MacLISP</span> compiler a function called
<code>DISPLACE</code> for obscure reasons having to do with the
implementation of <span class="sc">SCHEME</span> macros.</p>
<p><a href="#transduce2" id="transduce1"><code>TRANSDUCE</code></a> does
the primary work of processing the input file. When it is done, another
timestamp is printed to the output file, so that the real time consumed
can be determined; then the runtime statistics are calculated and
printed, along with the number of errors if any occurred. The output
file is then renamed as “<code>firstname LISP</code>” and closed. The
statistics message is returned so that it will be printed as the last
message on the terminal.</p>
</section>
<section id="rabbit-568-051578-page-67" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 67</a></h4>
<p><a href="#transduce2"><code>TRANSDUCE</code></a> processes forms from
<code>IFILE</code>, one by one, calling <a href="#outline" id="process-form4"><code>PROCESS-FORM</code></a> to do the real work on
each one. <a href="#outline"><code>PROCESS-FORM</code></a> may print
results on <code>OFILE</code>, and may also return a list of “random
forms” to be saved.</p>
<p>The business of “random forms” has to do with the fact that the file
being compiled may contains forms which are not function definitions.
The expectation is that when the file is loaded these forms will be
evaluated during the loading process, and this is indeed true if the
interpreter loads the original file of source forms.</p>
<p>Now <span class="sc">MacLISP</span> provides a facility for
evaluating random forms within a compiled file, but they are evaluated
as <span class="sc"><em>MacLISP</em></span> forms, not <span class="sc"><em>SCHEME</em></span> forms. To get around this whole
problem, I chose another solution. All the random forms in the file are
accumulated, and then compiled as the body of a function named
“<code>INIT-firstname</code>” In this way, once the compiled code is
loaded, the user is expected to say <code>(INIT-firstname)</code> to
cause the random forms to be evaluated.</p>
<p>This idea would have worked perfectly except that files typically
have a large number of random forms in them (macro definitions create
one or two random forms as well as the definition of the
macro-function). Putting all the random forms together in a single
function often creates a function too big for <span class="sc">RABBIT</span> to compile, given <span class="sc">PDP-10</span> memory limitiations. The four lines of code in
<a href="#transduce3" id="transduce2"><code>TRANSDUCE</code></a> for
this have therefore been commented out with a “<code>;</code>” at the
beginning of each line.</p>
<p>The final solution was to compile each random form as its own
function, and arrange for all these little functions to be chained; each
one executes one random form and then calls the next. A call to
<code>INIT-firstname</code> starts the chain going.</p>
<div id="process-form2">
<p>This, then, is the purpose of the big <code>DO</code> loop in <a href="#transduce3"><code>TRANSDUCE</code></a>: to construct all the
little functions for the random forms. The third argument to <a href="#process-form3"><code>PROCESS-FORM</code></a> may be
<code>NIL</code>, which suppresses the printing of any messages on the
terminal; this spares the user having to see tens or hundreds of
uninteresting messages concerning the compilation of these
initialization functions. However, so that the user will not be dismayed
at the long pause, a message saying how many random forms there were is
printed first.</p>
</div>
<p><code>READIFY</code> implements the <span class="sc">MacLISP</span>
convention that if the value of the <em>variable</em> <code>READ</code>
is non-nil, then that value is the read-in function to use; while if it
is <code>NIL</code>, then the <em>function</em> <code>READ</code> is the
read-in function. (This “hook” is the method by which <span class="sc">CGOL</span> works, for example.)</p>
</section>
<section id="rabbit-568-051578-page-68" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 68</a></h4>
<p><a href="#process-form2" id="process-form1"><code>PROCESS-FORM</code></a> takes a form, an output
file, and a switch saying whether to be “noisy”. The form is broken down
into one of many special cases and processed accordingly. The returned
value is a list of “random forms” for <a href="#transduce4" id="transduce3"><code>TRANSDUCE</code></a> to save for later
handling.</p>
<p>An atom, while pretty useless, is transduced directly to the output
file.</p>
<p>A <code>DEFINE</code>-form, which defined a function to be compiled,
is given to <code>PROCESS-DEFINE-FORM</code>. This is the interesting
case, which we will discuss on the next page.</p>
<p>A special hack handed down from <span class="sc">MacLISP</span> is
that a form <code>(PROGN &#39;COMPILE ...)</code> (and, for <span class="sc">SCHEME</span>, the analogous
<code>(BLOCK &#39;COMPILE ...)</code>) should be treated as if all the
subforms of the <code>PROGN</code> (or <code>BLOCK</code>) after the
first should be processed as if they had been read as “top-level” forms
from the file. This allows a macro call to generate more than one form
to be compiled, for example. It is necessary to accumulate all the
results of the calls to <a href="#process-form4" id="process-form3"><code>PROCESS-FORM</code></a> so that they may be
collectively returned.</p>
<p>A <code>PROCLAIM</code> form contains a set of forms to be evaluated
by <span class="sc">RABBIT</span> at compile time. The evaluation is
accomplished by constructing a <code>LAMBDA</code> form and using the
<span class="sc">SCHEME</span> primitive <code>ENCLOSE</code> to create
a closure, and then invoking the closure. As a special service, the
variable <code>OFILE</code> is made apparent to the evaluated form so
that it can print information to the output file if desired.</p>
<p>A <code>DECLARE</code> form is meant to be seen by the <span class="sc">MacLISP</span> compiler, and so it is passed on directly.</p>
<p>A <code>COMMENT</code> form is simply eliminated. (It could be passed
through directly with no harm.)</p>
<p>A <code>DEFUN</code> form is passed directly, for compilation by the
<span class="sc">MacLISP</span> compiler.</p>
<p>A form which is a macro call is expanded and re-processed. As a
special hack, those which are calls to <code>DEFMAC</code>,
<code>SCHMAC</code>, or <code>MACRO</code> are also evaluated (<span class="sc">MacLISP</span> evaluation serves), so that the defined macro
will be available for compiling calls to it later in the file.</p>
<p>Any other form is considered “random”, and is returned to <a href="#outline" id="transduce4"><code>TRANSDUCE</code></a>
<em>provided</em> <code>*BUFFER-RANDOM-FORMS*</code> is
non-<code>NIL</code>. This switch is provided in case it is necessary to
force a random form (e.g. an <code>ALLOC</code> form) to be output early
in the file. In this case any random forms must be <span class="sc">MacLISP</span>-evaluable as well as <span class="sc">SCHEME</span>-evaluable. (This requirement is the reason
<span class="sc">RABBIT</span> has random forms like
“<code>(SET&#39; FOO ...)</code>”; <code>SETQ</code> is unacceptable to
<span class="sc">SCHEME</span>, while <code>ASET&#39;</code> is unacceptable
to <span class="sc">MacLISP</span>, but <code>SET&#39;</code> happens to
work in both languages for setting a global variable.) <span class="sc">RABBIT</span> itself sets <code>*BUFFER-RANDOM-FORMS*</code>
to <code>NIL</code> on page 1 in a <code>PROCLAIM</code> form.</p>
</section>
<section id="rabbit-568-051578-page-69" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 69</a></h4>
<p><code>PROCESS-DEFINE-FORM</code> disambiguates the three
<code>DEFINE</code> formats permitted in <span class="sc">SCHEME</span>:</p>
<pre><code>  (DEFINE FOO (LAMBDA (X Y) ...))
  (DEFINE FOO (X Y) ...)
  (DEFINE (FOO X Y) ...)</code></pre>
<p>and constructs an appropriate <code>LAMBDA</code>-expression in
standard form.</p>
<p><code>PROCESS-DEFINITION</code> takes this
<code>LAMBDA</code>-expression and compiles it, after some error checks.
It then cleans up, and if desired prints a message on the console to the
effect that the function was compiled successfully.</p>
<p><code>CLEANUP</code> is used to clear out garbage left around by the
compilation process which is no longer needed (but is useful during the
compilation, whether for compilation proper or only for debugging should
the compilation process fail).</p>
<p><code>REPLACE</code> has to do with macros which displace calls to
them with the expanded forms, but retain enough information to undo
this. <code>REPLACE</code> undoes this and throws away the saved
information. (The <code>DISPLACE</code> facility is normally turned off
anyway, and is used only to make the compiler run faster when it itself
is being run under the <span class="sc">SCHEME</span> interpreter. This
was of great use when <span class="sc">RABBIT</span> wasn’t running well
enough to compile itself!)</p>
<p><code>GENFLUSH</code> removes from the <span class="sc">MacLISP</span> <code>OBARRAY</code> all the temporary
generated symbols created by <code>GENTEMP</code>.</p>
<p>The <code>MAPATOMS</code> form removes from every atom on the
<code>OBARRAY</code> the properties shown. This takes more time but less
space than recording exactly which atoms had such properties created for
them.</p>
</section>
<section id="rabbit-568-051578-page-70" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 70</a></h4>
<p><code>SEXPRFY</code> and <code>CSEXPRFY</code> are debugging aids
which take a node-tree or cnode-tree and produce a fairly readable
S-expression version of the code it represents. They are used by the
<code>SX</code> and <code>CSX</code> macros defined earlier. The
<code>USERP</code> switch for <code>SEXPRFY</code> specifies whether
internal variables names or user variable names should be used in the
construction.</p>
</section>
<section id="rabbit-568-051578-page-71" class="level4">
<h4><a href="#outline" title="Go to module outline"><span class="sc">RABBIT</span> 568 05/15/78 Page 71</a></h4>
<p><code>CHECK-NUMBER-OF-ARGS</code> is used by <a href="#outline" id="compile7"><code>COMPILE</code></a> and
<code>ALPHA-COMBINATION</code> to make sure that function calls and
definitions agree on the number of arguments taken by a function. If a
mismatch is detacted, a warning is issued. This check frequently catches
various typographical errors. The argument <code>DEFP</code> is
<code>NIL</code> unless this call is on behalf of a definition rather
than a call. The <code>DEFINED</code> property is used only so that a
more comprehensive warning may be given.</p>
<p><code>*EXPR</code> and <code>*LEXPR</code> are two special forms
suitable for use in a <code>PROCLAIM</code> form for declaring that
certain names refer to <span class="sc">MacLISP</span> functions rather
than <span class="sc">SCHEME</span> functions. An example, for
<code>PRINT-SHORT</code>, occurs on page 1 of <span class="sc">RABBIT</span>.</p>
<p><code>DUMPIT</code> establishes a simple user interface for <span class="sc">RABBIT</span>. After loading a compiled <span class="sc">RABBIT</span> into a <span class="sc">SCHEME</span> run-time
system, the call <code>(DUMPIT)</code> initializes the <span class="sc">RABBIT</span>, then suspends the <span class="sc">MacLISP</span> environment, with an argument which is an
<span class="sc">ITS</span> command for dumping the core image. When
this core image is later loaded and resumed, <code>DUMPIT</code> prints
“<code>FILE NAME:</code>” and reads a line. All the user need do is type
a file name and a carriage return to compile the file. When this is done
the call to <code>QUIT</code> kills the <span class="sc">RABBIT</span>
job.</p>
<p><code>STATS</code> prints out statistics accumulated in the counters
listed in <code>*STAT-VARS*</code>. <code>RESET-STATS</code> resets all
the counters.</p>
</section>
</section>
</body>
</html>
