<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Guy Lewis Steele Jr" />
  <meta name="keywords" content="LISP, SCHEME, continuation
passing, tail recursion, lexical scoping, macros" />
  <title>Guy L Steele Jr – Compiler Optimization</title>
  <style>
html {
font-size: 12pt;
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 36em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: blue;
}
a:visited {
color: blue;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
background-color: #1a1a1a;
border: none;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
</style>
  <style>
code {
font-family: Greybeard, Menlo, Monaco, Consolas, "Lucida Console", monospace }
body {
font-family: Bodoni, serif;
text-wrap: pretty;
max-width: 40em;
padding-right: 30px;
overflow-wrap: normal;
line-height: 1.2;
hyphens: none }
h1, h2 {
font-size: 1.2em;
margin-top: 1.0em }
h4 { margin-top: 0.85em;
margin-bottom: 0;
padding-bottom: 0 }
h4 + p {
margin-top: 0;
margin-bottom: 0.85em }
#notes p, #references p, #bibliography p {
margin-top: 0 }
hr {
margin-top: 3em }
dd {
margin-bottom: 0.85em }
pre code { 
text-wrap: nowrap;
overflow-x: scroll;
font-size: 75% }
p code, .line-block code, figcaption code, h3 code, dt code { 
font-size: 85% }
code em {
font-style: italic } 
.large {
font-size: 150% }
.small {
font-size: 80% }
.sc { 
font-size: 92% }
.in {
margin-left: 1em }
.in5 {
margin-left: 5em }
.ti {
text-indent: -1em;
padding-left: 1em;
margin-top: -0.85em }
.ti5 {
text-indent: -5em;
padding-left: 5em;
margin-top: -0.85em }
div.ti2 p {
text-indent: -2em;
padding-left: 2em;
margin-top: -0.85em }
.fr {
float: right }
.fwn {
font-weight: normal }
li::marker {
content: '(' counters(list-item) ') '; }
div.box {
padding: 0 0 0.5em 1em;
border: 1px solid }
figure {
margin: 1em 0;
width: 100% }
figcaption {
padding-top: 1em;
text-align: center }
a:hover {
text-decoration: underline }
a:any-link {
color: AccentColor }
.lh1 {
line-height: 0.7;
font-size: 0.7em }
:root {
background-color: color-mix(in oklab, Canvas 85%, #808080 15%);
color: color-mix(in oklab, CanvasText 85%, #808080 15%);
color-scheme: light dark; }
@media print {
hr {
break-before: always;
page-break-before: always }
div.box, div.npb, section.npb, pre {
break-inside: avoid-page;
page-break-inside: avoid }
body {
padding-top: 25px;
padding-bottom: 25px }
}
</style>
</head>
<body>
<div class="box">
<p><em>RABBIT: A Compiler for SCHEME</em> [<a href="#steele-1978" id="xsteele-1978" title="RABBIT: A Compiler for SCHEME (A Dialect of LISP) A Study in Compiler Optimization Based on Viewing LAMBDA as RENAME and PROCEDURE CALL as GOTO using the techniques of Macro Definition of Control and Environment Structures Source-to-Source Transformation Procedure Integration and Tail-Recursion">Steele
1978</a>] contains the note:</p>
<blockquote>
<p>Revised version of a dissertation submitted (under the title
<em>“Compiler Optimization Based on Viewing LAMBDA as RENAME plus
GOTO”</em>) to the Department of Electrical Engineering and Computer
Science on May 12, 1977</p>
</blockquote>
<p>This document is an abridged transcription
(<a href="https://creativecommons.org/licenses/by-nc/4.0/" title="Creative Commons license deed: creativecommons.org/licenses/by-nc/4.0/">CC
BY-NC</a> adaptation) of [<a href="#steele-1978" title="RABBIT: A Compiler for SCHEME (A Dialect of LISP) A Study in Compiler Optimization Based on Viewing LAMBDA as RENAME and PROCEDURE CALL as GOTO using the techniques of Macro Definition of Control and Environment Structures Source-to-Source Transformation Procedure Integration and Tail-Recursion">Steele
1978</a>], omitting text not in the chapter <em>Compiler Optimization
Based on Viewing LAMBDA as RENAME plus GOTO</em> (in <em>Artificial
Intelligence, an MIT Perspective, Volume 2</em> (MIT Press 1979)
pp401-431) [<a href="#steele-1979" id="xsteele-1979" title="&#39;Compiler Optimization Based on Viewing LAMBDA as RENAME plus GOTO&#39; in Artificial Intelligence, an MIT Perspective, Volume 2 (MIT Press 1979) pp401-431">Steele
1979</a>]</p>
<p>This title page, Contents, links, {{transcriber notes}}, and bridging
text added.</p>
</div>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<div style="text-align: center">
<h1>
<p><span class="large">Compiler Optimization</span></p>
<p>Based on Viewing</p>
<span class="large">LAMBDA</span> as <span class="large">RENAME</span>
plus <span class="large">GOTO</span>
</h1>
<p><br />
</p>
<p>Guy Lewis Steele Jr.</p>
<p>Massachusetts Institute of Technology </div></p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<p><br />
</p>
<div id="licence" class="ti small">
<p>{{<a href="https://dspace.mit.edu/handle/1721.1/6913/AITR-474.pdf" title="Original pdf at MIT: dspace.mit.edu/bitstream/handle/1721.1/6913/AITR-474.pdf">RABBIT:
A Compiler for SCHEME</a> © 1978 by Guy Lewis Steele Jr, and this
abridged transcription,<br /> licensed
<a href="https://creativecommons.org/licenses/by-nc/4.0/" title="Creative Commons license deed: creativecommons.org/licenses/by-nc/4.0/">CC
BY-NC 4.0</a>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.785" cy="28.501" r="28.836"></circle>
	<path d="M37.441-3.5c8.951,0,16.572,3.125,22.857,9.372c3.008,3.009,5.295,6.448,6.857,10.314
		c1.561,3.867,2.344,7.971,2.344,12.314c0,4.381-0.773,8.486-2.314,12.313c-1.543,3.828-3.82,7.21-6.828,10.143
		c-3.123,3.085-6.666,5.448-10.629,7.086c-3.961,1.638-8.057,2.457-12.285,2.457s-8.276-0.808-12.143-2.429
		c-3.866-1.618-7.333-3.961-10.4-7.027c-3.067-3.066-5.4-6.524-7-10.372S5.5,32.767,5.5,28.5c0-4.229,0.809-8.295,2.428-12.2
		c1.619-3.905,3.972-7.4,7.057-10.486C21.08-0.394,28.565-3.5,37.441-3.5z M37.557,2.272c-7.314,0-13.467,2.553-18.458,7.657
		c-2.515,2.553-4.448,5.419-5.8,8.6c-1.354,3.181-2.029,6.505-2.029,9.972c0,3.429,0.675,6.734,2.029,9.913
		c1.353,3.183,3.285,6.021,5.8,8.516c2.514,2.496,5.351,4.399,8.515,5.715c3.161,1.314,6.476,1.971,9.943,1.971
		c3.428,0,6.75-0.665,9.973-1.999c3.219-1.335,6.121-3.257,8.713-5.771c4.99-4.876,7.484-10.99,7.484-18.344
		c0-3.543-0.648-6.895-1.943-10.057c-1.293-3.162-3.18-5.98-5.654-8.458C50.984,4.844,44.795,2.272,37.557,2.272z M37.156,23.187
		l-4.287,2.229c-0.458-0.951-1.019-1.619-1.685-2c-0.667-0.38-1.286-0.571-1.858-0.571c-2.856,0-4.286,1.885-4.286,5.657
		c0,1.714,0.362,3.084,1.085,4.113c0.724,1.029,1.791,1.544,3.201,1.544c1.867,0,3.181-0.915,3.944-2.743l3.942,2
		c-0.838,1.563-2,2.791-3.486,3.686c-1.484,0.896-3.123,1.343-4.914,1.343c-2.857,0-5.163-0.875-6.915-2.629
		c-1.752-1.752-2.628-4.19-2.628-7.313c0-3.048,0.886-5.466,2.657-7.257c1.771-1.79,4.009-2.686,6.715-2.686
		C32.604,18.558,35.441,20.101,37.156,23.187z M55.613,23.187l-4.229,2.229c-0.457-0.951-1.02-1.619-1.686-2
		c-0.668-0.38-1.307-0.571-1.914-0.571c-2.857,0-4.287,1.885-4.287,5.657c0,1.714,0.363,3.084,1.086,4.113
		c0.723,1.029,1.789,1.544,3.201,1.544c1.865,0,3.18-0.915,3.941-2.743l4,2c-0.875,1.563-2.057,2.791-3.541,3.686
		c-1.486,0.896-3.105,1.343-4.857,1.343c-2.896,0-5.209-0.875-6.941-2.629c-1.736-1.752-2.602-4.19-2.602-7.313
		c0-3.048,0.885-5.466,2.658-7.257c1.77-1.79,4.008-2.686,6.713-2.686C51.117,18.558,53.938,20.101,55.613,23.187z" />
</g>
</svg>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.637" cy="28.806" r="28.276"></circle>
	<g>
		<path d="M37.443-3.5c8.988,0,16.57,3.085,22.742,9.257C66.393,11.967,69.5,19.548,69.5,28.5c0,8.991-3.049,16.476-9.145,22.456
			C53.879,57.319,46.242,60.5,37.443,60.5c-8.649,0-16.153-3.144-22.514-9.43C8.644,44.784,5.5,37.262,5.5,28.5
			c0-8.761,3.144-16.342,9.429-22.742C21.101-0.415,28.604-3.5,37.443-3.5z M37.557,2.272c-7.276,0-13.428,2.553-18.457,7.657
			c-5.22,5.334-7.829,11.525-7.829,18.572c0,7.086,2.59,13.22,7.77,18.398c5.181,5.182,11.352,7.771,18.514,7.771
			c7.123,0,13.334-2.607,18.629-7.828c5.029-4.838,7.543-10.952,7.543-18.343c0-7.276-2.553-13.465-7.656-18.571
			C50.967,4.824,44.795,2.272,37.557,2.272z M46.129,20.557v13.085h-3.656v15.542h-9.944V33.643h-3.656V20.557
			c0-0.572,0.2-1.057,0.599-1.457c0.401-0.399,0.887-0.6,1.457-0.6h13.144c0.533,0,1.01,0.2,1.428,0.6
			C45.918,19.5,46.129,19.986,46.129,20.557z M33.042,12.329c0-3.008,1.485-4.514,4.458-4.514s4.457,1.504,4.457,4.514
			c0,2.971-1.486,4.457-4.457,4.457S33.042,15.3,33.042,12.329z" />
	</g>
</g>
</svg>
<svg id="Layer_1" role="img" aria-label alt style="max-width: 1em;max-height:1em;margin-left: .2em;" x="0px" y="0px" width="64px" height="64px" viewBox="5.5 -3.5 64 64" enable-background="new 5.5 -3.5 64 64" xml:space="preserve">
<g>
	<circle fill="#FFFFFF" cx="37.47" cy="28.736" r="29.471"></circle>
	<g>
		<path d="M37.442-3.5c8.99,0,16.571,3.085,22.743,9.256C66.393,11.928,69.5,19.509,69.5,28.5c0,8.992-3.048,16.476-9.145,22.458
			C53.88,57.32,46.241,60.5,37.442,60.5c-8.686,0-16.19-3.162-22.513-9.485C8.644,44.728,5.5,37.225,5.5,28.5
			c0-8.762,3.144-16.343,9.429-22.743C21.1-0.414,28.604-3.5,37.442-3.5z M12.7,19.872c-0.952,2.628-1.429,5.505-1.429,8.629
			c0,7.086,2.59,13.22,7.77,18.4c5.219,5.144,11.391,7.715,18.514,7.715c7.201,0,13.409-2.608,18.63-7.829
			c1.867-1.79,3.332-3.657,4.398-5.602l-12.056-5.371c-0.421,2.02-1.439,3.667-3.057,4.942c-1.622,1.276-3.535,2.011-5.744,2.2
			v4.915h-3.714v-4.915c-3.543-0.036-6.782-1.312-9.714-3.827l4.4-4.457c2.094,1.942,4.476,2.913,7.143,2.913
			c1.104,0,2.048-0.246,2.83-0.743c0.78-0.494,1.172-1.312,1.172-2.457c0-0.801-0.287-1.448-0.858-1.943l-3.085-1.315l-3.771-1.715
			l-5.086-2.229L12.7,19.872z M37.557,2.214c-7.276,0-13.428,2.571-18.457,7.714c-1.258,1.258-2.439,2.686-3.543,4.287L27.786,19.7
			c0.533-1.676,1.542-3.019,3.029-4.028c1.484-1.009,3.218-1.571,5.2-1.686V9.071h3.715v4.915c2.934,0.153,5.6,1.143,8,2.971
			l-4.172,4.286c-1.793-1.257-3.619-1.885-5.486-1.885c-0.991,0-1.876,0.191-2.656,0.571c-0.781,0.381-1.172,1.029-1.172,1.943
			c0,0.267,0.095,0.533,0.285,0.8l4.057,1.83l2.8,1.257l5.144,2.285l16.397,7.314c0.535-2.248,0.801-4.533,0.801-6.857
			c0-7.353-2.552-13.543-7.656-18.573C51.005,4.785,44.831,2.214,37.557,2.214z" />
	</g>
</g>
</svg>
(Attribution-NonCommercial 4.0 International).<br /> Transcription by
Roger Turner: links, Contents, {{transcriber notes}}, and bridging text
added. }}</p>
</div>
<p><hr></p>
<section id="contents" class="level2">
<h2>Contents</h2>
<div style="line-height: 1.5">
<div class="line-block"><a href="#lexically-scoped-lisp">1.  
Lexically-scoped <span class="sc">LISP</span></a><br />
   <a href="#a.-background">A.   Background</a><br />
   <a href="#b.-the-thesis">B.   The Thesis</a><br />
<a href="#the-source-language---scheme">2.   The Source Language - <span class="sc">SCHEME</span></a><br />
<a href="#the-target-language">3.   The Target Language</a><br />
<a href="#language-design-considerations">4.   Language Design
Considerations</a><br />
<a href="#the-use-of-macros">5.   The Use of Macros</a><br />
<a href="#the-imperative-treatment-of-applicative-constructs">6.   The
Imperative Treatment of Applicative Constructs</a><br />
   <a href="#a.-optimization">A.   Optimization</a><br />
   <a href="#b.-environment-and-closure-analysis">B.   Environment and
closure analysis</a><br />
<a href="#conclusions">7.   Conclusions</a><br />
<a href="#references">References</a></div>
</div>
<p><hr></p>
</section>
<section id="lexically-scoped-lisp" class="level2">
<h2><a href="#contents" title="Go to Contents">1. Lexically-scoped <span class="sc">LISP</span></a></h2>
<p>We have developed a compiler for the lexically-scoped dialect of
<span class="sc">LISP</span> known as <span class="sc">SCHEME</span>.
The compiler knows relatively little about specific data manipulation
primitives such as arithmetic operators, but concentrates on general
issues of environment and control. Rather than having specialized
knowledge about a large variety of control and environment constructs,
the compiler handles only a small basis set which reflects the semantics
of lambda-calculus. All of the traditional imperative constructs, such
as sequencing, assignment, looping, <code>GOTO</code>, as well as many
standard <span class="sc">LISP</span> constructs such as
<code>AND</code>, <code>OR</code>, and <code>COND</code>, are expressed
as macros in terms of the applicative basis set. A small number of
optimization techniques, coupled with the treatment of function calls as
<code>GOTO</code> statements, serve to produce code as good as that
produced by more traditional compilers. The macro approach enables
speedy implementation of new constructs as desired without sacrificing
efficiency in the generated code.</p>
<p>A subset of <span class="sc">SCHEME</span> serves as the
representation intermediate between the optimized <span class="sc">SCHEME</span> code and the final output code; code is
expressed in this subset in the so-called continuation-passing style. As
a subset of <span class="sc">SCHEME</span>, it enjoys the same
theoretical properties; one could even apply the same optimizer used on
the input code to the intermediate code. However, the subset is so
chosen that all temporary quantities are made manifest as variables, and
no control stack is needed to evaluate it. As a result, this apparently
applicative representation admits an imperative interpretation which
permits easy transcription to final imperative machine code.</p>
<section id="a.-background" class="level3">
<h3><a href="#contents">A.   Background</a></h3>
<p>In [<a href="#sussman-1975-1-2-3" id="xsussman-19751" title="[1] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus">Sussman
1975</a>] we described the implementation of a dialect of <span class="sc">LISP</span> named <span class="sc">SCHEME</span> with the
properties of lexical scoping and tail-recursion; this implementation is
embedded within <span class="sc">MacLISP</span> [<a href="#moon-1974-1-2" id="xmoon-19741" title="[1] Moon 1974, MACLISP Reference Manual, Revision 0">Moon
1974</a>], a version of <span class="sc">LISP</span> which does not have
these properties. The property of lexical scoping (that a variable can
be referenced only from points textually within the expression which
binds it) is a consequence of the fact that all functions are closed in
the “binding environment.” [<a href="#moses-1970-1-2" id="xmoses-19701" title="[1] Moses 1970, The Function of FUNCTION in LISP">Moses 1970</a>]
That is, <span class="sc">SCHEME</span> is a “full-funarg” <span class="sc">LISP</span> dialect. <!--
{Note [Full-Funarg Example](#note-full-funarg-example "As an example of the difference
between lexical and dynamic scoping, consider the classic case of the 'funarg problem'. We
have defined a function MAPCAR which, given a function and a list, produces a new list of
the results of the function applied to each element of the given list ..."){#xfull-funarg-example}} 
--> The property of tail-recursion implies that loops written in an
apparently recursive form will actually be executed in an iterative
fashion. Intuitively, function calls do not “push control stack”;
instead, it is argument evaluation which pushes control stack. The two
properties of lexical scoping and tail-recursion are not independent. In
most <span class="sc">LISP</span> systems [<a href="#mccarthy-1962" id="xmccarthy-1962" title="[1] McCarthy etal 1962, LISP 1.5 Programmer&#39;s Manual">McCarthy
1962</a>] [<a href="#moon-1974-1-2" id="xmoon-19742" title="[2] Moon 1974, MACLISP Reference Manual, Revision 0">Moon
1974</a>] [<a href="#teitelman-1975" id="xteitelman-1975" title="Teitelman 1975, InterLISP Reference Manual. Revised edition">Teitelman
1975</a>], which use dynamic scoping rather than lexical, tail-recursion
is impossible because function calls must push control stack in order to
be able to undo the dynamic bindings after the return of the function.
On the other hand, it is possible to have a lexically scoped <span class="sc">LISP</span> which does not tail-recurse, but it is easily
seen that such an implementation only wastes storage space needlessly
compared to a tail-recursing implementation. [<a href="#steele-1977a-1-2-3-4" id="xsteele-1977a1" title="[1] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele
1977A</a>] Together, these two properties cause <span class="sc">SCHEME</span> to reflect lambda-calculus semantics much more
closely than dynamically scoped <span class="sc">LISP</span> systems.
<span class="sc">SCHEME</span> also permits the treatment of functions
as full-fledged data objects; they may be passed as arguments, returned
as values, made part of composite data structures, and notated as
independent, unnamed (“anonymous”) entities. (Contrast this with most
<span class="sc">ALGOL</span>-like languages, in which a function can be
written only by declaring it and giving it a name; imagine being able to
use an integer value only by giving it a name in a declaration!) The
property of lexical scoping allows this to be done in a consistent
manner without the possibility of identifier conflicts (that is, <span class="sc">SCHEME</span> “solves the <code>FUNARG</code> problem” [<a href="#moses-1970-1-2" id="xmoses-19702" title="[2] Moses 1970, The Function of FUNCTION in LISP">Moses
1970</a>]). In [<a href="#sussman-1975-1-2-3" id="xsussman-19752" title="[2] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus">Sussman
1975</a>] we also discussed the technique of “continuation-passing
style”, a way of writing programs in <span class="sc">SCHEME</span> such
that no function ever returns a value.</p>
<p>In [<a href="#steele-1976a-1-2-3" id="xsteele-1976a1" title="[1] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Steele
1976A</a>] we explored ways of exploiting these properties to implement
most traditional programming constructs, such as assignment, looping,
and call-by-name, in terms of function application. Such applicative
(lambda-calculus) models of programming language constructs are
well-known to theoreticians (see [<a href="#stoy-1974" id="xstoy-1974" title="Stoy 1974, he Scott-Strachey Approach to the Mathematical Semantics of Programming Languages">Stoy
1974</a>], for example), but have not been used in a practical
programming system. All of these constructs are actually made available
in <span class="sc">SCHEME</span> by macros which expand into these
applicative definitions. This technique has permitted the speedy
implementation of a rich user-level language in terms of a very small,
easy-to-implement basis set of primitive constructs. The escape operator
<code>CATCH</code> is easily modelled by transforming a program into
continuation-passing style. Transforming a program into this style
enforces a particular order of argument evaluation, and makes all
intermediate computational quantities manifest as variables.</p>
<p>In [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b1" title="[1] Steele 1976B, LAMBDA: The Ultimate Declarative">Steele
1976B</a>] we examined more closely the issue of tail-recursion, and
demonstrated that the usual view of function calls as pushing a return
address must lead to an either inefficient or inconsistent
implementation, while the tail-recursive approach of <span class="sc">SCHEME</span> leads to a uniform discipline in which function
calls are treated as <code>GOTO</code> statements which also pass
arguments. We also noted that a consequence of lexical scoping is that
the only code which can reference the value of a variable in a given
environment is code which is closed in that environment or which
receives the value as an argument; this in turn implies that a compiler
can structure a run-time environment in any arbitrary fashion, because
it will compile all the code which can reference that environment, and
so can arrange for that code to reference it in the appropriate manner.
Such references do not require any kind of search (as is commonly and
incorrectly believed in the <span class="sc">LISP</span> community
because of early experience with LISP interpreters which search a-lists)
because the compiler can determine the precise location of each variable
in an environment at compile time. It is not necessary to use a standard
format, because neither interpreted code nor other compiled code can
refer to that environment.</p>
<p>In [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b2" title="[2] Steele 1976B, LAMBDA: The Ultimate Declarative">Steele
1976B</a>] we also carried on the analysis of continuation-passing
style, and noted that transforming a program into this style elucidates
traditional compilation issues such as register allocation because user
variables and intermediate quantities alike are made manifest as
variables on an equal footing. Appendix A of [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b3" title="[3] Steele 1976B, LAMBDA: The Ultimate Declarative">Steele
1976B</a>] contained an algorithm for converting any <span class="sc">SCHEME</span> program (not containing <code>ASET</code>) to
continuation-passing style.</p>
<p>We have implemented two compilers for the language <span class="sc">SCHEME</span>. The purpose was to explore compilation
techniques for a language modelled on lambda-calculus, using
lambda-calculus-style models of imperative programming constructs. Both
compilers use the strategy of converting the source program to
continuation-passing style.</p>
<p>The first compiler (known as <span class="sc">CHEAPY</span>) was
written as a throw-away implementation to test the concept of conversion
to continuation-passing style. The first half of <span class="sc">CHEAPY</span> is essentially the algorithm which appears in
Appendix A of [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b4" title="[4] Steele 1976B, LAMBDA: The Ultimate Declarative">Steele
1976B</a>], and the second is a simple code generator with almost no
optimization. In conjunction with the writing of <span class="sc">CHEAPY</span>, the <span class="sc">SCHEME</span> interpreter
was modified to interface to compiled functions.</p>
<p>The second compiler, with which we are primarily concerned here, is
known as <span class="sc">RABBIT</span>. It, like <span class="sc">CHEAPY</span>, is written almost entirely in <span class="sc">SCHEME</span> (with minor exceptions due only to problems in
interfacing with certain <span class="sc">MacLISP</span> I/O
facilities). Unlike <span class="sc">CHEAPY</span>, it is fairly clever.
It is intended to demonstrate a number of optimization techniques
relevant to lexical environments and tail-recursive control
structures.</p>
</section>
<section id="b.-the-thesis" class="level3">
<h3><a href="#contents">B.   The Thesis</a></h3>
<ol type="1">
<li>Function calls are not expensive when compiled correctly; they
should be thought of as <code>GOTO</code> statements that happen to pass
arguments.</li>
<li>The combination of cheap function calls, lexical scoping,
tail-recursion, and “anonymous” notation of functions (which are not
independent properties of a language, but aspects of a single unified
approach) permits the definition of a wide variety of “imperative”
constructs in applicative terms. Because these properties result from
adhering to the principles of the well-known lambda-calculus [<a href="#church-1941-1-2" id="xchurch-19411" title="[1] Church 1941, The Calculi of Lambda Conversion">Church
1941</a>], such definitions can be lifted intact from existing
literature and used directly.</li>
<li>A macro facility (the ability to specify syntactic transformations)
makes it practical to use these as the only definitions of imperative
constructs in a programming system. Such a facility makes it extremely
easy to define new constructs.</li>
<li>A few well-chosen optimization strategies enable the compilation of
these applicative definitions into the imperative low-level code which
one would expect from a traditional compiler.</li>
<li>The macro facility and the optimization techniques used by the
compiler can be conceptually unified. The same properties which make it
easy to write the macros make it easy to define optimizations correctly.
In the same way that many programming constructs are defined in terms of
a small, well- chosen basis set, so a large number of traditional
optimization techniques fall out as special cases of the few used in
<span class="sc">RABBIT</span>. This is no accident. The separate
treatment of a large and diverse set of constructs necessitates separate
optimization techniques for each. As the basis set of constructs is
reduced, so is the set of interesting transformations. If the basis set
is properly chosen, their combined effect is “multiplicative” rather
than “additive”.</li>
<li>The technique of compiling by converting to continuation-passing
style elucidates some important compilation issues in a natural way.
Intermediate quantities are made manifest; so is the precise order of
evaluation. Moreover, this is all expressed in a language isomorphic to
a subset of the source language <span class="sc">SCHEME</span>; as a
result the continuation-passing style version of a program inherits many
of the philosophical and practical advantages. For example, the same
optimization techniques can be applied at this level as at the original
source level. While the use of continuation-passing style may not make
the decisions any easier, it provides an effective and natural way to
express the results of those decisions.</li>
<li>Continuation-passing style, while apparently applicative in nature,
admits a peculiarly imperative interpretation as a consequence of the
facts that it requires no control stack to be evaluated and that no
functions ever return values. As a result, it is easily converted to an
imperative machine language.</li>
<li>A <span class="sc">SCHEME</span> compiler should ideally be a
designer of good data structures, since it may choose any representation
whatsoever for environments. <span class="sc">RABBIT</span> has a
rudimentary design knowledge, involving primarily the preferral of
registers to heap-allocated storage. However, there is room for
knowledge of “bit-diddling” representations.</li>
<li>We suggest that those who have tried to design useful <span class="sc">UNCOL</span>s (UNiversal Computer-Oriented Languages) [<a href="#sammet-1969" id="xsammet-1969" title="[1] Sammet 1969, Programming Languages: History and Fundamentals">Sammet
1969</a>] [<a href="#coleman-1974" id="xcoleman-1974" title="[1] Coleman 1974, JANUS: A Universal Intermediate Language">Coleman
1974</a>] have perhaps been thinking too imperatively, and worrying more
about data manipulation primitives than about environment and control
issues. As a result, proposed <span class="sc">UNCOL</span>s have been
little more than generalizations of contemporary machine languages. We
suggest that <span class="sc">SCHEME</span> makes an ideal <span class="sc">UNCOL</span> at two levels. The first level is the fully
applicative level, to which most source-language constructs are easily
reduced; the second is the continuation-passing style level, which is
easily reduced to machine language. We envision building a compiler in
three stages: (a) reduction of a user language to basic <span class="sc">SCHEME</span>, whether by macros, a parser of algebraic
syntax, or some other means; (b) optimization by means of <span class="sc">SCHEME</span>-level source-to-source transformations, and
conversion to continuation-passing style; and (c) generation of code for
a particular machine. <span class="sc">RABBIT</span> addresses itself to
the second stage. Data manipulation primitives are completely ignored at
this stage, and are just passed along from input to output. These
primitives, whether integer arithmetic, string concatenation and
parsing, or list structure manipulators, are chosen as a function of a
particular source language and a particular target machine. <span class="sc">RABBIT</span> deals only with fundamental environment and
control issues common to most modes of algorithmic expression.</li>
<li>While syntactic issues tend to be rather superficial, we point out
that algebraic syntax tends to obscure the fundamental nature of
function calling and tail-recursion by arbitrarily dividing functions
into syntactic classes such as “operators” and “functions”. ([<a href="#standish-1976-1-2" id="xstandish-19761" title="[1] Standish etal 1976, The Irvine Program Transformation Catalogue">Standish
1976</a>], for example, uses much space to exhibit each conceptually
singular transformation in a multiplicity of syntactic manifestations.)
The lack of an “anonymous” notation for functions in most algebraic
languages, and the inability to treat functions as data objects, is a
distinct disadvantage. The uniformity of <span class="sc">LISP</span>
syntax makes these issues easier to deal with.</li>
</ol>
<p>To the LISP community in particular we address these additional
points:</p>
<ol start="11" type="1">
<li>Lexical scoping need not be as expensive as is commonly thought.
Experience with lexically-scoped <em>interpreters</em> is misleading;
lexical scoping is not inherently slower than dynamic scoping. While
some implementations may entail access through multiple levels of
structure, this occurs only under circumstances (accessing of variables
through multiple levels of closure) which could not even be expressed in
a dynamically scoped language. Unlike deep-bound dynamic variables,
compiled lexical access requires no search; unlike shallow-bound dynamic
variables, lexical binding does not require that values be put in a
canonical value cell. The compiler has complete discretion over the
manipulation of environments and variable values. The “display”
technique used in Algol implementations can be generalized to provide an
efficient solution to the <span class="sc">FUNARG</span> problem.</li>
<li>Lexical scoping does not necessarily make <span class="sc">LISP</span> programming unduly difficult. The very existence
of <span class="sc">RABBIT</span>, a working compiler some fifty pages
in length written in <span class="sc">SCHEME</span>, first implemented
in about a month, part-time, substantiates this claim (which is,
however, admitted to be mostly a matter of taste and experience). <!--
     {Note [Refinement of [RABBIT]{.sc}](#note-refinement-of-rabbit "Since the original
     dissertation was written I have continued to refine and improve RABBIT. This effort has
     included a complete rewriting of the optimizer ..."){#xrefinement-of-rabbit}}
     --> <span class="sc">SCHEME</span> has also been used to implement
several AI problem-solving languages, including <span class="sc">AMORD</span> [<a href="#doyle-1977" id="xdoyle-1977" title="[1] Doyle etal 1977, AMORD: A Dependency-Based Problem-Solving Language">Doyle
1977</a>].</li>
</ol>
<p><hr></p>
</section>
</section>
<section id="the-source-language---scheme" class="level2">
<h2><a href="#contents">2.   The Source Language - <span class="sc">SCHEME</span></a></h2>
<p>The basic language processed by <span class="sc">RABBIT</span> is a
subset of the <span class="sc">SCHEME</span> language as described in
[<a href="#sussman-1975-1-2-3" id="xsussman-19753" title="[3] Sussman and Steele 1975, SCHEME: An Interpreter for Extended Lambda Calculus">Sussman
1975</a>] the primary restrictions being that the first argument to
<code>ASET</code> must be quoted and that the multiprocessing primitives
are not accommodated. This subset is summarized here. <span class="sc">SCHEME</span> is essentially a lexically scoped (“full
funarg”) dialect of <span class="sc">LISP</span>. Interpreted programs
are represented by S-expressions in the usual manner. Numbers represent
themselves. Atomic symbols are used as identifiers (with the
conventional exception of <code>T</code> and <code>NIL</code>, which are
conceptually treated as constants). All other constructs are represented
as lists.</p>
<p>In order to distinguish the various other constructs, <span class="sc">SCHEME</span> follows the usual convention that a list whose
car is one of a set of distinguished atomic symbols is treated as
directed by a rule associated with that symbol. All other lists (those
with non-atomic cars, or with undistinguished atoms in their cars) are
<em>combinations</em>, or function calls. All subforms of the list are
uniformly evaluated in an unspecified order, and then the value of the
first (the function) is applied to the values of all the others (the
arguments). Notice that the function position is evaluated in the same
way as the argument positions (unlike most other <span class="sc">LISP</span> systems). (In order to be able to refer to <span class="sc">MacLISP</span> functions, global identifiers evaluate to a
special kind of functional object if they have definitions as <span class="sc">MacLISP</span> functions of the <code>EXPR</code>,
<code>SUBR</code>, or <code>LSUBR</code> varieties. Thus
“<code>(PLUS 1 2)</code>” evaluates to <code>3</code> because the values
of the subforms are &lt;functional object for <code>PLUS</code>&gt;,
<code>1</code>, and <code>2</code>; and applying the first to the other
two causes invocation of the <span class="sc">MacLISP</span> primitive
<code>PLUS</code>.)</p>
<p>The atomic symbols which distinguish special constructs are as
follows:</p>
<dl>
<dt><strong><code>LAMBDA</code></strong></dt>
<dd>
This denotes a function. A form
<code>(LAMBDA (var1 var2 ... varn) body)</code> will evaluate to a
function of n arguments. The <strong>parameters</strong>
<code>vari</code> are identifiers (atomic symbols) which may be used in
the body to refer to the respective <strong>arguments</strong> when the
function is invoked. Note that a <code>LAMBDA</code>-expression is not a
function, but <em>evaluates</em> to one, a crucial distinction.
</dd>
<dt><strong><code>IF</code></strong></dt>
<dd>
This denotes a conditional form. <code>(IF a b c)</code> evaluates the
<strong>predicate</strong> <code>a</code>, producing a value
<code>x</code>; if <code>x</code> is non-<code>NIL</code>, then the
<strong>consequent</strong> <code>b</code> is evaluated, and otherwise
the <strong>alternative</strong> <code>c</code>. If <code>c</code> is
omitted, <code>NIL</code> is assumed.
</dd>
<dt><strong><code>QUOTE</code></strong></dt>
<dd>
As in all <span class="sc">LISP</span> systems, this provides a way to
specify any S-expression as a constant. <code>(QUOTE x)</code> evaluates
to the S-expression <code>x</code>. This may be abbreviated to
<code>&#39;x</code>, thanks to the <span class="sc">MacLISP</span>
read-macro-character feature.
</dd>
<dt><strong><code>LABELS</code></strong></dt>
<dd>
This primitive permits the local definition of one or more mutually
recursive functions. The format is:<br />
<code>  (LABELS ((name1 (LAMBDA ...))</code><br />
<code>           (name2 (LAMBDA ...))</code><br />
<code>           ...</code><br />
<code>           (namen (LAMBDA ...)))</code><br />
<code>          body)</code><br />
This evaluates the <code>body</code> in an environment in which the
names refer to the respective functions, which are themselves closed in
that same environment. Thus references to these names in the bodies of
the <code>LAMBDA</code>-expressions will refer to the labelled
functions. <!--
  {Note [Generalized `LABELS`](#note-generalized-labels "Since the dissertation
  was written, and indeed after [Revised Report] came out, the format of LABELS in SCHEME
  was generalized to permit labelled functions to be defined using any of the same three
  formats permitted by DEFINE in [Revised Report]. RABBIT has been updated to reflect this
  change, and the code for it appears in the Appendix."){#xgeneralized-labels}}
  -->
</dd>
<dt><strong><code>ASET&#39;</code></strong></dt>
<dd>
This is the primitive side-effect on variables.
<code>(ASET&#39; var body)</code> evaluates the <code>body</code>, assigns
the resulting value to the variable <code>var</code>, and returns that
value. <!--
  {Note [Non-quoted `ASET`](#note-non-quoted-aset "The SCHEME
  interpreter permits one to compute the name of the variable, but for technical and
  philosophical reasons RABBIT forbids this. ..."){#xnon-quoted-aset}}
  --> For implementation-dependent reasons, it is forbidden by <span class="sc">RABBIT</span> to use <code>ASET&#39;</code> on a global variable
which is the name of a primitive <span class="sc">MacLISP</span>
function, or on a variable bound by <code>LABELS</code>.
(<code>ASET&#39;</code> is actually used very seldom in practice anyway, and
all these restrictions are “good programming practice”. <span class="sc">RABBIT</span> could be altered to lift these restrictions, at
some expense and labor.)
</dd>
<dt><strong><code>CATCH</code></strong></dt>
<dd>
This provides an escape operator facility. [<a href="#landin-1965" id="xlandin-1965" title="[1] Landin 1965, A Correspondence between ALGOL 60 and Church&#39;s Lambda-Notation">Landin
1965</a>] [<a href="#reynolds-1972" id="xreynolds-1972" title="Reynolds 1972, Definitional Interpreters for Higher Order Programming Languages">Reynolds
1972</a>] <code>(CATCH var body)</code> evaluates the <code>body</code>,
which may refer to the variable <code>var</code>, which will denote an
“escape function” of one argument which, when called, will return from
the <code>CATCH</code>-form with the given argument as the value of the
<code>CATCH</code>-form. Note that it is entirely possible to return
from the <code>CATCH</code>-form several times. This raises a difficulty
with optimization which will be discussed later.
</dd>
<dt><strong>Macros</strong></dt>
<dd>
Any atomic symbol which has been defined in one of various ways to be a
macro distinguishes a special construct whose meaning is determined by a
macro function. This function has the responsibility of rewriting the
form and returning a new form to be evaluated in place of the old one.
In this way complex syntactic constructs can be expressed in terms of
simpler ones.
</dd>
</dl>
<p><hr></p>
</section>
<section id="the-target-language" class="level2">
<h2><a href="#contents">3.   The Target Language</a></h2>
<p>The “target language” is a highly restricted subset of <span class="sc">MacLISP</span>, rather than any particular machine language
for an actual hardware machine such as the <span class="sc">PDP-10</span>. <span class="sc">RABBIT</span> produces <span class="sc">MacLISP</span> function definitions which are then compiled
by the standard <span class="sc">MacLISP</span> compiler. In this way we
do not need to deal with the uninteresting vagaries of a particular
piece of hardware, nor with the peculiarities of the many and various
data-manipulation primitives (<code>CAR</code>, <code>RPLACA</code>,
<code>+</code>, etc.). We allow the <span class="sc">MacLISP</span>
compiler to deal with them, and concentrate on the issues of environment
and control which are unique to <span class="sc">SCHEME</span>. While
for production use this is mildly inconvenient (since the code must be
passed through two compilers before use), for research purposes it has
saved the wasteful re-implementation of much knowledge already contained
in the <span class="sc">MacLISP</span> compiler.</p>
<p>On the other hand, the use of <span class="sc">MacLISP</span> as a
target language does not by any means trivialize the task of <span class="sc">RABBIT</span>. The <span class="sc">MacLISP</span>
function-calling mechanism cannot be used as a target construct for the
<span class="sc">SCHEME</span> function call, because <span class="sc">MacLISP</span>’s function calls are not guaranteed to behave
tail-recursively. Since tail-recursion is a most crucial characteristic
distinguishing <span class="sc">SCHEME</span> from most <span class="sc">LISP</span> systems, we must implement <span class="sc">SCHEME</span> function calls by more primitive methods.
Similarly, since <span class="sc">SCHEME</span> is a full-funarg dialect
of <span class="sc">LISP</span> while <span class="sc">MacLISP</span> is
not, we cannot in general use <span class="sc">MacLISP</span>’s
variable-binding mechanisms to implement those of <span class="sc">SCHEME</span>. On the other hand, it is a perfectly
legitimate optimization to use <span class="sc">MacLISP</span>
mechanisms in those limited situations where they are applicable.</p>
</section>
<section id="language-design-considerations" class="level2">
<h2><a href="#contents">4.   Language Design Considerations</a></h2>
<p>We divide the definition of the <span class="sc">SCHEME</span>
language into two parts: the environment and control constructs, and the
data manipulation primitives. Examples of the former are
<code>LAMBDA</code>-expressions, combinations, and <code>IF</code>;
examples of the latter are <code>CONS</code>, <code>CAR</code>,
<code>EQ</code>, and <code>PLUS</code>. Note that we can conceive of a
version of <span class="sc">SCHEME</span> which did not have
<code>CONS</code>, for example, and more generally did not have
S-expressions in its data domain. Such a version would still have the
same environment and control constructs, and so would hold the same
theoretical interest for our purposes here. (Such a version, however,
would be less convenient for purposes of writing a meta-circular
description of the language, however!)</p>
<p><span class="sc">SCHEME</span> is a lexically scoped (“full-funarg”)
dialect of <span class="sc">LISP</span>, and so is an applicative
language which conforms to the spirit of the lambda-calculus. [<a href="#church-1941-1-2" id="xchurch-19412" title="[2] Church 1941, The Calculi of Lambda Conversion">Church
1941</a>] By the “spirit of lambda-calculus” we mean the essential
properties of the axioms obeyed by lambda-calculus expressions. Among
these are the rules of <em>alpha-conversion</em> and
<em>beta-conversion</em>. The first intuitively implies that we can
uniformly rename a function parameter and all references to it without
altering the meaning of the function. An important corollary to this is
that we can in fact effectively locate all the references. The second
implies that in a situation where a known function is being called with
known argument expressions, we may substitute an argument expression for
a parameter reference within the body of the function (provided no
naming conflicts result, and that certain restrictions involving side
effects are met). Both of these operations are of importance to an
optimizing compiler. Another property which follows indirectly is that
of <em>tail-recursion</em>. This property is exploited in expressing
iteration in terms of applicative constructs, and is discussed in some
detail in [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b5" title="[5] Steele 1976, LAMBDA: The Ultimate Declarative">Steele
1976B</a>].</p>
<p>There are those to whom lexical scoping is nothing new, for example
the <span class="sc">ALGOL</span> community. For this audience, however,
we should draw attention to another important feature of <span class="sc">SCHEME</span>, which is that functions are first-class data
objects. They may be assigned or bound to variables, returned as values
of other functions, placed in arrays, and in general treated as any
other data object. Just as numbers have certain operations defined on
them, such as addition, so functions have an important operation defined
on them, namely invocation.</p>
<p>The ability to treat functions as objects is not at all the same as
the ability to treat <em>representations</em> of functions as objects.
It is the latter ability that is traditionally associated with <span class="sc">LISP</span>; functions can be represented as S-expressions.
In a version of <span class="sc">SCHEME</span> which had no S-expression
primitives, however, one could still deal with functions (i.e. closures)
as such, for that ability is part of the fundamental environment and
control facilities. Conversely, in a <span class="sc">SCHEME</span>
which does have <code>CONS</code>, <code>CAR</code>, and
<code>CDR</code>, there is no defined way to use <code>CONS</code> by
itself to construct a function (although a primitive
<code>ENCLOSE</code> is now provided which converts an S-expression
representation of a function into a function), and the <code>CAR</code>
or <code>CDR</code> of a function is in general undefined. The only
defined operation on a function is invocation. <!--
{Note [Operations on Functions](#note-operations-on-functions "It would certainly be possible
to define other operations on functions, such as determining the number of arguments required,
or the types of the arguments and returned value, etc. ..."){#xoperations-on-functions}}
--></p>
<p>We draw this sharp distinction between environment and control
constructs on the one hand and data manipulation primitives on the other
because only the former are treated in any depth by <span class="sc">RABBIT</span>, whereas much of the knowledge of a “real”
compiler deals with the latter. A <span class="sc">PL/I</span> compiler
must have much specific knowledge about numbers, arrays, strings, and so
on. We have no new ideas to present here on such issues, and so have
avoided this entire area. <span class="sc">RABBIT</span> itself knows
almost nothing about data manipulation primitives beyond being able to
recognize them and pass them along to the output code, which is a small
subset of MacLISP. In this way <span class="sc">RABBIT</span> can
concentrate on the interesting issues of environment and control, and
exploit the expert knowledge of data manipulation primitives already
built into the <span class="sc">MacLISP</span> compiler.</p>
<p><hr></p>
</section>
<section id="the-use-of-macros" class="level2">
<h2><a href="#contents">5.   The Use of Macros</a></h2>
<p>An important characteristic of the <span class="sc">SCHEME</span>
language is that its set of primitive constructs is quite small. This
set is not always convenient for expressing programs, however, and so a
macro facility is provided for extending the expressive power of the
language. A macro is best thought of as a <em>syntax rewrite rule</em>.
As a simple example, suppose we have a primitive <code>GCD</code> which
takes only two arguments, and we wish to be able to write an invocation
of a <code>GCD</code> function with any number of arguments. We might
then define (in a “production-rule” style) the conditional rule:</p>
<pre><code>    (XGCD)          =&gt; 0
    (XGCD x)        =&gt; x
    (XGCD x . rest) =&gt; (GCD x (XGCD . rest))</code></pre>
<p>(Notice the use of <span class="sc">LISP</span> dots to refer to the
rest of a list.) This is not considered to be a definition of a function
<code>XGCD</code>, but a purely syntactic transformation. In principle
all such transformations could be performed before executing the
program. In fact, <span class="sc">RABBIT</span> does exactly this,
although the <span class="sc">SCHEME</span> interpreter naturally does
it incrementally, as each macro call is encountered.</p>
<p>Rather than use a separate production-rule/pattern-matching language,
in practice <span class="sc">SCHEME</span> macros are defined as
transformation functions from macro-call expressions to resulting
S-expressions, just as they are in <span class="sc">MacLISP</span>.
(Here, however, we shall continue to use production rules for purposes
of exposition.) It is important to note that macros need not be written
in the language for which they express rewrite rules; rather, they
should be considered an adjunct to the interpreter, and written in the
same language as the interpreter (or the compiler). To see this more
clearly, consider a version of <span class="sc">SCHEME</span> which does
not have S-expressions in its data domain. If programs in this language
are represented as S-expressions, then the interpreter for that language
cannot be written in that language, but in another meta-language which
does deal with S-expressions. Macros, which transform one S-expression
(representing a macro call) to another (the replacement form, or the
interpretation of the call), clearly should be expressed in this
meta-language also. The fact that in most <span class="sc">LISP</span>
systems the language and the meta-language appear to coincide is a
source of both power and confusion.</p>
<p>We shall give some examples here. The <code>BLOCK</code> macro is
similar to the <span class="sc">MacLISP</span> <code>PROGN</code>; it
evaluates all its arguments and returns the value of the last one. One
critical characteristic is that the last argument is evaluated
“tail-recursively” (I use horror quotes because normally we speak of
invocation, not evaluation, as being tail-recursive). An expansion rule
is given for this in [<a href="#steele-1976a-1-2-3" id="xsteele-1976a2" title="[2] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Steele
1976A</a>] equivalent to:</p>
<pre><code>    (BLOCK x)         =&gt;  x
    (BLOCK x . rest)  =&gt;  ((LAMBDA (DUMMY) (BLOCK . rest)) x)</code></pre>
<p>This definition exploits the fact that <span class="sc">SCHEME</span>
is evaluated in applicative order, and so will evaluate all arguments
before applying a function to them. Thus, in the second subrule,
<code>x</code> must be evaluated, and then the block of all the
<code>rest</code> is. It is then clear from the first subrule that the
last argument is evaluated “tail-recursively”.</p>
<p>One problem with this definition is the occurrence of the variable
<code>DUMMY</code>, which must be chosen so as not to conflict with any
variable used by the user. This we refer to as the “<code>GENSYM</code>
problem”, in honor of the traditional <span class="sc">LISP</span>
function which creates a “fresh” symbol. It would be nicer to write the
macro in such a way that no conflict could arise no matter what names
were used by the user. There is indeed a way, which <span class="sc">ALGOL</span> programmers will recognize as equivalent to the
use of “thunks”, or call-by-name parameters:</p>
<pre><code>    (BLOCK x)         =&gt;  x
    (BLOCK x . rest)  =&gt;  ((LAMBDA (A B) (B))
                           x
                           (LAMBDA () (BLOCK . rest)))</code></pre>
<p>This is a technique which should be understood quite thoroughly,
since it is the key to writing correct macro rules without any
possibility of conflicts between names used by the user and those needed
by the macro. As another example, let us consider the <code>AND</code>
and <code>OR</code> constructs as used by most <span class="sc">LISP</span> systems. <code>OR</code> evaluates its arguments
one by one, in order, returning the first non-<code>NIL</code> value
obtained (without evaluating any of the following arguments), or
<code>NIL</code> if all arguments produce <code>NIL</code>.
<code>AND</code> is the dual to this; it returns <code>NIL</code> if any
argument does, and otherwise the value of the last argument. A
simple-minded approach to <code>OR</code> would be:</p>
<pre><code>    (OR)           =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  (IF x x (OR . rest))</code></pre>
<p>There is an objection to this, which is that the code for
<code>x</code> is duplicated. Not only does this consume extra space,
but it can execute erroneously if <code>x</code> has any side-effects.
We must arrange to evaluate x only once, and then test its value:</p>
<pre><code>    (OR)           =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  ((LAMBDA (V) (IF V V (OR . rest))) x)</code></pre>
<p>This certainly evaluates <code>x</code> only once, but admits a
possible naming conflict between the variable <code>V</code> and any
variables used by rest. This is avoided by the same technique used for
<code>BLOCK</code>:</p>
<pre><code>    (OR)          =&gt;  &#39;NIL
    (OR x . rest)  =&gt;  ((LAMBDA (V R) (IF V V (R)))
                      x
                      (LAMBDA () (OR . rest)))</code></pre>
<p>Let us now consider a rule for the more complicated <code>COND</code>
construct:</p>
<pre><code>    (COND)                 =&gt;  &#39;NIL
    (COND (x) . rest)      =&gt;  (OR x (COND . rest))
    (COND (x . r) . rest)  =&gt;  (IF x (BLOCK . r) (COND . rest))</code></pre>
<p>This defines the “extended” <code>COND</code> of modern <span class="sc">LISP</span> systems, which produces <code>NIL</code> if no
clauses succeed, which returns the value of the predicate in the case of
a singleton clause, and which allows more than one consequent in a
clause. An important point here is that one can write these rules in
terms of other macro constructs such as <code>OR</code> and
<code>BLOCK</code>.</p>
<p><span class="sc">SCHEME</span> also provides macros for such
constructs as <code>DO</code> and <code>PROG</code>, all of which expand
into similar kinds of code using <code>LAMBDA</code>, <code>IF</code>,
and <code>LABELS</code> (see below). In particular, <code>PROG</code>
permits the use of <code>GO</code> and <code>RETURN</code> in the usual
manner. In this manner all the traditional imperative constructs are
expressed in an applicative manner. <!--
{Note [`ASET'` Is Imperative](#note-aset-is-imperative-1-2 "It is true
that ASET' is an actual imperative which produces a side effect, and is not expressed
applicatively. ASET' is used only for two purposes in practice: to initialize global
variables (often relating to MacLISP primitives), and to implement objects with state ..."){#xaset-is-imperative1}}
--></p>
<p>None of this is particularly new; theoreticians have modelled
imperative constructs in these terms for years. What is new, we think,
is the serious proposal that a practical interpreter and compiler can be
designed for a language in which such models serve as the <em>sole
definitions</em> of these imperative constructs. <!--
{Note [Dijkstra's Opinion](#note-dijkstras-opinion "In [Dijkstra] a remark is
made to the effect that defining the while-do construct in terms of function calls seems
unusually clumsy. In [Steele] we reply that this is due partly to Dijkstra’s choice of
ALGOL for expressing the definition. ..."){#xdijkstras-opinion}}
--> This approach has both advantages and disadvantages.</p>
<p>One advantage is that the base language is small. A simple-minded
interpreter or compiler can be written in a few hours. (We have
re-implemented the <span class="sc">SCHEME</span> interpreter from
scratch a dozen times or more to test various representation strategies;
this was practical only because of the small size of the language.
Similarly, the <span class="sc">CHEAPY</span> compiler is fewer than ten
pages of code, and could be rewritten in a day or less.) Once the basic
interpreter is written, the macro definitions for all the complex
constructs can be used without revision. Moreover, the same macro
definitions can be used by both interpreter and compiler (or by several
versions of interpreter and compiler!). Excepting the very few
primitives such as <code>LAMBDA</code> and <code>IF</code>, it is not
necessary to “implement a construct twice”, once each in interpreter and
compiler.</p>
<p>Another advantage is that new macros are very easy to write (using
facilities provided in <span class="sc">SCHEME</span>). One can easily
invent a new kind of <code>DO</code> loop, for example, and implement it
in <span class="sc">SCHEME</span> for both interpreter and all compilers
in less than five minutes.</p>
<p>A third advantage is that the attention of the compiler can be
focused on the basic constructs. Rather than having specialized code for
two dozen different constructs, the compiler can have much deeper
knowledge about each of a few basic constructs. One might object that
this “deeper knowledge” consists of recognizing the two dozen special
cases represented by the separate constructs of the former case. This is
true to some extent. It is also true, however, that in the latter case
such deep knowledge will carry over to any new constructs which are
invented and represented as macros.</p>
<p>Among the disadvantages of the macro approach are lack of speed and
the discarding of information. Many people have objected that macros are
of necessity slower than, say, the <code>FSUBR</code> implementation
used by most <span class="sc">LISP</span> systems. This is true in many
current interpretive implementations, but need not be true of compilers
or more cleverly designed interpreters. Moreover, the <code>FSUBR</code>
implementation is not general; it is very hard for a user to write a
meaningful <code>FSUBR</code> and then describe to the compiler the best
way to compile it. The macro approach handles this difficulty
automatically. We do not object to the use of the <code>FSUBR</code>
mechanism as a special-case “speed hack” to improve the performance of
an interpreter, but we insist on recognizing the fact that it is not as
generally useful as the macro approach.</p>
<p>Another objection relating to speed is that the macros produce
convoluted code involving the temporary creation and subsequent
invocation of many closures. We feel, first of all, that the macro
writer should concern himself more with producing correct code than fast
code. Furthermore, convolutedness can be eliminated by a few simple
optimization techniques in the compiler, to be discussed below. Finally,
function calls need not be as expensive as is popularly supposed. [<a href="#steele-1977a-1-2-3-4" id="xsteele-1977a2" title="[2] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele
1977A</a>]</p>
<p>Information is discarded by macros in the situation, for example,
where a <code>DO</code> macro expands into a large mess that is not
obviously a simple loop; later compiler analysis must recover this
information. This is indeed a problem. We feel that the compiler is
probably better off having to recover the information anyway, since a
deep analysis allows it to catch other loops which the user did not use
<code>DO</code> to express for one reason or another. Another is the
possibility that <code>DO</code> could leave clues around in the form of
declarations if desired.</p>
<p><hr></p>
</section>
<section id="the-imperative-treatment-of-applicative-constructs" class="level2">
<h2><a href="#contents">6. The Imperative Treatment of Applicative
Constructs</a></h2>
<p>Given the characteristics of lexical scoping and tail-recursive
invocations, it is possible to assign a peculiarly imperative
interpretation to the applicative constructs of <span class="sc">SCHEME</span>, which consists primarily of treating a
function call as a <code>GOTO</code>. More generally, a function call is
a <code>GOTO</code> that can pass one or more items to its target; the
special case of passing no arguments is precisely a <code>GOTO</code>.
It is never necessary for a function call to save a return address of
any kind. It is true that return addresses are generated, but we adopt
one of two other points of view, depending on context. One is that the
return address, plus any other data needed to carry on the computation
after the called function has returned (such as previously computed
intermediate values and other return addresses) are considered to be
packaged up into an additional argument (the
<strong>continuation</strong>) which is passed to the target. This lends
itself to a non-functional interpretation of <code>LAMBDA</code>, and a
method of expressing programs called the continuation-passing style
(similar to the message-passing actors paradigm), to be discussed
further below. The other view, more intuitive in terms of the
traditional stack implementation, is that the return address should be
pushed before evaluating arguments rather than before calling a
function. This view leads to a more uniform function-calling discipline,
and is discussed in [<a href="#steele-1976b-1-2-3-4-5-6" id="xsteele-1976b6" title="[6] Steele 1976, LAMBDA: The Ultimate Declarative">Steele
1976B</a>] and [<a href="#steele-1977a-1-2-3-4" id="xsteele-1977a3" title="[3] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele
1977A</a>].</p>
<p>We are led by this point of view to consider a compilation strategy
in which function calling is to be considered very cheap (unlike the
situation with <span class="sc">PL/I</span> and <span class="sc">ALGOL</span>, where programmers avoid procedure calls like
the plague — see [<a href="#steele-1977a-1-2-3-4" id="xsteele-1977a4" title="[4] Steele 1977, Debunking the &#39;Expensive Procedure Call&#39; Myth">Steele
1977A</a>] for a discussion of this). In this light the code produced by
the sample macros above does not seem inefficient, or even particularly
convoluted. Consider the expansion of <code>(OR a b c)</code>:</p>
<pre><code>    ((LAMBDA (V R) (IF V V (R)))
     a
     (LAMBDA () ((LAMBDA (V R) (IF V V (R)))
                 b
                 (LAMBDA () ((LAMBDA (V R) (IF V V (R)))
                             c (LAMBDA () &#39;NIL))))))</code></pre>
<p>Then we might imagine the following (slightly contrived) compilation
scenario. First, for expository purposes, we shall rename the variables
in order to be able to distinguish them.</p>
<pre><code>    ((LAMBDA (V1 R1) (IF V1 V1 (R1)))
     a
     (LAMBDA () ((LAMBDA (V2 R2) (IF V2 V2 (R2)))
                 b
                 (LAMBDA () ((LAMBDA (V3 R3) (IF V3 V3 (R3)))
                             c
                             (LAMBDA () &#39;NIL))))))</code></pre>
<p>We shall assign a generated name to each
<code>LAMBDA</code>-expression, which we shall notate by writing the
name after the word <code>LAMBDA</code>. These names will be used as
tags in the output code.</p>
<pre><code>    ((LAMBDA name1 (V1 R1) (IF V1 V1 (R1)))
     a
     (LAMBDA name2 () ((LAMBDA name3 (V2 R2) (IF V2 V2 (R2)))
                       b
                       (LAMBDA name4 () ((LAMBDA name5 (V3 R3) (IF V3 V3 (R3)))
                                         c
                                         (LAMBDA name6 () &#39;NIL))))))</code></pre>
<p>Next, a simple analysis shows that the variables <code>R1</code>,
<code>R2</code>, and <code>R3</code> always denote the
<code>LAMBDA</code>-expressions named <code>name2</code>,
<code>name4</code>, and <code>name6</code>, respectively. Now an
optimizer might simply have substituted these values into the bodies of
<code>name1</code>, <code>name3</code>, and <code>name5</code> using the
rule of beta-conversion, but we shall not apply that technique here.
Instead we shall compile the six functions in a straightforward manner.
We make use of the additional fact that all six functions are closed in
identical environments (we count two environments as identical if they
involve the same variable bindings, regardless of the number of “frames”
involved; that is, the environment is the same inside and outside a
<code>(LAMBDA () ...))</code>. Assume a simple target machine with
argument registers called <code>reg1</code>, <code>reg2</code>, etc.</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
            LOAD reg2,[name2]       ;[name2] is the closure for name2
            CALL-FUNCTION 2,[namel] ;call name1 with 2 arguments

    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1
    name1a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name2:  &lt;code for b&gt;            ;result in reg1
            LOAD reg2,[name4]       ;[name4] is the closure for name4
            CALL-FUNCTION 2,[name3] ;call name3 with 2 arguments

    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1
    name3a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name4:  &lt;code for c&gt;            ;result in reg1
            LOAD reg2,[name6]       ;[name6] is the closure for name6
            CALL-FUNCTION 2,[name5] ;call name5 with 2 arguments

    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1
    name5a: CALL-FUNCTION 0,reg2    ;call function in reg2, 0 arguments

    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>Now we make use of our knowledge that certain variables always denote
certain functions, and convert <code>CALL-FUNCTION</code> of a known
function to a simple <code>GOTO</code>. (We have actually done things
backwards here; in practice this knowledge is used <em>before</em>
generating any code. We have fudged over this issue here, but will
return to it later. Our purpose here is merely to demonstrate the
treatment of function calls as <code>GOTO</code>s.)</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
            LOAD reg2,[name2]       ;[name2] is the closure for name2
            GOTO name1

    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1
    name1a: GOTO name2

    name2:  &lt;code for b&gt;            ;result in reg1
            LOAD reg2,[name4]       ;[name4] is the closure for name4
            GOTO name3

    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1
    name3a: GOTO name4

    name4:  &lt;code for c&gt;            ;result in reg1
            LOAD reg2,[name6]       ;[name6] is the closure for name6
            GOTO name5

    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1
    name5a: GOTO name6

    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>The construction <code>[foo]</code> indicates the creation of a
closure for <code>foo</code> in the current environment. This will
actually require additional instructions, but we shall ignore the
mechanics of this for now since analysis will remove the need for the
construction in this case. The fact that the <em>only</em> references to
the variables <code>R1</code>, <code>R2</code>, and <code>R3</code> are
function calls can be detected and the unnecessary <code>LOAD</code>
instructions eliminated. (Once again, this would actually be determined
ahead of time, and no <code>LOAD</code> instructions would be generated
in the first place. All of this is determined by a general pre-analysis,
rather than a peephole post-pass.) Moreover, a <code>GOTO</code> to a
tag which immediately follows the <code>GOTO</code> can be
eliminated.</p>
<pre><code>    main:   &lt;code for a&gt;            ;result in reg1
    name1:  JUMP-IF-NIL reg1,name1a
            RETURN                  ;return the value in reg1

    name1a:
    name2:  &lt;code for b&gt;            ;result in reg1
    name3:  JUMP-IF-NIL reg1,name3a
            RETURN                  ;return the value in reg1

    name3a:
    name4:  &lt;code for c&gt;            ;result in reg1
    name5:  JUMP-IF-NIL reg1,name5a
            RETURN                  ;return the value in reg1

    name5a:
    name6:  LOAD reg1,&#39;NIL          ;constant NIL in reg1
            RETURN</code></pre>
<p>This code is in fact about what one would expect out of an ordinary
<span class="sc">LISP</span> compiler. (There is admittedly room for a
little more improvement.) <span class="sc">RABBIT</span> indeed produces
code of essentially this form, by the method of analysis outlined
here.</p>
<p>Similar considerations hold for the <code>BLOCK</code> macro.
Consider the expression <code>(BLOCK a b c)</code>; conceptually this
should perform <code>a</code>, <code>b</code>, and <code>c</code>
sequentially. Let us examine the code produced:</p>
<pre><code>    main:   &lt;code for a&gt;
    name1:
    name2:  &lt;code for b&gt;
    name3:
    name4:  &lt;code for c&gt;
            RETURN</code></pre>
<p>What more could one ask for?</p>
<p>Notice that this has fallen out of a general strategy involving only
an approach to compiling <em>function calls</em>, and has involved no
special knowledge of <code>OR</code> or <code>BLOCK</code> not encoded
in the macro rules. The cases shown so far are actually special cases of
a more general approach, special in that all the conceptual closures
involved are closed in the same environment, and called from places that
have not disturbed that environment, but only used “registers.” In the
more general case, the environments of caller and called function will
be different. This divides into two subcases, corresponding to whether
the closure was created by a simple <code>LAMBDA</code> or by a
<code>LABELS</code> construction. The latter involves circular
references, and so is somewhat more complicated; but it is easy to show
that in the former case the environment of the caller must be that of
the (known) called function, possibly with additional values added on.
This is a consequence of lexical scoping. As a result, the function call
can be compiled as a <code>GOTO</code> preceded by an environment
adjustment which consists merely of lopping off some leading portion of
the current one (intuitively, one simply “pops the unnecessary crud off
the stack”). <code>LABELS</code>-closed functions also can be treated in
this way, if one closes all the functions in the same way (which <span class="sc">RABBIT</span> presently does, but this is not always
desirable). If one does, then it is easy to see the effect of expanding
a <code>PROG</code> into a giant <code>LABELS</code> as outlined in [<a href="#steele-1976a-1-2-3" id="xsteele-1976a3" title="[3] Steele and Sussman 1976, LAMBDA: The Ultimate Imperative">Steele
1976A</a>] and elsewhere: normally, a <code>GOTO</code> to a tag at the
same level of PROG will involve no adjustment of environment, and so
compile into a simple <code>GOTO</code> instruction, whereas a
<code>GOTO</code> to a tag at an outer level of PROG probably will
involve adjusting the environment from that of the inner
<code>PROG</code> to that of the outer. All of this falls out of the
proper imperative treatment of function calls.</p>
<section id="a.-optimization" class="level3">
<h3><a href="#contents">A.   Optimization</a></h3>
<p>Once the preliminary analysis is done, the optimization phase
performs certain transformations on the code. The result is an
equivalent program which will (probably) compile into more efficient
code. This new program is itself structurally a valid <span class="sc">SCHEME</span> program; that is, all transformations are
contained within the language. The transformations are thus similar to
those performed on macro calls, consisting of a syntactic rewriting of
an expression, except that the situations where such transformations are
applicable are more easily recognized in the case of macro calls. It
should be clear that the optimizer and the macro-functions are
conceptually at the same level in that they may be written in the same
meta-language that operates on representations of <span class="sc">SCHEME</span> programs. <!--
{Note [Non-deterministic Optimization](#note-non-deterministic-optimization "To simplify
the implementation, RABBIT uses only a deterministic (and very conservative) optimizer.
Ideally, an optimizer would be non-deterministic in structure ..."){#xnon-deterministic-optimization}}
--></p>
<p>The simplest transformation is that a combination whose function
position contains a <code>LAMBDA</code>-expression and which has no
arguments can be replaced by the body of the
<code>LAMBDA</code>-expression:</p>
<pre><code>    ((LAMBDA () body))  =&gt;  body</code></pre>
<p>There are two transformations on <code>IF</code> expressions. One is
simply that an <code>IF</code> expression with a constant predicate is
simplified to its consequent or alternative (resulting in elimination of
dead code). The other was adapted from [<a href="#standish-1976-1-2" id="xstandish-19762" title="[2] Standish etal 1976, The Irvine Program Transformation Catalogue">Standish
1976</a>], which does not have this precise transformation listed, but
gives a more general rule. In its original form this transformation
is:</p>
<pre><code>    (IF (IF a b c) d e)  =&gt;  (IF a (IF b d e) (IF c d e))</code></pre>
<p>One problem with this is that the code for d and e is duplicated.
This can be avoided by the use of <code>LAMBDA</code>-expressions:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF a
                 (IF b (Q1) (Q2))
                 (IF c (Q1) (Q2))))
     (LAMBDA () d)
     (LAMBDA () e))</code></pre>
<p>As before, there is no problem of name conflicts with Q1 and Q2.
While this code may appear unnecessarily complex, the calls to the
functions <code>Q1</code> and <code>Q2</code> will, typically, as shown
above, be compiled as simple <code>GOTO</code>s. As an example, consider
the expression:</p>
<pre><code>    (IF (AND PRED1 PRED2) (PRINT &#39;WIN) (ERROR &#39;LOSE))</code></pre>
<p>Expansion of the <code>AND</code> macro will result in:</p>
<pre><code>    (IF ((LAMBDA (V R) (IF V (R) &#39;NIL))
         PRED1
         (LAMBDA () PRED2))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>(For expository clarity we will not bother to rename all the
variables, inasmuch as they are already distinct.) Because
<code>V</code> and <code>R</code> have only one reference apiece (and
there are no possible interfering side-effects), the corresponding
arguments can be substituted for them.</p>
<pre><code>    (IF ((LAMBDA (V R) (IF PRED1 ((LAMBDA () PRED2)) &#39;NIL))
         PRED1
         (LAMBDA () PRED2))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE) )</code></pre>
<p>Now, since <code>V</code> and <code>R</code> have no referents at
all, they and the corresponding arguments can be eliminated, since the
arguments have no side-effects.</p>
<pre><code>    (IF ((LAMBDA () (IF PRED1 ((LAMBDA () PRED2)) &#39;NIL)))
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>Next, the combination <code>((LAMBDA () ...))</code> is eliminated in
two places:</p>
<pre><code>    (IF (IF PRED1 PRED2 &#39;NIL)
        (PRINT &#39;WIN)
        (ERROR &#39;LOSE))</code></pre>
<p>Now, the transformation on the nested <code>IF</code>’s:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF PRED1
                 (IF PRED2 (Q1) (Q2))
                 (IF &#39;NIL (Q1) (Q2))))
     (LAMBDA () (PRINT &#39;WIN))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>Now one <code>IF</code> has a constant predicate and can be
simplified:</p>
<pre><code>    ((LAMBDA (Q1 Q2)
             (IF PRED1
                 (IF PRED2 (Q1) (Q2))
                 (Q2)))
     (LAMBDA () (PRINT &#39;WIN))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>The variable <code>Q1</code> has only one referent, and so we
substitute in, eliminate the variable and argument, and collapse a
<code>((LAMBDA () ...))</code>:</p>
<pre><code>    ((LAMBDA (Q2)
             (IF PRED1
                 (IF PRED2 (PRINT &#39;WIN) (Q2))
                 (Q2)))
     (LAMBDA () (ERROR &#39;LOSE)))</code></pre>
<p>Recalling that <code>(Q2)</code> is, in effect, a <code>GOTO</code>
branching to the common piece of code, and that by virtue of later
analysis no actual closure will be created for either
<code>LAMBDA</code>-expression, this result is quite reasonable. <!--
{Note [Evaluation for Control](#note-evaluation-for-control-1-2 "It is usual in a compiler
to distinguish at least three 'evaluation contexts': value, control, and effect. 
(See [Wulf 1975], for example.) Evaluation for control occurs in the predicate of an IF, 
where the point is not so much to produce a data object as simply to decide whether it is 
true or false. ..."){#xevaluation1}}
--></p>
<p><hr></p>
</section>
<section id="b.-environment-and-closure-analysis" class="level3">
<h3><a href="#contents">B.   Environment and Closure Analysis</a></h3>
<p>This phase consists of four passes over the CPS version of the
program. As with the earlier preliminary analysis, each pass determines
one related set of information and attaches this information to nodes of
the program tree and to property lists.</p>
<p>The first pass <code>(CENV-ANALYZE)</code> analyzes variable
references for the CPS version in a manner similar to that of the first
pass of the preliminary analysis. The results of this previous analysis
are used here in the case of trivial expressions; with this exception
the analysis is redone completely, because additional variables are
introduced by the CPS conversion. (None of these new variables can
appear in an <code>ASET&#39;</code>, however, and so the analysis of written
variables need not be done over.) In addition, for each variable
reference which does not occur in the function position of a
combination, we mark that variable with a non-nil
<code>VARIABLE-REFP</code> property, used later to determine whether
closures need to be created for known functions. The second pass
<code>(BIND-ANALYZE)</code> determines for each
<code>LAMBDA</code>-expression whether a closure will be needed for it
at run time. There are three possibilities:</p>
<ol type="1">
<li>If the function denoted by the <code>LAMBDA</code>-expression is
bound to some variable, and that variable is referenced other than in
function position, then the closure is being treated as data, and must
be a full (standard <code>CBETA</code> format) closure. If the function
itself occurs in non-function position other than in a
<code>LAMBDA</code>-combination, it must be fully closed.</li>
<li>If the closure is bound to some variable, and that variable is
referenced only in function position, but some of these references occur
within other partially or fully closed functions, then this function
must be partially closed. By this we mean that the environment for the
closure must be “consed up”, but no pointer to the code need be added on
as for a full closure. This function will always be called from places
that know the name of the function and so can just perform a
<code>GO</code> to the code, but those such places which are within
closures must have a complete copy of the necessary environment.</li>
<li>In other cases (functions bound to variables referenced only in
function position and never within a closed function, or functions
occurring in function position of <code>LAMBDA</code>-combinations), the
function need not be closed. This is because the environment can always
be fully recovered from the environment at the point of call.</li>
</ol>
<p>In order to determine this information, it is necessary to determine,
for each node, the set of variables referred to from within closed
functions at or below that node. Thus this process and the process of
determining functions to close are highly interdependent, and so must be
accomplished in a single pass.</p>
<p><hr></p>
</section>
</section>
<section id="conclusions" class="level2">
<h2><a href="#contents">7. Conclusions</a></h2>
<p>Lexical scoping, tail-recursion, the conceptual treatment of
functions (as opposed to representations thereof) as data objects, and
the ability to notate “anonymous” functions make <span class="sc">SCHEME</span> an excellent language in which to express
program transformations and optimizations. Imperative constructs are
easily modelled by applicative definitions. Anonymous functions make it
easy to avoid needless duplication of code and conflict of variable
names. A language with these properties is useful not only at the
preliminary optimization level, but for expressing the results of
decisions about order of evaluation and storage of temporary quantities.
These properties make <span class="sc">SCHEME</span> as good a candidate
as any for an <span class="sc">UNCOL</span>. The proper treatment of
functions and function calls leads to generation of excellent imperative
low-level code.</p>
<p>We have emphasized the ability to treat functions as data objects. We
should point out that one might want to have a very simple run-time
environment which did not support complex environment structures, or
even stacks. Such an end environment does not preclude the use of the
techniques described here. Many optimizations result in the elimination
of <code>LAMBDA</code>-expressions; post CPS-conversion analysis
eliminates the need to close many of the remaining
<code>LAMBDA</code>-expressions. One could use the macros and internal
representations of <span class="sc">RABBIT</span> to describe
intermediate code transformations, and require that the final code not
actually create any closures. As a concrete example, imagine writing an
operating system in <span class="sc">SCHEME</span>, with machine words
as the data domain (and functions excluded from the run-time data
domain). We could still meaningfully write, for example:</p>
<pre><code>    (IF (OR (STOPPED (PROCESS I))
            (AWAITING-INPUT (PROCESS I)))
        (SCHEDULE-LOOP (+ I 1))
        (SCHEDULE-PROCESS I))</code></pre>
<p>While the intermediate expansion of this code would conceptually
involve the use of functions as data objects, optimizations would reduce
the final code to a form which did not require closures at run time.</p>
<p><hr></p>
</section>
<section id="references" class="level2">
<h2><a href="#contents">References</a></h2>
<section id="section" class="level3">
<h3></h3>
<section id="allen-1972" class="level4">
<h4>[Allen 1972] <span class="fr">*</span><br />
</h4>
<p>Allen, Frances E., and Cocke, John. <a href="https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf" title="www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf"><em>A
Catalogue of Optimizing Transformations</em></a>. In Rustin, Randall
(ed.), Design and Optimization of Compilers. Proc. Courant Comp. Sci.
Symp. 5. Prentice-Hall (Englewood Cliffs, N.J., 1972).</p>
</section>
<section id="bobrow-1973" class="level4">
<h4>[Bobrow 1973] <span class="fr">*</span><br />
</h4>
<p>Bobrow, Daniel G. and Wegbreit, Ben. <a href="https://dl.acm.org/doi/10.1145/362375.362379" title="dl.acm.org/doi/10.1145/362375.362379"><em>A Model and Stack
Implementation of Multiple Environments</em></a>. CACM 16, 10 (October
1973) pp. 591-603.</p>
</section>
<section id="church-1941-1-2" class="level4">
<h4>[Church 1941] <span class="fr"><a href="#xchurch-19411">1</a>, <a href="#xchurch-19412">2</a></span><br />
</h4>
<p>Church, Alonzo. <a href="https://archive.org/details/AnnalsOfMathematicalStudies6ChurchAlonzoTheCalculiOfLambdaConversionPrincetonUniversityPress1941" title="archive.org/details/AnnalsOfMathematicalStudies6ChurchAlonzoTheCalculiOfLambdaConversionPrincetonUniversityPress1941"><em>The
Calculi of Lambda Conversion</em></a>. Annals of Mathematics Studies
Number 6. Princeton University Press (Princeton, 1941). Reprinted by
Klaus Reprint Corp. (New York, 1965).</p>
</section>
<section id="coleman-1974" class="level4">
<h4>[Coleman 1974] <a href="#xcoleman-1974" class="fr">^</a><br />
</h4>
<p>Coleman, Samuel S. <a href="https://.invalid/_no_online_copy_found_" title="No online copy found"><em>JANUS: A Universal Intermediate
Language</em></a>, PhD thesis, University of Colorado, 1974.</p>
<div class="ti">
<p>{{See Coleman etal 1974 <a href="https://onlinelibrary.wiley.com/doi/10.1002/spe.4380040103" title="onlinelibrary.wiley.com/doi/10.1002/spe.4380040103"><em>The
mobile programming system, Janus</em></a>.}}</p>
</div>
</section>
<section id="dijkstra-1976" class="level4">
<h4>[Dijkstra 1976] <span class="fr">*</span><br />
</h4>
<p>Dijkstra, Edsger W. <a href="https://archive.org/details/disciplineofprog0000dijk" title="archive.org/details/disciplineofprog0000dijk"><em>A Discipline of
Programming</em></a>. Prentice-Hall (Englewood Cliffs, N.J., 1976)</p>
</section>
<section id="doyle-1977" class="level4">
<h4>[Doyle 1977] <a href="#xdoyle-1977" class="fr">^</a><br />
</h4>
<p>Jon Doyle, Johan de Kleer, Gerald Jay Sussman, and Guy L. Steele Jr.
<a href="https://dl.acm.org/doi/pdf/10.1145/872734.806940" title="dl.acm.org/doi/pdf/10.1145/872734.806940"><em>AMORD: Explicit
Control of Reasoning</em></a>, Proc. AI and Programming Languages Conf.,
SIGPLAN Notices 12, 8, SIGART Newsletter 64, 1977.</p>
</section>
<section id="geschke-1972" class="level4">
<h4>[Geschke 1972] <span class="fr">*</span><br />
</h4>
<p>Geschke, Charles M. <a href="https://www.proquest.com/openview/257cdb472f7f80955f5e5be70cb1f2f6/1.pdf" title="www.proquest.com/openview/257cdb472f7f80955f5e5be70cb1f2f6/1.pdf"><em>Global
program optimizations.</em></a>, PhD thesis, Carnegie-Mellon University,
1972.</p>
</section>
<section id="gries-1971" class="level4">
<h4>[Gries 1971] <span class="fr">*</span><br />
</h4>
<p>Gries, David <a href="https://archive.org/details/compilerconstruc0000grie" title="archive.org/details/compilerconstruc0000grie"><em>Compiler
Construction for Digital Computers</em></a>, John Wiley and Sons,
1971.</p>
</section>
<section id="landin-1965" class="level4">
<h4>[Landin 1965] <a href="#xlandin-1965" class="fr">^</a><br />
</h4>
<p>Landin, Peter J. <a href="https://dl.acm.org/doi/10.1145/363744.363749" title="dl.acm.org/doi/10.1145/363744.363749"><em>A Correspondence
between ALGOL 60 and Church’s Lambda-Notation</em></a>. CACM Vol. 8,
No. 2-3, 1965. (<a href="https://dl.acm.org/doi/10.1145/363744.363749" title="dl.acm.org/doi/10.1145/363744.363749">February</a> and <a href="https://dl.acm.org/doi/10.1145/363791.363804" title="dl.acm.org/doi/10.1145/363791.363804">March</a>).</p>
</section>
<section id="mccarthy-1962" class="level4">
<h4>[McCarthy 1962] <a href="#xmccarthy-1962" class="fr">^</a><br />
</h4>
<p>McCarthy, John, et al. <a href="https://apps.dtic.mil/sti/tr/pdf/AD0406138.pdf" title="apps.dtic.mil/sti/tr/pdf/AD0406138.pdf"><em>LISP 1.5 Programmer’s
Manual</em></a>. The MIT Press (Cambridge, 1962).</p>
<div class="ti">
<p>{{See also McCarthy et al <a href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf" title="www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf"><em>LISP
1.5 Programmer’s Manual</em></a> [Second edition] The MIT Press
(Cambridge, 1965).}}</p>
</div>
</section>
<section id="moon-1974-1-2" class="level4">
<h4>[Moon 1974] <span class="fr"><a href="#xmoon-19741">1</a>, <a href="#xmoon-19742">2</a></span><br />
</h4>
<p>Moon, David A. <a href="https://www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf" title="www.softwarepreservation.org/projects/LISP/MIT/Moon-MACLISP_Reference_Manual-Apr_08_1974.pdf"><em>MACLISP
Reference Manual, Revision 0</em></a>. Project MAC, MIT (Cambridge,
April 1974).</p>
</section>
<section id="moses-1970-1-2" class="level4">
<h4>[Moses 1970] <span class="fr"><a href="#xmoses-19701">1</a>, <a href="#xmoses-19702">2</a></span><br />
</h4>
<p>Moses, Joel. <a href="https://dspace.mit.edu/handle/1721.1/5854" title="dspace.mit.edu/handle/1721.1/5854"><em>The Function of FUNCTION
in LISP</em></a>. AI Memo 199, MIT AI Lab (Cambridge, June 1970).</p>
</section>
<section id="reynolds-1972" class="level4">
<h4>[Reynolds 1972] <a href="#xreynolds-1972" class="fr">^</a><br />
</h4>
<p>Reynolds, John C. <a href="https://dl.acm.org/doi/10.1145/800194.805852" title="dl.acm.org/doi/10.1145/800194.805852"><em>Definitional
Interpreters for Higher Order Programming Languages</em></a>. ACM
Conference Proceedings 1972.</p>
</section>
<section id="sammet-1969" class="level4">
<h4>[Sammet 1969] <a href="#xsammet-1969" class="fr">^</a><br />
</h4>
<p>Sammet, Jean E. <a href="https://archive.org/details/programminglangu00unse" title="archive.org/details/programminglangu00unse"><em>Programming
Languages: History and Fundamentals</em></a>, Prentice-Hall (Englewood
Cliffs, N.J., 1969).</p>
</section>
<section id="standish-1976-1-2" class="level4">
<h4>[Standish 1976] <span class="fr"><a href="#xstandish-19761">1</a>,
<a href="#xstandish-19762">2</a></span><br />
</h4>
<p>Standish, T. A. etal. <a href="https://escholarship.org/uc/item/79p8s9qv" title="escholarship.org/uc/item/79p8s9qv"><em>The Irvine Program
Transformation Catalogue</em></a>, University of California TR#161,
1976.</p>
</section>
<section id="steele-1976a-1-2-3" class="level4">
<h4>[Steele 1976A] <span class="fr"><a href="#xsteele-1976a1">1</a>, <a href="#xsteele-1976a2">2</a>, <a href="#xsteele-1976a3">3</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr., and Sussman, Gerald Jay. <a href="https://dspace.mit.edu/handle/1721.1/5790" title="dspace.mit.edu/handle/1721.1/5790"><em>LAMBDA: The Ultimate
Imperative</em></a>. AI Lab Memo 353. MIT (Cambridge, March 1976).<br />
{{HTML and PDF transcriptions at <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</section>
<section id="steele-1976b-1-2-3-4-5-6" class="level4">
<h4>[Steele 1976B] <span class="fr"><a href="#xsteele-1976b1">1</a>, <a href="#xsteele-1976b2">2</a>, <a href="#xsteele-1976b3">3</a>, <a href="#xsteele-1976b4">4</a>, <a href="#xsteele-1976b5">5</a>, <a href="#xsteele-1976b6">6</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr. <a href="https://dspace.mit.edu/handle/1721.1/6091" title="dspace.mit.edu/handle/1721.1/6091"><em>LAMBDA: The Ultimate
Declarative</em></a>. AI Memo 379. MIT AI Lab (Cambridge, November
1976).<br />
{{HTML and PDF transcriptions at <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</section>
<section id="steele-1977a-1-2-3-4" class="level4">
<h4>[Steele 1977A] <span class="fr"><a href="#xsteele-1977a1">1</a>, <a href="#xsteele-1977a2">2</a>, <a href="#xsteele-1977a3">3</a>, <a href="#xsteele-1977a4">4</a></span><br />
</h4>
<p>Steele, Guy Lewis Jr. <a href="https://dl.acm.org/doi/abs/10.1145/800179.810196" title="dl.acm.org/doi/abs/10.1145/800179.810196"><em>Debunking the
‘Expensive Procedure Call’ Myth</em></a> submitted to the 77 ACM
National Conference.</p>
<div class="ti">
<p>{{See also <a href="https://dspace.mit.edu/handle/1721.1/5753" title="dspace.mit.edu/handle/1721.1/5753"><em>Debunking the ‘Expensive
Procedure Call’ Myth, or, Procedure Call Implementations Considered
Harmful, or, Lambda: The Ultimate GOTO</em></a> MIT AI Memo 443, October
1977.<br />
HTML and PDF transcriptions at <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</div>
</section>
<section id="steele-1977b" class="level4">
<h4>[Steele 1977B] <span class="fr">*</span><br />
</h4>
<p>Steele, Guy Lewis Jr. <a href="https://.invalid/_no_online_copy_found_" title="No online copy found"><em>Compiler Optimization Based on Viewing
LAMBDA as Rename plus GOTO</em></a>. S.M. Thesis. MIT (Cambridge, May
1977).</p>
<div class="ti">
<p>{{See <em>Compiler Optimization Based on Viewing LAMBDA as RENAME
plus GOTO</em> in <a href="https://archive.org/details/artificialintell0002unse" title="archive.org/details/artificialintell0002unse"><em>Artificial
Intelligence, an MIT Perspective, Volume 2</em></a> (MIT Press 1979)
pp401-431. }}</p>
</div>
</section>
<section id="steele-1978" class="level4">
<h4>{{[Steele 1978] <span class="fr"><a href="#xsteele-1978">^</a></span><br />
</h4>
<div class="in">
<p>Steele, Guy Lewis Jr. <a href="https://dspace.mit.edu/handle/1721.1/6913" title="dspace.mit.edu/handle/1721.1/6913"><em>RABBIT: A Compiler for
SCHEME</em></a>. AITR-474 MIT May 1978.<br />
HTML and PDF transcriptions at <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.
}}</p>
</div>
</section>
<section id="steele-1979" class="level4">
<h4>{{[Steele 1979] <span class="fr"><a href="#xsteele-1979">^</a></span></h4>
<div class="in">
<p>Steele, Guy Lewis Jr. [<em>Compiler Optimization Based on Viewing
LAMBDA as RENAME plus GOTO</em> in <a href="https://archive.org/details/artificialintell0002unse" title="archive.org/details/artificialintell0002unse"><em>Artificial
Intelligence, an MIT Perspective, Volume 2</em></a> (MIT Press 1979)
pp401-431. }}</p>
</div>
</section>
<section id="stoy-1974" class="level4">
<h4>[Stoy 1974] <a href="#xstoy-1974" class="fr">^</a><br />
</h4>
<p>Stoy, Joseph <a href="https://.invalid/_no_online_copy_found_" title="No online copy found"><em>The Scott-Strachey Approach to the
Mathematical Semantics of Programming Languages</em></a>, MIT Laboratory
for Computer Science, 1974.</p>
<div class="ti">
<p>{{See Stoy, Joseph E. <a href="https://archive.org/details/denotationalsema0000jose" title="archive.org/details/denotationalsema0000jose"><em>Denotational
Semantics: The Scott-Strachey Approach to Programming Language
Theory</em></a> MIT Press (Cambridge, 1977). }}</p>
</div>
</section>
<section id="sussman-1975-1-2-3" class="level4">
<h4>{{[Sussman 1975] <span class="fr"><a href="#xsussman-19751">1</a>,
<a href="#xsussman-19752">2</a>, <a href="#xsussman-19753">3</a></span><br />
</h4>
<div class="in">
<p>Sussman, Gerald Jay, and Steele, Guy L. Jr. <a href="https://dspace.mit.edu/handle/1721.1/5794" title="dspace.mit.edu/handle/1721.1/5794"><em>SCHEME: An Interpreter for
Extended Lambda Calculus</em></a>. AI Lab Memo 349. MIT (Cambridge,
December 1975).<br />
HTML and PDF transcriptions at <a href="https://research.scheme.org/lambda-papers/" title="research.scheme.org/lambda-papers/">research.scheme.org/lambda-papers/</a>.<br />
Republished with notes as<br />
Sussman, G.J., Steele, G.L. <a href="https://www.researchgate.net/publication/227098423_Scheme_A_Interpreter_for_Extended_Lambda_Calculus" title="www.researchgate.net/publication/227098423_Scheme_A_Interpreter_for_Extended_Lambda_Calculus"><em>Scheme:
A Interpreter for Extended Lambda Calculus</em></a>. Higher-Order and
Symbolic Computation 11, 405–439 (1998).
https://doi.org/10.1023/A:1010035624696<br />
See also: Sussman, G.J., Steele, G.L. <a href="https://doi.org/10.1023/A:1010079421970" title="doi.org/10.1023/A:1010079421970"><em>The First Report on Scheme
Revisited</em></a>. Higher-Order and Symbolic Computation 11, 399–404
(1998). https://doi.org/10.1023/A:1010079421970 }}</p>
</div>
</section>
<section id="teitelman-1975" class="level4">
<h4>[Teitelman 1975] <a href="#xteitelman-1975" class="fr">^</a><br />
</h4>
<p>Teitelman, Warren. <a href="https://.invalid/_no_online_copy_found_" title="No online copy found"><em>InterLISP Reference Manual Revised
edition</em></a>. Xerox Palo Alto Research Center (Palo Alto,
1975).<br />
{{see <a href="https://www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_Oct_1974.pdf" title="www.bitsavers.org/pdf/xerox/interlisp/Interlisp_Reference_Manual_Oct_1974.pdf"><em>InterLISP
Reference Manual</em></a>, 1974 }}</p>
</section>
<section id="wand-1976" class="level4">
<h4>[Wand 1976] <span class="fr">*</span><br />
</h4>
<p>Wand, Mitchell and Friedman, Daniel P. <a href="https://legacy.cs.indiana.edu/ftp/techreports/TR55.pdf" title="legacy.cs.indiana.edu/ftp/techreports/TR55.pdf"><em>Compiling
Lambda Expressions Using Continuations</em></a>, Technical Report 55,
Indiana University, 1976.</p>
</section>
<section id="wulf-1975" class="level4">
<h4>[Wulf 1975] <span class="fr">*</span><br />
</h4>
<p>Wulf, William A., et al. <a href="https://apps.dtic.mil/sti/citations/AD0773838" title="apps.dtic.mil/sti/citations/AD0773838"><em>The Design of an
Optimizing Compiler</em></a>. American Elsevier (New York, 1975).</p>
</section>
</section>
</section>
</body>
</html>
